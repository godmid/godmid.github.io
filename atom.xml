<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>冥狐的小站</title>
  
  <subtitle>如无必要，勿增实体</subtitle>
  <link href="https://www.darkfox.top/atom.xml" rel="self"/>
  
  <link href="https://www.darkfox.top/"/>
  <updated>2021-11-12T07:29:36.794Z</updated>
  <id>https://www.darkfox.top/</id>
  
  <author>
    <name>DarkFox</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2021全国电赛（F题）图像识别__数字识别</title>
    <link href="https://www.darkfox.top/posts/694f8495/"/>
    <id>https://www.darkfox.top/posts/694f8495/</id>
    <published>2021-11-08T03:30:55.000Z</published>
    <updated>2021-11-12T07:29:36.794Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><span id="more"></span><h3 id="基于openmv的图像识别"><strong>基于openmv的图像识别</strong></h3><h4 id="openmv简介"><strong>openmv简介</strong></h4><p>OpenMV是一个开源，低成本，功能强大的机器视觉模块，以STM32F427CPU为核心，集成了OV7725摄像头芯片，在小巧的硬件模块上，用C语言高效地实现了核心机器视觉算法，提供Python编程接口 。同时 OpenMV也是一个可编程的摄像头，通过Python语言可实现你想要的逻辑。而且摄像头本身也内置了一些图像处理的算法，使用起来也更加的方便，仅需要写一些简单的Python代码，即可轻松的完成各种机器视觉相关的任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在本次赛事中我们听到的最多的怨言就是（openmv4运行内存只有1MB，而openmv4plus运行内存有32MB！）</span><br><span class="line">，因为很多神经网络模型需要更大的内存才能运行。但是这个其实是可以实现的，后面我会简单说明一下。</span><br></pre></td></tr></table></figure><h5 id="一-打开openmv-ide软件"><strong>一、打开OpenMV IDE软件</strong></h5><p><img src="https://img-blog.csdnimg.cn/c84f2fc2a13b4c408867322efa96691a.png" alt="img" loading="lazy"></p><p>选择Cancel（不升级即可）！</p><h5 id="二-openmv4的数字模板匹配识别"><strong>二、openmv4的数字模板匹配识别</strong></h5><p>openmv4的数字识别的基础是需要配置使用NCC模板匹配。通过NCC模板的匹配可把</p><p>需要识别的数字模板图片保存到SD卡中，然后可进行下一步的识别。</p><p><strong>1、我们通过打开模板匹配的历程来直接打开代码使用</strong></p><p>点击文件——示例——openmv——feature detection——template_matching.py</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/test/202111121343657.png" alt="" loading="lazy"></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/test/202111121335156.png" alt="" loading="lazy"></p><p><strong>2、如果运行出现这个窗口那就说明你没有保存模板图片。</strong></p><p><img src="https://img-blog.csdnimg.cn/4043f3c29e4847d59d86ae582e3874d0.png" alt="img" loading="lazy"></p><p><strong>这时我们就需要创建一个模板图片。</strong></p><p><strong>3、首先要打开一个helloworld历程文件</strong></p><p>点击file——examples——01-basics——<a href="http://helloworld.py">helloworld.py</a></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/test/202111121344295.png" alt="" loading="lazy"></p><p><strong>4、在helloworld历程文件中进行匹配0~9这样的数字</strong></p><p>对这些数字进行一一截取（打开摄像头，图像中出现数字之和关闭摄像头，在图像中截取数字，右键选择将图像选择保存到PC），用它们来作为我们的模板图片（此时图片格式后缀为bmp格式）。</p><p>在右边的Frame Buffer框中进行截取</p><p><strong>注意</strong>：不要点Zoom，因为Zoom展示的是放大后的效果，在识别时可能会导致失帧。</p><p><strong>例如：本人截取的一张图片（目前后缀还是bmp）</strong></p><p><img src="https://img-blog.csdnimg.cn/c29ea05f024d4e5c9f01b8d110eb3bb7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA546L5ZOl5p2l5LqG5b-r6LeR,size_8,color_FFFFFF,t_70,g_se,x_16" alt="img" loading="lazy"></p><p><img src="https://img-blog.csdnimg.cn/2e6e9ea350664008a0908f27e633e6ca.bmp" alt="img" loading="lazy"></p><p><strong>注意：模板图片的格式一定要是pgm的格式</strong></p><p>星瞳科技给了一个网址：<strong><a href="https://convertio.co/zh/bmp-pgm/">https://convertio.co/zh/bmp-pgm/</a></strong>，其他的网站也是大同小异</p><p>这个网站用不了的话可以去百度啥的地方随便搜一个</p><p>点击选择文件（刚刚截图的模板图片）</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/test/202111121346073.png" alt="" loading="lazy"></p><p>打开所选的图片，点击转换（注意是不是转换到PGM格式，如果不是请换到PGm格式）</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/test/202111121337807.png" alt="" loading="lazy"></p><p>转换完成之后点击下载即可，此时图片后缀为PGM格式。</p><p><strong>5、将转换的数字图片（PGM）进行保存，一定要保存到OpenMV4的SD卡中，名称自定义</strong></p><p><strong>6、把template.pgm改为你命名的模板图片（PGM）的名称</strong></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/test/202111121338466.png" alt="" loading="lazy"></p><p>例如：我命名的为11</p><p><img src="https://img-blog.csdnimg.cn/ef46e5ea5b614c3ab6b4b2b6de485f03.png" alt="img" loading="lazy"></p><p><strong>7、改完即可运行</strong></p><p><a href="https://book.openmv.cc/image/template-match.html">官方数字识别源代码</a>，此代码为源代码，可在此基础上进行改动。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Template Matching Example - Normalized Cross Correlation (NCC)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This example shows off how to use the NCC feature of your OpenMV Cam to match</span></span><br><span class="line"><span class="comment"># image patches to parts of an image... expect for extremely controlled enviorments</span></span><br><span class="line"><span class="comment"># NCC is not all to useful.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># WARNING: NCC supports needs to be reworked! As of right now this feature needs</span></span><br><span class="line"><span class="comment"># a lot of work to be made into somethin useful. This script will reamin to show</span></span><br><span class="line"><span class="comment"># that the functionality exists, but, in its current state is inadequate.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time, sensor, image</span><br><span class="line"><span class="keyword">from</span> image <span class="keyword">import</span> SEARCH_EX, SEARCH_DS</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reset sensor</span></span><br><span class="line">sensor.reset()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set sensor settings</span></span><br><span class="line">sensor.set_contrast(<span class="number">1</span>)</span><br><span class="line">sensor.set_gainceiling(<span class="number">16</span>)</span><br><span class="line"><span class="comment"># Max resolution for template matching with SEARCH_EX is QQVGA</span></span><br><span class="line">sensor.set_framesize(sensor.QQVGA)</span><br><span class="line"><span class="comment"># You can set windowing to reduce the search image.</span></span><br><span class="line"><span class="comment">#sensor.set_windowing(((640-80)//2, (480-60)//2, 80, 60))</span></span><br><span class="line">sensor.set_pixformat(sensor.GRAYSCALE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load template.</span></span><br><span class="line"><span class="comment"># Template should be a small (eg. 32x32 pixels) grayscale image.</span></span><br><span class="line">template = image.Image(<span class="string">&quot;/template.pgm&quot;</span>)</span><br><span class="line"></span><br><span class="line">clock = time.clock()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run template matching</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">True</span>):</span><br><span class="line">    clock.tick()</span><br><span class="line">    img = sensor.snapshot()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># find_template(template, threshold, [roi, step, search])</span></span><br><span class="line">    <span class="comment"># ROI: The region of interest tuple (x, y, w, h).</span></span><br><span class="line">    <span class="comment"># Step: The loop step used (y+=step, x+=step) use a bigger step to make it faster.</span></span><br><span class="line">    <span class="comment"># Search is either image.SEARCH_EX for exhaustive search or image.SEARCH_DS for diamond search</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># Note1: ROI has to be smaller than the image and bigger than the template.</span></span><br><span class="line">    <span class="comment"># Note2: In diamond search, step and ROI are both ignored.</span></span><br><span class="line">    r = img.find_template(template, <span class="number">0.70</span>, step=<span class="number">4</span>, search=SEARCH_EX) <span class="comment">#, roi=(10, 0, 60, 60))</span></span><br><span class="line">    <span class="keyword">if</span> r:</span><br><span class="line">        img.draw_rectangle(r)</span><br><span class="line"></span><br><span class="line">    print(clock.fps())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="openmv的lenet数字识别">openmv的Lenet数字识别</h3><h4 id="1-简单的de个bug">1、简单的de个bug</h4><p>我估计很多人看到了这个nn识别的方案，但是我估计很多人倒在的这个地方</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202111121438620.png" alt="" loading="lazy"></p><p>因为官方把这个model给删除了（笑），另外还要注意一点，这个nn模型只支持3.6.5及以前的固件版本，如果你的固件是最新的版本的话，请刷回来老的固件版本才能使用。固件的话，自己去github找去。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202111121439528.png" alt="" loading="lazy"></p><p>这个模型，我队友通过万能的淘宝给找回来了（笑）。点击下载<a href="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/test/lenet.network">模型文件</a>，注意：该文件分享有效期为该文章发表日期起十日</p><h4 id="2-简单的跑个例程">2、简单的跑个例程</h4><p>刷好固件，存进去模型之后就可以运行了,例程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># LetNet数字识别例程</span></span><br><span class="line"><span class="keyword">import</span> sensor, image, time, os, nn</span><br><span class="line"></span><br><span class="line">sensor.reset()                         <span class="comment"># 复位并初始化传感器。</span></span><br><span class="line"></span><br><span class="line">sensor.set_contrast(<span class="number">3</span>)</span><br><span class="line">sensor.set_pixformat(sensor.GRAYSCALE) <span class="comment"># Set pixel format to RGB565 (or GRAYSCALE)</span></span><br><span class="line"><span class="comment">#设置图像色彩格式，有RGB565色彩图和GRAYSCALE灰度图两种</span></span><br><span class="line"></span><br><span class="line">sensor.set_framesize(sensor.QVGA)      <span class="comment"># 将图像大小设置为QVGA (320x240)</span></span><br><span class="line"></span><br><span class="line">sensor.set_windowing((<span class="number">128</span>, <span class="number">128</span>))       <span class="comment"># 设置128 x128窗口。</span></span><br><span class="line">sensor.skip_frames(time=<span class="number">100</span>)</span><br><span class="line">sensor.set_auto_gain(<span class="literal">False</span>)</span><br><span class="line">sensor.set_auto_exposure(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载lenet神经网络模型</span></span><br><span class="line">net = nn.load(<span class="string">&#x27;/lenet.network&#x27;</span>)</span><br><span class="line">labels = [<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>]</span><br><span class="line"></span><br><span class="line">clock = time.clock()                <span class="comment"># 创建一个时钟对象来跟踪FPS帧率。</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    clock.tick()                    <span class="comment"># 更新FPS帧率时钟。</span></span><br><span class="line">    img = sensor.snapshot()         <span class="comment"># 拍一张照片并返回图像。</span></span><br><span class="line">    out = net.forward(img.copy().binary([(<span class="number">150</span>, <span class="number">255</span>)], invert=<span class="literal">True</span>))</span><br><span class="line">    max_idx = out.index(<span class="built_in">max</span>(out))</span><br><span class="line">    score = <span class="built_in">int</span>(out[max_idx]*<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">if</span> (score &lt; <span class="number">70</span>):</span><br><span class="line">        score_str = <span class="string">&quot;??:??%&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        score_str = <span class="string">&quot;%s:%d%% &quot;</span>%(labels[max_idx], score)</span><br><span class="line">    img.draw_string(<span class="number">0</span>, <span class="number">0</span>, score_str)</span><br><span class="line"></span><br><span class="line">    print(clock.fps())             </span><br><span class="line">    <span class="comment"># 注意: 当连接电脑后，OpenMV会变成一半的速度。当不连接电脑，帧率会增加。</span></span><br><span class="line">    <span class="comment">#打印当前的帧率。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体的效果图我忘记存了，改天重现一下，但是这个方案的结果是：<strong>识别效果很垃圾！<strong>3，6，9不分1，7不分，2，4不分，再加上帧率只有tm的</strong>5帧</strong>，不适合放在车上边移动边识别（哪怕你停下来识别效果也很拉）</p><h4 id="3-简单的训个模型">3、简单的训个模型</h4><p>这个是使用的官方的nnlenet模型，其实我们蛮可以自己训练一个，官方也在下面说过，可以自己训练模型。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202111121449178.png" alt="" loading="lazy"></p><p>所以我自己训练了一个简单的模型，<a href="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/test/train.png">点击打开模型示意图</a></p><p>因为没学过相关内容，就简单找了找教程，自己搞个足够大的数据集，然后丢进炼丹炉，然后练好后取出。<a href="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/test/train.tflite">模型文件</a>(注意：该文件十日后失效)</p><p>官方例程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># OpenMV Image Classification Example</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sensor, image, time, os, tf</span><br><span class="line"></span><br><span class="line">sensor.reset()                         <span class="comment"># Reset and initialize the sensor.</span></span><br><span class="line">sensor.set_pixformat(sensor.GRAYSCALE)    <span class="comment"># Set pixel format to RGB565 (or GRAYSCALE)</span></span><br><span class="line">sensor.set_framesize(sensor.QVGA)      <span class="comment"># Set frame size to QVGA (320x240)</span></span><br><span class="line">sensor.set_windowing((<span class="number">240</span>, <span class="number">240</span>))       <span class="comment"># Set 240x240 window.</span></span><br><span class="line">sensor.skip_frames(time=<span class="number">2000</span>)          <span class="comment"># Let the camera adjust.</span></span><br><span class="line"></span><br><span class="line">net = <span class="string">&quot;trained.tflite&quot;</span><span class="comment">#模型名称</span></span><br><span class="line">labels = [line.rstrip(<span class="string">&#x27;\n&#x27;</span>) <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&quot;labels.txt&quot;</span>)]<span class="comment">#标签，训练集自带的那个就行</span></span><br><span class="line"></span><br><span class="line">clock = time.clock()</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    clock.tick()</span><br><span class="line"></span><br><span class="line">    img = sensor.snapshot()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># default settings just do one detection... change them to search the image...</span></span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> tf.classify(net, img, min_scale=<span class="number">1.0</span>, scale_mul=<span class="number">0.8</span>, x_overlap=<span class="number">0.5</span>, y_overlap=<span class="number">0.5</span>):</span><br><span class="line">        print(<span class="string">&quot;**********\nPredictions at [x=%d,y=%d,w=%d,h=%d]&quot;</span> % obj.rect())<span class="comment">#打印坐标</span></span><br><span class="line">        img.draw_rectangle(obj.rect())</span><br><span class="line">        <span class="comment"># This combines the labels and confidence values into a list of tuples</span></span><br><span class="line">        predictions_list = <span class="built_in">list</span>(<span class="built_in">zip</span>(labels, obj.output()))<span class="comment">#定义数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(predictions_list)):</span><br><span class="line">            print(<span class="string">&quot;%s = %f&quot;</span> % (predictions_list[i][<span class="number">0</span>], predictions_list[i][<span class="number">1</span>]))<span class="comment">#对应的数字和概率</span></span><br><span class="line"></span><br><span class="line">    print(clock.fps(), <span class="string">&quot;fps&quot;</span>)<span class="comment">#打印个帧率不过分吧</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>好巧不巧，这个效果图我也忘记保存了，改天补上。这个模型的识别效果就比nn好多了，但是仍然有一些不足，3，6，9仍然会有混滫错误。没办法，内存就那一丁点，跑不了太大的model。</p><h3 id="基于k210的数字识别">基于k210的数字识别</h3><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">之前打电赛需要用到嵌入式视觉识别几个数字，在此记录一下我的思路和方案。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>int8_t等数据类型的区别</title>
    <link href="https://www.darkfox.top/posts/52c127a1/"/>
    <id>https://www.darkfox.top/posts/52c127a1/</id>
    <published>2021-11-02T13:08:59.000Z</published>
    <updated>2021-11-02T13:23:50.769Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center>   </center><span id="more"></span><p>工作中经常碰到int8_t、int16_t、int32_t、int64_t、uint8_t、size_t、ssize_t等数据类型，所以有必要对此进行梳理。</p><p><strong>int_t同类</strong></p><p>int_t 为一个结构的标注，可以理解为type/typedef的缩写，表示它是通过typedef定义的，而不是一种新的数据类型。因为跨平台，不同的平台会有不同的字长，所以利用预编译和typedef可以最有效的维护代码。</p><ul><li>int8_t   : typedef signed char;</li><li>uint8_t  : typedef unsigned char;</li><li>int16_t  : typedef signed short ;</li><li>uint16_t : typedef unsigned short ;</li><li>int32_t  : typedef signed int;</li><li>uint32_t : typedef unsigned int;</li><li>int64_t  : typedef signed long long;</li><li>uint64_t : typedef unsigned long long;</li></ul><table><thead><tr><th style="text-align:left">Specifier</th><th style="text-align:left">Common Equivalent</th><th style="text-align:left">Signing</th><th style="text-align:left">Bits</th><th style="text-align:left">Bytes</th><th style="text-align:left">Minimum Value</th><th style="text-align:left">Maximum Value</th></tr></thead><tbody><tr><td style="text-align:left"><code>int8_t</code></td><td style="text-align:left"><code>signed char</code></td><td style="text-align:left">Signed</td><td style="text-align:left">8</td><td style="text-align:left">1</td><td style="text-align:left">-128</td><td style="text-align:left">127</td></tr><tr><td style="text-align:left"><code>uint8_t</code></td><td style="text-align:left"><code>unsigned char</code></td><td style="text-align:left">Unsigned</td><td style="text-align:left">8</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">255</td></tr><tr><td style="text-align:left"><code>int16_t</code></td><td style="text-align:left"><code>short</code></td><td style="text-align:left">Signed</td><td style="text-align:left">16</td><td style="text-align:left">2</td><td style="text-align:left">-32,768</td><td style="text-align:left">32,767</td></tr><tr><td style="text-align:left"><code>uint16_t</code></td><td style="text-align:left"><code>unsigned short</code></td><td style="text-align:left">Unsigned</td><td style="text-align:left">16</td><td style="text-align:left">2</td><td style="text-align:left">0</td><td style="text-align:left">65,535</td></tr><tr><td style="text-align:left"><code>int32_t</code></td><td style="text-align:left"><code>int</code></td><td style="text-align:left">Signed</td><td style="text-align:left">32</td><td style="text-align:left">4</td><td style="text-align:left">-2,147,483,648</td><td style="text-align:left">2,147,483,647</td></tr><tr><td style="text-align:left"><code>uint32_t</code></td><td style="text-align:left"><code>unsigned int</code></td><td style="text-align:left">Unsigned</td><td style="text-align:left">32</td><td style="text-align:left">4</td><td style="text-align:left">0</td><td style="text-align:left">4,294,967,295</td></tr><tr><td style="text-align:left"><code>int64_t</code></td><td style="text-align:left"><code>long long</code></td><td style="text-align:left">Signed</td><td style="text-align:left">64</td><td style="text-align:left">8</td><td style="text-align:left">-9,223,372,036,854,775,808</td><td style="text-align:left">9,223,372,036,854,775,807</td></tr><tr><td style="text-align:left"><code>uint64_t</code></td><td style="text-align:left"><code>unsigned long long</code></td><td style="text-align:left">Unsigned</td><td style="text-align:left">64</td><td style="text-align:left">8</td><td style="text-align:left">0</td><td style="text-align:left">18,446,744,073,709,551,615</td></tr></tbody></table><p><strong>size_t与ssize_t</strong></p><p>size_t主要用于计数，如sizeof函数返回值类型即为size_t。在不同位的机器中所占的位数也不同，size_t是无符号数，ssize_t是有符号数。</p><ul><li>在32位机器中定义为：typedef  unsigned int size_t; （4个字节）</li><li>在64位机器中定义为：typedef  unsigned long size_t;（8个字节）</li></ul><p>由于size_t是无符号数，因此，<strong>当变量有可能为负数时，必须使用ssize_t</strong>。因为当有符号整型和无符号整型进行运算时，有符号整型会先自动转化成无符号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> a;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> b = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    a = b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b=&quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//b=-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//a=65535</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，int 无论在32位还是64位机器中，都是4个字节, 且带符号，可见size_t与int 的区别之处。</p><p>下面是stdint.h中的详细定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 7.18.1.1  Exact-width integer types */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">char</span> <span class="keyword">int8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>   <span class="keyword">uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">short</span>  <span class="keyword">int16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span>  <span class="keyword">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>  <span class="keyword">int32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span>   <span class="keyword">uint32_t</span>;</span><br><span class="line">__MINGW_EXTENSION <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span>  <span class="keyword">int64_t</span>;</span><br><span class="line">__MINGW_EXTENSION <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>   <span class="keyword">uint64_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 7.18.1.2  Minimum-width integer types */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">char</span> <span class="keyword">int_least8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>   <span class="keyword">uint_least8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">short</span>  <span class="keyword">int_least16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span>  <span class="keyword">uint_least16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>  <span class="keyword">int_least32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span>   <span class="keyword">uint_least32_t</span>;</span><br><span class="line">__MINGW_EXTENSION <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span>  <span class="keyword">int_least64_t</span>;</span><br><span class="line">__MINGW_EXTENSION <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>   <span class="keyword">uint_least64_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  7.18.1.3  Fastest minimum-width integer types</span></span><br><span class="line"><span class="comment"> *  Not actually guaranteed to be fastest for all purposes</span></span><br><span class="line"><span class="comment"> *  Here we use the exact-width types for 8 and 16-bit ints.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">char</span> <span class="keyword">int_fast8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="keyword">uint_fast8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">short</span>  <span class="keyword">int_fast16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span>  <span class="keyword">uint_fast16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>  <span class="keyword">int_fast32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span>  <span class="keyword">int</span>  <span class="keyword">uint_fast32_t</span>;</span><br><span class="line">__MINGW_EXTENSION <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span>  <span class="keyword">int_fast64_t</span>;</span><br><span class="line">__MINGW_EXTENSION <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>   <span class="keyword">uint_fast64_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 7.18.1.5  Greatest-width integer types */</span></span><br><span class="line">__MINGW_EXTENSION <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span>  <span class="keyword">intmax_t</span>;</span><br><span class="line">__MINGW_EXTENSION <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>   <span class="keyword">uintmax_t</span>;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;center&gt;   &lt;/center&gt;</summary>
    
    
    
    <category term="C语言" scheme="https://www.darkfox.top/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言数据类型" scheme="https://www.darkfox.top/tags/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>c/c++ long int与long long的区别</title>
    <link href="https://www.darkfox.top/posts/66a918cc/"/>
    <id>https://www.darkfox.top/posts/66a918cc/</id>
    <published>2021-11-02T11:49:28.000Z</published>
    <updated>2021-11-02T13:26:47.476Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center>   </center><h1>long int</h1><p>long int即long，给人的感觉好像是长整型，但实际上，它和int一样，只有32位。cppreference给出的定义是——</p><blockquote><p><strong>int</strong> - basic integer type. The keyword int may be omitted if any of the modifiers listed below are used. If no length modifiers are present, it’s guaranteed to have a width of at least 16 bits. However, on 32/64 bit systems it is almost exclusively guaranteed to have width of at least 32 bits.<br><strong>long</strong> - target type will have width of at least 32 bits.</p></blockquote><p>在实际的使用中，long与int几乎没有区别，比如——</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> l = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10000000</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;size of long:%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;size of int:%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;l = %d\n&quot;</span>,l);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>,i);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2018122510141490.png" alt="在这里插入图片描述" loading="lazy"><br>　　既然long int与int相同，那么为什么还有long int这种尴尬的类型呢？<br>　　原因是早期的C编译器定义了long int占用4个字节，int占用2个字节，long int是名副其实的<strong>长整型</strong>。在ANSI C的标准中，对长整型的定义也是<strong>long int应该至少和int一样长</strong>，而不是long int 一定要比int占用存储字节长。新版的C/C++标准兼容了早期的这一设定。</p><span id="more"></span><h1>long long</h1><p>long long则不同，long long是C++的64位整型的基本类型，“现任”长整型，从C99开始引入这个概念，在后续的标准中完善概念和定义，C++11官方正式标准如下——</p><blockquote><p><strong>long long</strong> - target type will have width of at least 64 bits.(since C++11)</p></blockquote><p>long long占用8个字节，数据表示范围也从int的[ − 2 31 , 2 31 − 1 ] [-2^{31},2^{31}-1][−231,231−1]，升级到[ − 2 63 , 2 63 − 1 ] [-2^{63},2^{63}-1][−263,263−1]。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> l = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ll = <span class="number">100000000000000</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;size of long:%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;size of int:%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;size of long long:%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>));</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;l = %d\n&quot;</span>,l);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>,i);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;ll = %lld\n&quot;</span>,ll);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20181225103911667.png" alt="在这里插入图片描述" loading="lazy"><br>　　long long是C++的正式标准，这也就意味着，该类型不会因为编译器或者开发平台的不同而有所差异，放之四海而皆准，而且与一些系统函数、类库都有很好的交互（如常见的printf、scanf、cin和cout等）。与之相反，出身MS的__int64就有点不受待见了，在不同的编译器上可能水土不服。</p><h1>__int64</h1><p>在早期的代码中，可能会遇到<code>__int64</code>这种类型，这应该算是“历史遗留”问题。早期的C/C++标准中并没有规定64位长整型的规范，因此不同的编译器对这一模糊概念有不同的定义，我们熟知的VC6.0采用了<code>__int64</code>这种类型来表示64位长整型——</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">__int64 i64 = -<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">63</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;__int64:&quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(__int64)&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;i64 = &quot;</span>&lt;&lt;i64&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20181225104812530.png" alt="在这里插入图片描述" loading="lazy"><br>　　与long long具有相同的效果，但是，__int64并不是正式规范，比如，如果你使用的是MinGW的编译器的话，打开__int64的定义会发现——<br><img src="https://img-blog.csdnimg.cn/20181225105553149.png" alt="img" loading="lazy"><br>　　VS 2017虽然把__int64作为了一种内置类型，但是也做了类似的处理，使得__int64与long long没有肉眼可见的差别。但如果你使用的开发环境比较早期，那么可能就要专门研究一下__int64了。比如说，古老的VC6.0并没有long long这种类型，而__int64的输入输出，又需要printf和%I64d的配合，而不是%lld或者直接用cout。</p><h1>总结</h1><p>C/C++与Java等语言不同，具有较高的自由度，由于某些历史原因，某些概念在不同的平台上有不同的解释，虽然现在新版本的C++标准和编译器都在做兼容性工作，你可以在__int64与long long之间无缝切换，但至少，我们要清楚两者的不同。</p><table><thead><tr><th>类型</th><th>存储字节</th><th>表示范围</th></tr></thead><tbody><tr><td>int</td><td>4</td><td>-2147483648~2147483647</td></tr><tr><td>short int</td><td>2</td><td>-32768～+32767</td></tr><tr><td>long</td><td>4</td><td>-2147483648~2147483647（二十亿，约1 0 10 10^{10}1010）</td></tr><tr><td>long long</td><td>8</td><td>9223372036854775808～+9223372036854775807(九百亿亿，约1 0 19 10^{19}1019)</td></tr><tr><td>__int64</td><td>8</td><td>9223372036854775808～+9223372036854775807</td></tr></tbody></table><h1>参考链接</h1><p>1.<a href="https://blog.csdn.net/qq_31736627/article/details/52912691">https://blog.csdn.net/qq_31736627/article/details/52912691</a><br>2.<a href="https://en.cppreference.com/w/cpp/language/types">https://en.cppreference.com/w/cpp/language/types</a><br>3.<a href="https://www.cnblogs.com/ChenDinghao/p/6480937.html">https://www.cnblogs.com/ChenDinghao/p/6480937.html</a><br>4.<a href="https://blog.csdn.net/sk18192449347/article/details/55000087">https://blog.csdn.net/sk18192449347/article/details/55000087</a></p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;center&gt;   &lt;/center&gt;
&lt;h1&gt;long int&lt;/h1&gt;
&lt;p&gt;long int即long，给人的感觉好像是长整型，但实际上，它和int一样，只有32位。cppreference给出的定义是——&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; - basic integer type. The keyword int may be omitted if any of the modifiers listed below are used. If no length modifiers are present, it’s guaranteed to have a width of at least 16 bits. However, on 32/64 bit systems it is almost exclusively guaranteed to have width of at least 32 bits.&lt;br&gt;
&lt;strong&gt;long&lt;/strong&gt; - target type will have width of at least 32 bits.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在实际的使用中，long与int几乎没有区别，比如——&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; l = &lt;span class=&quot;number&quot;&gt;10000000&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;10000000&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;size of long:%d\n&amp;quot;&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;size of int:%d\n&amp;quot;&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;l = %d\n&amp;quot;&lt;/span&gt;,l);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;i = %d\n&amp;quot;&lt;/span&gt;,i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1234567891011&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2018122510141490.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;
　　既然long int与int相同，那么为什么还有long int这种尴尬的类型呢？&lt;br&gt;
　　原因是早期的C编译器定义了long int占用4个字节，int占用2个字节，long int是名副其实的&lt;strong&gt;长整型&lt;/strong&gt;。在ANSI C的标准中，对长整型的定义也是&lt;strong&gt;long int应该至少和int一样长&lt;/strong&gt;，而不是long int 一定要比int占用存储字节长。新版的C/C++标准兼容了早期的这一设定。&lt;/p&gt;</summary>
    
    
    
    <category term="C语言" scheme="https://www.darkfox.top/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言数据类型" scheme="https://www.darkfox.top/tags/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Bug</title>
    <link href="https://www.darkfox.top/posts/dc1f9f4/"/>
    <id>https://www.darkfox.top/posts/dc1f9f4/</id>
    <published>2021-09-28T11:45:55.000Z</published>
    <updated>2021-10-02T05:57:57.077Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center>   </center><span id="more"></span><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">用来记录那些奇奇怪怪的BUG，解决的bug将放入debug文件里面</summary>
    
    
    
    <category term="bug" scheme="https://www.darkfox.top/categories/bug/"/>
    
    
    <category term="bug" scheme="https://www.darkfox.top/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>Debug</title>
    <link href="https://www.darkfox.top/posts/ad6468a3/"/>
    <id>https://www.darkfox.top/posts/ad6468a3/</id>
    <published>2021-09-28T11:25:27.000Z</published>
    <updated>2021-10-02T05:57:57.080Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center>   </center> <span id="more"></span><h5 id="00x01-命名">00x01 命名</h5><p>这是有个远古之前犯的bug，今天来复现一下。</p><p>如图所示，一个极其简单的入门级别的操作代码，没有啥问题吧？</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/pic/20210928193215.png" alt="" loading="lazy"></p><p>但是吼，报错了嘿</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/pic/20210928194231.png" alt="" loading="lazy"></p><p>仔细一看，发现了么，是因为命名出现了问题。<img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/pic/20210928194412.png" alt="" loading="lazy"></p><p>改一下名字就好了，(<em>^_^</em>)</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/pic/20210928194508.png" alt="" loading="lazy"></p><p>00x03</p><p>00x04</p><p>00x05</p><p>00x06</p><p>00x07</p><p>00x08</p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">今天突然发现犯了以前的错误，但是忘记了debug方式，所以在此记录下，以备后患</summary>
    
    
    
    <category term="bug" scheme="https://www.darkfox.top/categories/bug/"/>
    
    
    <category term="bug" scheme="https://www.darkfox.top/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>写这句话的人建议拉去并网发电</title>
    <link href="https://www.darkfox.top/posts/3391b988/"/>
    <id>https://www.darkfox.top/posts/3391b988/</id>
    <published>2021-09-27T13:06:42.000Z</published>
    <updated>2021-09-27T13:09:49.275Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/pic/202109272108878.jpg" alt="1" loading="lazy"></p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css&quot;&gt;&lt;scrip</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>宽禁带半导体材料的电力电子器件概述</title>
    <link href="https://www.darkfox.top/posts/946a5cb7/"/>
    <id>https://www.darkfox.top/posts/946a5cb7/</id>
    <published>2021-09-27T09:53:38.000Z</published>
    <updated>2021-09-27T11:34:05.479Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h4 id="百字总结">百字总结</h4><p>宽禁带半导体材料被誉为第三代半导体材料，典型的材料代表有碳化硅、氮化镓、金刚石。在电力电子元件以及材料的研制中，碳化硅的研究时间最为长久，紧接其后的便是氮化镓。第三代半导体材料相比较传统工艺材料有明显的三大特性。比硅高得多的临界雪崩击穿电场强度和载流子饱和漂移速度、较高的热导率和相差不大的载流子迁移率，因此，基于宽禁带半导体材料(如碳化硅)的电力电子器件将具有比硅器件高得多的耐受高电压的能力、低得多的通态电阻、更好的导热性能和热稳定性以及更强的耐受高温和射线辐射的能力，许多方面的性能都是成数量级地提高。<br>之所以最近该材料广受关注，是因为人们普遍认为硅基材料已经接近材料特性的理论极限。为了人类的进步，以及国家的战略发展，众多攻城狮和科学家将精力放在了此处。目前该新型材料（其实不新了，最早可以追溯到上个世纪）的发展一直受制于材料的提炼、制造以及随后半导体制造工艺的困难。目前金刚石在这些宽禁带半导体材料中性能是最好的，很多人称之为最理想的或最具前景的电力半导体材料。但是金刚石材料提炼和制造以及随后的半导体制造工艺也是最困难的（所以才有人去研究石墨烯）。目前，碳化硅的工艺较为成熟。其优异的特性使其在研制高温、高频、大功率、抗辐射器件以及紫外探测器、短波发光二极管等方面具有广阔的应用前景。</p><span id="more"></span><h3 id="何为宽禁带半导体材料">何为宽禁带半导体材料</h3><p>固体中电子的能量具有不连续的量值，电子都分布在一些相互之间不连续的能带上。价电子所在能带与自由电子所在能带之间的间隙称为禁带或带隙。所以禁带的宽度实际上反映了被束缚的价电子要成为自由电子所必须额外获得的能量。硅的禁带宽度为1.12电子伏特(eV)，而宽禁带半导体材料是指禁带宽度在2.3eV及以上的<a href="https://baike.baidu.com/item/%E5%8D%8A%E5%AF%BC%E4%BD%93%E6%9D%90%E6%96%99/5078">半导体材料</a>，典型的是<a href="https://baike.baidu.com/item/%E7%A2%B3%E5%8C%96%E7%A1%85/245856">碳化硅</a>(SiC)、氮化镓(GaN)、金刚石等材料。宽禁带半导体材料是被称为第三代半导体材料。</p><h3 id="sic器件概要">SIC器件概要</h3><p>以碳化硅(SiC)和氮化镓(GaN)为代表的第三代半导体材料具有非常显著的性能优势和巨大的产业带动作用，欧美日等发达国家和地区都将发展碳化硅半导体技术列入国家战略，积极投入巨资支持发展。随着SiC衬底、外延材料、工艺制造技术的改进，器件性能和生产成本不断降低。SiC电力电子器件打破了传统Si器件由于材料特性极限所造成的性能瓶颈，推动着电力电子技术领域的革新与发展。当前，传统电网正向以电力电子技术广泛应用为代表的智能电网方向发展。以未来电力电子变压器的核心应用为代表，对超高压大功率器件提出了更高的性能要求。碳化硅(SiC)器件具有高耐压、大电流、高频率、低损耗等优势，大大推动了设备小型化、轻量化、高效化、低能耗的发展，因此，高压大功率SiC材料及器件的实用化将决定电力电子设备的发展未来。</p><p>对于 10 kV 超高压 SiC 电力电子器件，一些工艺难度较低的器件，如 PiN 二极管、肖特基势垒二极管(SBD)等，发展较早，正趋向成熟；对于栅控器件，如 MOSFET、 IGBT，由 SiC 材料所带来的一些问题，如栅氧界面态密度高、沟道迁移率低、器件可靠性差等，随着近年来材料及工艺技术的提高，逐渐获得解决和完善，尽管起步较晚，但是发展迅速。 本文将重点针对近年来国内外智能电网用 10 kV以上 SiC 二极管(PiN、 SBD、 JBS 与 MPS)和晶体管(SiC MOSFET 与 IGBT)的器件结构、技术手段、发展现状来阐述超高压 SiC 电力电子器件的设计思路及其性能特点。</p><h4 id="超高压-sicpin-二极管">超高压 SiCPiN 二极管</h4><p>国外对于 SiCPiN 二极管的研究始于 20 世纪 90年代，凭借其简单且成熟的工艺优势， SiCPiN 二极管成为 SiC 电力电子器件的主力之一，尤其在超高压领域的研究已较为成熟。通过不断优化与改进结终端技术， SiCPiN 二极管成为目前超高压领域发展最完善的电力电子器件  。</p><p>2001 年日本关西电力研究中心和 CREE 共同报道了耐压达到 12~19 kV 的 MESA-JTE 结构的SiCPiN 二极管， 成为世界上首个超过 10 kV 的 SiC功率整流器。 器件通过结合 MESA 与单区 JTE 两种结终端技术，从而降低边缘电场集中效应，提高了器件击穿电压。</p><p>对于不同外延层浓度与厚度的SiCPiN二极管(A：N-漂移区掺杂浓度2×1014cm–3，厚度120μm；B：N-漂移区掺杂浓度8×1013cm–3，厚度200μm)，击穿电压分别达到了14.9 kV与19 kV，100 A/cm2时导通压降UF分别为4.4 V与6.5 V，关断延迟仅为商业化400 V耐压的Si基PiN二极管的1/4，动态损耗大大降低，如图1所示。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/pic/202109271830648.png" alt="image-20210927183034494" loading="lazy"></p><p>做为首个超过10 kV的SiC功率整流器，该研究对未来超高压SiC功率器件的发展具有重要的意义及借鉴作用。但是，MESA结构的缺点在于斜面角度与掺杂浓度需要进行优化，而且实际工艺中往往受到氧化层间电荷的影响。另一方面，器件击穿电压对于单区JTE区的掺杂浓度范围很敏感，因此在实际工艺中，要获得最大击穿电压对应的最优JTE掺杂浓度非常困难。因此，近年来国内外学者不断优化改进JTE终端结构，进一步提高了SiCPiN二极管性能。</p><p>2015年，Naoki Kaji等人通过结合间距调变JTE(space-modulated JTE，SM-JTE)与双区JTE(double zone JTE)结构，研制出了一种击穿电压超过26.9 kV的SiCPiN二极管，是目前报道的击穿电压最高的SiC电力电子器件，如图2所示。新结构通过优化SM-JTE的宽度与间距，降低了单区JTE边缘处的电场集中现象，从而克服了传统单区JTE存在的优化掺杂浓度范围窄的缺点。同时，与传统双区JTE结构相比，JTE区同样只需要2次离子注入，没有增加工艺步骤与难度。该结构器件特性如图3所示。一方面，相比传统单区JTE与双区JTE结构，新结构JTE优化掺杂浓度范围显著扩宽；另一方面，当N-区厚度分别为98μm和268μm时二极管的击穿电压超过13 kV和26.9 kV，达到了理论平行平面结击穿电压的70%，同时差分导通电阻分别为1.87 mΩ·cm2及9.7 mΩ·cm2，正向压降分别为3.1 V和4.72 V，在保证优良正向导通特性的条件下，大大提高了器件的击穿电压。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/pic/202109271831805.png" alt="image-20210927183155665" loading="lazy"></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/pic/202109271832155.png" alt="image-20210927183209986" loading="lazy"></p><h4 id="超高压sic-sbd二极管">超高压SiC SBD二极管</h4><p>肖特基势垒二极管(schottky barrier diode，SBD)是一种金半接触的整流器件，SiC SBD相较于SiCPiN二极管，其主要优势在于导通压降只有1 V左右，仅为PiN二极管的1/3，大大降低了器件的导通损耗。但是，金半接触也导致其反向耐压较低，泄漏电流较大，如今商业化的SiC SBD大多在千伏量级，对于10 kV以上的超高压领域，目前国内外的研究均较少。2003年，赵建华等人报道了首个10 kV SiC SBD二极管。该器件的终端利用刻蚀与外延生长形成多级JTE结构，如图4所示。二极管击穿电压为10.8 kV，电流密度48 A/cm2时正向导通压降为6 V，比导通电阻187 mΩ·cm2。器件的缺点显而易见，反向泄漏电流较大。</p><h4 id="超高压sic-jbs与mps二极管">超高压SiC JBS与MPS二极管</h4><p>JBS与MPS二极管结构上类似，均是结合PiN高耐压大电流与SBD低导通压降、高开关速度的优点，其区别在于：JBS二极管选用肖特基势垒较低的金属接触，漂移区较薄，导通时仅SBD部分参与导电，关断时PN结反偏形成耗尽层承受耐压，多用于低压领域；而MPS选用肖特基势垒相对较高的金属接触，漂移区较厚，导通时SBD与PiN均参与导电，多用于高压领域。JBS与MPS的综合性能均高于单一PiN和SBD器件，且工艺难度不大，因此，在超高压应用领域，SiC JBS与MPS二极管扮演着重要角色。</p><h4 id="超高压sic-mosfet与igbt晶体管">超高压SiC MOSFET与IGBT晶体管</h4><p>金属氧化物场效应半导体(MOSFET)与绝缘栅双极型晶体管(IGBT)均是栅控型电力电子器件，其输入阻抗高、温度稳定性好、安全工作区大，是目前中高压领域发展的主流器件，尤其IGBT更是结合了MOSFET与BJT的优点，在高压大电流应用领域远超其他器件，是目前发展最为迅速的功率器件。同样，在10 kV领域，SiC MOSFET与SiC IGBT相比传统器件具有巨大优势。一方面，SiC MOSFET与SiC IGBT大大降低了功率损耗，减少了系统元器件数目，简化了电路拓扑结构，提高了效率。另一方面，超高压SiC MOSFET与SiC IGBT为一些<br>受到Si材料极限限制的应用领域，如固态电力电子变压器，提供了扩展发展空间的途径。由CREE公司设计研制的10~15 kV SiCMOSFET和15 kV SiC IGBT代表了目前超高压功率器件发展的最高技术水平，并引起了国际上对于超高压SiC MOSFET和SiC IGBT晶体管的广泛研究。2015年Jeffrey B等人报道了新一代的10 kVSiC MOSFET，如图8所示，对于8.1 mm×8.1 mm的器件，通过优化改进，其室温下导通电阻从第一代的160 mΩ降低至100 mΩ。</p><h4 id="sic器件在电力电子变压器中的应用">SiC器件在电力电子变压器中的应用</h4><p>电力电子变压器与传统变压器相比具有重量轻、体积小、单位功率因数高等优点。随着分布式发电系统、智能电网技术以及可再生能源的发展，面向智能电网的电力电子变压器逐渐发展为具有电气隔离、可再生能源并网接入等多种功能的智能化电力电子设备。然而，早期电力电子变压器的理论和实验研究受到当时大功率器件和高压大功率变换技术发展水平以及Si基器件材料性能极限带来的开关频率的限制，未能实用化。随着10 kV以上SiC电力电子器件的出现，电力电子变压器的研究取得了新的突破。</p><p>2009年W Sung等人报道了15 kV SiCIGBT，打破了传统Si基功率开关器件的频率限制，使固态变压器取代传统配电变压成为可能。如图14所示的FREEDM系统中，15 kV SiC IGBT将被用于固态变压器技术中，取代系统中变压器和配电控制，实现可再生能源的发展，提高电能质量。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/pic/202109271859338.png" alt="image-20210927185929187" loading="lazy"></p><p>2014年J. W. Palmour等人报道了15 kVSiC MOSFET，与商业化6.5 kV的Si IGBT比较，如表2所示，击穿电压高2倍多，且开关损耗仅为其1/30。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/pic/202109271901898.png" alt="image-20210927190134793" loading="lazy"></p><p>15 kV的SiC MOSFET和JBS被应用在第二代电力电子变压器中，与第一代采用6.5 kV的硅基IGBT电力电子变压器(如图15所示)相比较，不再使用复杂的器件或拓扑串联结构，开关频率由原来的1 kHz提升至20 kHz，开关损耗大大降低，并且可靠性大大提高。</p><h4 id="超高压sic器件在直流及交流断路器中的应用">超高压SiC器件在直流及交流断路器中的应用</h4><p>直流断路器凭借其高速的开关特性和方便的控制能力，以及瞬时、高频、低损耗和高安全性的特性得到了广泛的关注。15 kV SiC ETO器件被应用于直流断路器，如图所示，实现了9 kV/50 A下的可靠性工作。在大容量柔性直流输电技术发展的推动下，超高压大容SiC器件在未来直流断路器的应用中必定具有光明的应用前景。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/pic/202109271908466.png" alt="image-20210927190806346" loading="lazy"></p><p>交流固态断路器的主要特点就是快速性和可靠性，对电网故障的快速检测系统起着十分重要的作用。目前已有研究者提出基于15 kV SiC ETO及15 kV PiN二极管的混合交流断路器，如图所示，实现了中压领域超过100 A的故障电流条件下，4 ms内快速断路。相比传统机械断路器40~100 ms，速度提升了一个数量级，大大提高了交流固态断路器的快速性和可靠性。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/pic/202109271910964.png" alt="image-20210927191023879" loading="lazy"></p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;百字总结&quot;&gt;百字总结&lt;/h4&gt;
&lt;p&gt;宽禁带半导体材料被誉为第三代半导体材料，典型的材料代表有碳化硅、氮化镓、金刚石。在电力电子元件以及材料的研制中，碳化硅的研究时间最为长久，紧接其后的便是氮化镓。第三代半导体材料相比较传统工艺材料有明显的三大特性。比硅高得多的临界雪崩击穿电场强度和载流子饱和漂移速度、较高的热导率和相差不大的载流子迁移率，因此，基于宽禁带半导体材料(如碳化硅)的电力电子器件将具有比硅器件高得多的耐受高电压的能力、低得多的通态电阻、更好的导热性能和热稳定性以及更强的耐受高温和射线辐射的能力，许多方面的性能都是成数量级地提高。&lt;br&gt;
之所以最近该材料广受关注，是因为人们普遍认为硅基材料已经接近材料特性的理论极限。为了人类的进步，以及国家的战略发展，众多攻城狮和科学家将精力放在了此处。目前该新型材料（其实不新了，最早可以追溯到上个世纪）的发展一直受制于材料的提炼、制造以及随后半导体制造工艺的困难。目前金刚石在这些宽禁带半导体材料中性能是最好的，很多人称之为最理想的或最具前景的电力半导体材料。但是金刚石材料提炼和制造以及随后的半导体制造工艺也是最困难的（所以才有人去研究石墨烯）。目前，碳化硅的工艺较为成熟。其优异的特性使其在研制高温、高频、大功率、抗辐射器件以及紫外探测器、短波发光二极管等方面具有广阔的应用前景。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>MATLAB的常用函数</title>
    <link href="https://www.darkfox.top/posts/6b735cd/"/>
    <id>https://www.darkfox.top/posts/6b735cd/</id>
    <published>2021-09-26T01:42:13.000Z</published>
    <updated>2021-09-27T11:37:40.326Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center>   </center><span id="more"></span><h3 id="第一篇：matlab软件函数">第一篇：Matlab软件函数</h3><h4 id="一-软件操作函数">一、软件操作函数</h4><h5 id="1-命令窗口函数：">1）命令窗口函数：</h5><p>clc：清空命令窗口，使用向上箭头翻看命令。</p><p>open:打开文件，文本文件（<em>.doc），可执行文件（</em>.exe），图形文件（<em>.fig），超文本文件（</em>.html，<em>.htm），MATLAB数据库文件（</em>.mat），simulink模型文件*.mdl），MATLAB p文件（<em>.p），PDF文件（</em>,pdf），PPT文件（<em>.ppt），工程文件（</em>.prj），网址(*.url)和变量等。</p><p>format：设置数据输出格式。format（‘command’）</p><p>disp:在commandwindow中显示字符和矩阵。</p><p>​    disp(x)—x为矩阵</p><p>​    disp(‘x’)—x为字符</p><p>​    disp([‘x’ a ‘y’])—打印字符合集</p><p>clear：从工作空间中清空变量。clear, clear name,clear global name, clear –regexpexpr1 expr2</p><p>​    clear:清空工作空间的所有变量</p><p>​    clear name—clear(‘name’):清空以name命名的m文件，mex文件或变量名</p><p>​    clear globe name:完全清空以name命名的全局变量，清空后该全局变量不能被函数调用。</p><h5 id="2-帮助函数">2)帮助函数</h5><p>demo：通过help浏览器访问工具箱的演示文件。—demo’MATLAB’</p><p>doc:在help浏览器中打开相应帮助页面。</p><p>help：在MATLAB命令窗口中显示MATLAB的m函数，mdl文件，工具箱等的帮助信息。</p><h4 id="二-文件编程函数">二、文件编程函数</h4><h5 id="1-文件目录操作函数">1)文件目录操作函数</h5><p>dir:显示当前工作空间目录文件  dir; dirname;</p><p>files=dir(‘directory’):返回指定目录中的文件信息到结构体file中，结构体file中包含的信息为：name,data,bytes,isdir,datenum</p><h5 id="2-文件编辑调试函数">2)文件编辑调试函数</h5><p>dbstep:从当前断点中执行一行或多行代码 dbstep; dbstep nlines;dbstep in</p><p>dbstop:设置断点  dbstop inmfile ; dbstop in mfile at lineno</p><p>debug:列举出m文件的调试函数</p><p>mlint:检查m文件可能出现的问题，并报告结果—mlint(‘m-filename’)</p><p>profile:调试优化m文件代码—界面Desktop–Profiler</p><h5 id="3-文件脚本函数">3)文件脚本函数</h5><p>function:声明函数  function [out1, out2, …]=funname(in1,in2,…)：定义一个名为funname的函数，该函数输入参数为in1、in2、……输出参数为out1、out2、……</p><p>input:请求用户输入  user_entry=input(‘prompt’) ：在屏幕上显示prompt作为提示，等待键盘输入，并返回用户输入的值。user_entry=input(‘prompt’,‘s’)：将键入的字符返回为文本变量而非变量名或数值。</p><h5 id="4-语句控制函数">4）语句控制函数</h5><p>break:终止执行for循环或者while循环, break语句结束循环，把语句控制返回给循环结束后的语句。</p><p>continue:传递控制给下一个for或while循环</p><p>case:条件为真时执行代码,case是switch语法中的允许有条件执行语句的一部分。case语句块由case函数，case表达式和其后的一条或多条语句构成。</p><p>switch:有条件执行的代码，在基本语法中，当switch_expr ==case_expr时执行相关语句，如果没有实例表达式与switch表达式相匹配，则语句控制传递给otherwise语句块。</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">`method=&#x27;bigger&#x27;;`</span><br><span class="line">`switch method`</span><br><span class="line">`case&#x27;bigger&#x27;`</span><br><span class="line">`a=3;`</span><br><span class="line">`case&#x27;middle&#x27;`</span><br><span class="line">`a=2;`</span><br><span class="line">`case&#x27;small&#x27;`</span><br><span class="line">`a=1;`</span><br><span class="line">`otherwise`</span><br><span class="line">`a=0;`</span><br><span class="line">`end`</span><br></pre></td></tr></table></figure><p>If:如果条件为真，则执行相关语句  if expression, statements, end</p><p>elseif:—if expression1,statement1,elseifexpresstion,statement2,end</p><p>else:如果条件为假时执行语句</p><p>end:终止代码块，或为数组的最后一位数字索引, end用来终止for、while、switch、try和if语句—end函数也作为数组的最后一个索引，如X(3:end)和X(1,1:2:end-1)。可以用end增加数组，如X存在的情况下使用X(end+1)=5。</p><p>error:显示信息并终止函数—error(‘说明信息’)</p><p>for：反复运算指定代码块 forvariable=initval:endval, statements, end</p><p>while:当条件为真时重复执行语句—whileexpression,statement,end</p><p>return:从调用函数中返回</p><h5 id="5-内存控制函数">5)内存控制函数</h5><p>global:声明全局变量  初始化为一个空矩阵</p><p>isglobal:判断一个变量是否是全局变量</p><p>persistent:定义静态全局常量</p><h3 id="第二篇：数据类型函数">第二篇：数据类型函数</h3><h4 id="三-基本数据类型函数">三、基本数据类型函数</h4><h5 id="1-数值函数">1）数值函数</h5><p>double：转换为双精度浮点数</p><p>single:转换为单精度浮点数</p><p>typecast：在不改变数据大小情况下转换数据类型 Y=typecast(X,type)</p><p>​    type可选范围:‘uint8’、‘int8’、‘uint16’、‘int16’、‘uint32’、‘int32’、‘uint64’、‘int64’、‘single’、‘double’</p><p>arrayfun:把函数应用到数组中的每个元素 A=arrayfun(fun, S)应用fun函数到数组S中的每个元素，将结果返回给数组A。</p><p>​    A=arrayfun(fun, S, T, …)</p><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x(1).f1&#x3D;2;x(2).f1&#x3D;3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x(1).f2&#x3D;3;x(2).f2&#x3D;3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result&#x3D;arrayfun(@(x)isequal(x.f1,x.f2),x)</span><br></pre></td></tr></table></figure><p>cast:转变数值数据类型 B=cast(A,newclass)</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`a=int16(2);`</span><br><span class="line">`b=cast(a,&#x27;char&#x27;);`</span><br><span class="line">`cate=class(b)`</span><br></pre></td></tr></table></figure><p>cat:连接数组  C=cat(dim, A,B)–cat(2,A,B)与[A,B]相同，cat(1,A,B)与[A;B]相同</p><p>class:创建对象或者返回对象类型  obj=class(s,‘class_name’)</p><p>find：寻找非零元素的索引和值</p><p>​    ind=find(X)；X可以是逻辑式，返回非零元素的索引</p><p>​    ind=find(X, k, ‘first’) 返回数组X中所有非零元素的前k个元素。</p><p>​    ind=find(X, k, ‘last’) 返回数组X中所有非零元素的后k个元素。</p><p>​    [row,col,v]=find(X,…)返回列向量，行向量，v表示非零值</p><p>isequal ：判断两个对象是否相等 比较结构体是否相等时，结构体中子域的顺序不重要 NaNs在此函数中认识不相等—isequal(A,B,…)相同返回1，不同返回0</p><p>isequalwithequalnans:把NaN视为相等的情况下判断两个数组是否相等</p><h5 id="2-字符串转化数值函数">2）字符串转化数值函数</h5><p>base2dec :把指定进制的数字字符串转换为十进制数 d=base2dec(‘strn’, base)</p><p>bin2dec :把二进制数字字符串转换为十进制数 bin2dec(binarystr)</p><p>hex2dec :把十六进制数字字符串转换为十进制数 d=hex2dec(‘hex_value’)</p><p>hex2num :把十六进制数字字符串转换为双精度浮点数 n=hex2num(S)</p><p>str2double :把字符串转换为双精度浮点数</p><p>str2num :把字符串转换为数字</p><h5 id="3-数值转化为字符串函数">3）数值转化为字符串函数</h5><p>dec2base:把十进制数转换为指定基下的数值字符串 str=dec2base(d, base)</p><p>dec2bin :把十进制数转换为二进制数值字符串</p><p>dec2hex :把十进制数转换为十六进制的数值字符串</p><p>int2str :把整数转换为字符串</p><p>mat2str :把矩阵转换为字符串</p><p>num2str :把数字转换为字符串</p><h4 id="四-高级数据类型函数">四、高级数据类型函数</h4><h5 id="1-结构体函数">1）结构体函数</h5><p>cell2struct :把元胞数组转换成结构体数组 s=cell2struct(c, fields,dim) fields指结构体数组的域名，fields可以说字符数组或者字符串元胞数组。</p><p>size(c,dim)==length(fields)%如果fields是元胞数组 size</p><p>(c,dim)==size(fields,1)%如果fields是字符数组</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`c=&#123;&#x27;Tom&#x27;,&#x27;math&#x27;,80;&#x27;Jane&#x27;,&#x27;math&#x27;,70&#125;`</span><br><span class="line">`feilds=&#123;&#x27;name&#x27;,&#x27;subject&#x27;,&#x27;grade&#x27;&#125;;`</span><br><span class="line">`s=cell2struct(c,fields,2)`</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>struct:创建结构体数组 s=struct(‘field1’, values1, ‘field2’,values2, …)</p><p>struct2cell :把结构体数组转换为元胞数组</p><p>structfun :把函数应用于结构体中的每一个子域 A=structfun(fun, s)</p><h5 id="2-元胞数组函数">2)元胞数组函数</h5><p>cell ：创建元胞数组  c=cell(n)c=cell(m,n)</p><p>celldisp ：显示元胞数组的内容</p><p>cellfun ：把函数应用于元胞数组中的每个元素 A=cellfun(fun, C, D,…)</p><p>cellplot ：以图形形式显示元胞数组的结构</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`c&#123;1,1&#125;=&#x27;2-by-2&#x27;;c&#123;1,2&#125;=&#x27;eigenvalues ofeye(2)&#x27;;`</span><br><span class="line">`c&#123;2,1&#125;=eye(2);c&#123;2,2&#125;=eig(eye(2));`</span><br><span class="line">`cellplot(c)`</span><br></pre></td></tr></table></figure><p>cellstr ：根据字符串数组创建字符串元胞数组</p><p>mat2cell ：把矩阵分割为元胞数组 c=mat2cell(x,m, n)</p><p>num2cell ：把数值数组转变为元胞数组  C=num2cell(A)</p><h5 id="3-字符串函数">3)字符串函数</h5><p>func2str ：根据函数句柄构建函数名称字符串 s=func2str(fhandle)</p><p>char ：把整数数组转化为字符串 S=char(X)</p><p>eval ：执行包含MATLAB表达式的字符串 eval(expression)</p><p>findstr ：在长字符串中寻找匹配的短字符串,返回字符串索引</p><p>sprintf ：把一定格式把数据写入字符串  [s, errmsg]=sprintf(format,A, …)</p><p>strcat ：水平连接字符串  t=strcat(s1,s2, s3, …)</p><p>strcmp,strcmpi ：比较字符串—strcmp(‘str1’,‘str2’)相同返回1，不同返回0</p><p>strings函数：连接字符串name=[‘abc’ ‘def’ ‘ghj’]</p><p>strread ：从字符串中读取指定格式数据</p><p>strrep :发现和替换子字符串  str=strrep(str1, str2, str3) —将str1内的所有子字符串str2替换为str3</p><p>strtrim :删除字符串开头和结尾的空字符</p><p>blanks :创建空格字符串数组</p><p>isletter :判断字符串中字符是否为英文字母</p><p>isspace :判断字符串中字符是否为空格</p><p>isstrprop :判断字符串中是否含有指定类别的字符tf=isspace(‘str’)</p><p>dblank :删除字符串末尾空格</p><h3 id="第三篇：矩阵函数">第三篇：矩阵函数</h3><h4 id="五-数组和矩阵函数">五、数组和矩阵函数</h4><h5 id="1-数组基本函数">1）数组基本函数</h5><p>display：显示字符或者数组</p><p>isempty :判断数组是否为空，空返回1，不空返回0</p><p>isequal :判断数组是否相同 （认为NaN不同）</p><p>isequalwithequalnans:判断数组是否相同，把NaN看成相同的数</p><p>isfinite :判断数组元素是否为有限数</p><p>isfloat :判断数组元素是否为浮点数</p><p>isinf :判断数组元素是否为无限数</p><p>isinteger :判断元素是否为整数</p><p>islogical ：判断元素是否为逻辑变量</p><p>isnan ：判断元素是否为NaN</p><p>isnumeric ：判断数组元素是否为数值</p><p>isscalar ：判断输入是不是离散量</p><p>issparse ：判断矩阵是否为稀疏矩阵</p><p>isvector ：判断输入是否为向量</p><p>length ：计算向量的长度</p><p>max ：找出向量中的最大元素</p><p>C=max(A) A为一个向量，返回向量最大值，矩阵A，返回每列向量最大值</p><p>C=max(A,B) A、B维数一样，返回对应位置最大元素</p><p>max(A,[],dim)</p><p>[C,I]=max(A)找出最大值和索引</p><p>min ：找出向量中的最小元素</p><p>ndims ：计算矩阵的维数  ndims同length(size(x)) 一致</p><p>numel：计算数组中元素的个数或者下标数组表达式的个数</p><p>size ：计算数组维数大小 d=size(X) [m,n]=size(X)m行n列 m=size(X,dim)</p><h5 id="2-数组操作函数">2）数组操作函数</h5><p>bsxfun：两个数组间元素逐个计算 C=bsxfun(fun,A,B)</p><p>@plus(加)@minus（减）@times(数组乘)@rdivide（左除）@ldivide（右除）@power（幂）@max@min@rem（整除）@mod（模除）</p><p>dot :向量点乘 C=dot(A,B)</p><h5 id="3-基础矩阵函数">3）基础矩阵函数</h5><p>create :生成随机数流  [s1,s2,…]=RandStream.create(‘gentype’,‘NumStreams’,n)</p><p>eye :生成单位矩阵 Y=eye([m,n])对角线1，其他0</p><p>ones :生成元素为1的数组 Y=ones(n) Y=ones(m,n)</p><p>rand :生成均匀分布的伪随机数矩阵 r=rand(n) rand(m,n,p,…)</p><p>randi :生成均匀分布的伪随机整数矩阵 randi(imax) r=randi(imax,n)</p><p>r=randi(imax,m,n,p,…) r=randi([imin,imax],…) 例：r=randi([5,10],[2,3])</p><p>randn :生成[-1,1]之间随机分布数矩阵 r=randn(n) randn(m,n)randn(m,n,p,…)</p><p>randstream :生成随机数据流</p><p>set (RandStream) :设置随机数据流属性set(S,‘PropertyName’,Value)</p><p>set(S,‘Property’)</p><h5 id="4-矩阵处理函数">4)矩阵处理函数</h5><p>reshape ：改变矩阵维数  B=reshape(A,m,n)</p><p>sort :把数组元素按升序或降序排列</p><p>B=sort(A,dim) B=sort(…,mode) [B,IX]=sort(A,2)返回B元素在A中的位置的索引</p><p>sortrows :矩阵行按照升序排列</p><h5 id="5-矩阵分析函数">5）矩阵分析函数</h5><p>det :求方阵行列式值</p><p>norm :计算向量或者矩阵范数  n=norm(A) n=norm(A,p)</p><p>normest :返回矩阵2-范数估计值</p><p>null :计算矩阵零空间</p><p>rank :返回矩阵的秩</p><p>subspace :返回两个子空间夹角</p><p>trace :返回矩阵的迹对角元素之和</p><h5 id="6-矩阵特征值函数">6）矩阵特征值函数</h5><p>eig :计算矩阵特征值和特征向量</p><p>condeig :计算特征值对应的条件数</p><p>eigs :计算矩阵的最大特征值和特征向量</p><p>gsvd :矩阵广义奇异值分解</p><p>svd :矩阵奇异值分解</p><h3 id="第四篇-数学函数">第四篇 数学函数</h3><h4 id="六-基本数学函数">六、基本数学函数</h4><h5 id="1-基本运算符">1）基本运算符</h5><p>+：加法运算符</p><p>-：减法运算符</p><p>*：矩阵乘法</p><p>.*：数组乘法</p><p>/：斜杠或者矩阵右除  B/A等于公式B*inv(A)</p><p>./：数组右除  A./B等于A(i,j)/B(i,j)</p><p>\：反斜杠或者矩阵左除  A\B等于inv(A)*B</p><p>.\：数组左除   A.\B等于B(i,j)/A(i,j)</p><p>^：矩阵幂计算</p><p>.^：数组幂计算  A.^B等于A(i,j)的B(i,j)次幂</p><p>’：矩阵转置</p><p>[]：表示空矩阵，A(m,:)删除A中的一行，A(:,n)删除A中的一列</p><p>{}：元胞组赋值</p><p>关系操作符：&lt; &lt;= &gt; &gt;= == ~ =</p><p>逻辑操作符 : 逻辑：&amp;&amp; || 数组：&amp; | ~</p><h5 id="2-数据操作函数">2）数据操作函数</h5><p>sort ：数组元素按升序或降序排列 B=sort(A) B=sort(A,dim) B=sort(…,mode)[B,IX]=sort(A,…)</p><p>sortrows ：把矩阵中每行按照升序排列  B=sortrows(A) B=sortrows(A,column)</p><p>sum ：求数列元素的和  B=sum(A) A是向量，向量求和，A是矩阵就没列求和 B=sum(A,dim)</p><h5 id="3-统计分析函数">3）统计分析函数</h5><p>brush:交互式标记、删除、修改以及保存图片中的观测量位  data brush</p><p>corrcoef ：计算相关性系数 R=corrcoef(X)</p><p>cov ：返回协方差矩阵 cov(x)</p><p>max ：求数组中的最大元素   C=max(A) C=max(A,B) C=max(A,[],dim)</p><p>mean ：求数组的平均数或者均值 M=mean(A) M=mean(A,dim)</p><p>median ：返回数组的中间值 M=median(A) M=median(A,dim)</p><p>mode ：求数组中出现频率最多的值  M=mode(X) M=mode(X, dim)</p><p>[M,F]=mode(X, …)</p><p>std ：计算标准差 s=std(X)</p><p>var ：计算方差 V=var(X)</p><h5 id="4-三角函数">4）三角函数</h5><p>acos ：以弧度的形式返回反余弦值</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`x=-1:.05:1;`</span><br><span class="line">`plot(x,acos(x));grid on`</span><br></pre></td></tr></table></figure><p>acosd ：以角度的形式返回反余弦值</p><p>acosh ：以弧度形式返回反双曲余弦值</p><p>acot ：以弧度的形式返回反余切值</p><p>acotd ：以角度的形式返回反余切值</p><p>acoth ：以弧度的形式返回反双曲余切值</p><p>acsc :以弧度的形式返回反余割值</p><p>acscd :以角度的形式返回反正割值</p><p>acsch :以弧度的形式反双曲余割值</p><p>asec :以弧度的形式返回反正割值</p><p>asecd :以角度的形式返回反正割值</p><p>asech :以弧度的形式返回反双曲正割值</p><p>asin :以弧度的形式返回反正弦值</p><p>asind :以角度形式返回反正弦值</p><p>asinh :以弧度的形式返回反双曲正弦值</p><p>atan :以弧度的形式返回反正切值</p><p>atand :以角度的形式返回反正切值</p><p>atanh :以弧度的形式返回反双曲正切值</p><p>cos :以弧度的形式返回输入的余弦值</p><p>cosd :以角度的形式返回输入的余弦值</p><p>cosh :以弧度的形式返回输入的双曲余弦值</p><p>cot :以弧度的形式返回输入的余切</p><p>cotd :以角度的形式返回输入的余切值</p><p>coth :以弧度的形式返回输入的双曲余切值</p><p>csc :以弧度的形式返回输入的余割值</p><p>cscd :以角度形式返回输入的余割值</p><p>csch :以弧度的形式返回双曲余割值</p><p>sec :以弧度的形式返回输入的正割值</p><p>secd :以角度的形式返回输入的正割值</p><p>sech :以弧度的形式返回双曲正割值</p><p>sin :以弧度的形式返回输入的正弦</p><p>sind :以角度的形式返回输入的正弦值</p><p>sinh :以弧度的形式返回输入的双曲正弦值</p><p>tan :以弧度的形式返回输入的正切值</p><p>tand :以角度的形式返回输入的正切值</p><p>tanh :以弧度的形式返回双曲正切</p><h5 id="5-指数函数">5）指数函数</h5><p>exp ：计算指数</p><p>log ：计算自然对数</p><p>log10 ：计算平凡对数（以10为底）</p><p>log2 ：计算以2为底数的对</p><p>pow2 ：计算以2为底的幂</p><p>nthroot：计算实数值的实n阶方根。y=nthroot(X,n)</p><p>sqrt ：计算平方根</p><p>abs ：计算绝对值和复数模值</p><h5 id="6-除法函数">6）除法函数</h5><p>ceil ：向正无穷方向舍入</p><p>fix ：向零方向舍入</p><p>floor ：向负无穷方向舍入</p><p>idivide ：舍入操作  C=idivide(A,B, opt)</p><p>mod ：计算相除后的模值</p><h5 id="7-排列函数">7）排列函数</h5><p>factorial：阶乘—factorial（N），N！</p><p>perms：元素所有可能的全排列</p><h4 id="七-高级数学函数">七、高级数学函数</h4><h5 id="1-微分方程解函数">1）微分方程解函数</h5><p>decic ：计算和ode15i（ode常微分方程）相容的初始条件</p><p>[y0mod,yp0mod]=decic(odefun,t0,y0,fixed_y0,yp0,fixed_yp0)</p><p>deval ：计算微分方程的解   sxint=deval(sol,xint)  sol是求解器返回的结构体，（ode45, ode23, dde23 xint是点或向量，函数求解的是该点上的值。</p><p>deval :计算微分方程的解   sxint=deval(sol,xint)</p><h5 id="2-极值函数">2）极值函数</h5><p>fminbnd ：在指定区间上求解单变量函数的最小值x=fminbnd(fun,x1,x2)x=fminbnd(fun,x1,x2,options)  结构体options用于指定优化参数</p><p>[x,fval]=fminbnd(…)   [x,fval,exitflag]=fminbnd(…)</p><p>[x,fval,exitflag,output]=fminbnd(…)</p><p>fminsearch ：利用derivative-free算法求无约束多变量函数的最小值</p><p>x=fminsearch(fun,x0)x=fminsearch(fun,x0,options)</p><p>[x,fval,exitflag]=fminsearch(…)</p><p>fzero：求单变量连续函数的零值点 x=fzero(fun,x0) x=fzero(fun,x0,options)</p><p>isqnonneg :求解非负最小二乘法约束问题</p><p>x=lsqnonneg(C,d)返回一个向量x，满足x &gt;= 0时(C*x-d)的范数最小。</p><p>x=lsqnonneg(C,d,x0) x=lsqnonneg(C,d,x0,options)</p><h5 id="3-数值积分函数">3）数值积分函数</h5><p>dblquad ：计算矩形区域的二重定积分</p><p>q=dblquad(fun,xmin,xmax,ymin,ymax)</p><p>q=dblquad(fun,xmin,xmax,ymin,ymax,tol)q=dblquad(fun,xmin,xmax,ymin,ymax,tol,method)</p><p>quad ：求基于变步长Simpson法的函数定积分数值解 q=quad(fun,a,b)</p><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">F&#x3D;@(x)1.&#x2F;(x.^3-2*x-5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Q&#x3D;quad(F,0,2)</span><br></pre></td></tr></table></figure><p>quad2d ：在平面区域求二重积分的数值解  q=quad2d(fun,a,b,c,d)</p><p>实例：Q=quad2d(@(x,y)y.*sin(x)+x.<em>cos(y),pi,2</em>pi,0,pi)</p><h5 id="4-微分积分函数">4）微分积分函数</h5><p>dblquad ：计算矩形区域的二重定积分 q=dblquad(fun,xmin,xmax,ymin,ymax)</p><p>cumtrapz ：累积梯形数值积分 Z=cumtrapz(Y)Z=cumtrapz(X,Y) 对于多维数组从第一维开始计算 Z=cumtrapz(X,Y,dim)</p><p>diff :差分与微分近似 Y=diff(X) Y=diff(X,n) Y=diff(X,n,dim)</p><p>gradient :计算函数数值梯度  FX=gradient(F) [FX,FY]=gradient(F)</p><p>实例：绘制函数z=exp(-x.^2-y.^2)的梯度图形。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">`v=-2:0.2:2;`</span><br><span class="line">`[x,y]=meshgrid(v);`</span><br><span class="line">`z=exp(-x.^2-y.^2);`</span><br><span class="line">`[px,py]=gradient(z,0.2,0.2);`</span><br><span class="line">`contour(v,v,z)`</span><br><span class="line">`hold on`</span><br><span class="line">`quiver(v,v,px,py)`</span><br></pre></td></tr></table></figure><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210926095356.png" alt="image-20210926095340360" loading="lazy"></p><p>trapz :梯形数值积分 Z=trapz(Y) Z=trapz(X,Y) Z=trapz(…,dim)</p><h5 id="5-赋值函数">5)赋值函数</h5><p>biltin:重载方法中执行MATLAB内部自带的函数  builtin(…) 函数和 feval(…)函数相同</p><p>evalc :计算表达式值  T=evalc(S)：同函数eval(S)用法相同</p><p>feval :计算函数值  [y1, y2, …]=feval(fhandle, x1, …, xn)</p><h3 id="第五篇：方程函数">第五篇：方程函数</h3><h4 id="八-插值函数-线性方程解函数和多项式函数">八、插值函数、线性方程解函数和多项式函数</h4><h5 id="1-插值函数">1）插值函数</h5><p>interp1q ：1维快速线性插值法 yi=interp1q(x,Y,xi)</p><p>​    interp1q正常执行条件：</p><p>（1）x单调递增列向量</p><p>（2）Y为列向量or行数为length(x)(3)xi为列向量，如果xi值在x的坐标范围外，返回NaN</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`x=(-5:0.5:5)&#x27;;`</span><br><span class="line">`y=sin(x);`</span><br><span class="line">`xi=(-5:0.5:5)&#x27;;`</span><br><span class="line">`yi=interp1q(x,y,xi);`</span><br><span class="line">`plot(x,y,&#x27;o&#x27;,xi,yi)`</span><br></pre></td></tr></table></figure><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210926095806.png" alt="image-20210926095802196" loading="lazy"></p><p>interp2 ：2维数据插值法</p><p>​    ZI=interp2(X,Y,Z,XI,YI)</p><p>​    ZI=interp2(Z,XI,YI)</p><p>​    ZI=interp2(X,Y,Z,XI,YI,method)</p><p>​    （1）‘nearest’：最邻近插值法；</p><p><img src="C:/Users/49475/AppData/Roaming/Typora/typora-user-images/image-20210926095826309.png" alt="image-20210926095826309" loading="lazy"></p><p>​    （2）‘linear’：线性插值法（默认插值方法）；</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210926100005.png" alt="image-20210926095912064" loading="lazy"></p><p>​    （3）‘spline’：三次样条插值法；</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210926100043.png" alt="image-20210926100040286" loading="lazy"></p><p>​    （4）’cubic’：三次插值法</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210926100104.png" alt="image-20210926100100798" loading="lazy"></p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">`[X,Y]=meshgrid(-2:0.5:2);`</span><br><span class="line">`Z=peaks(X,Y);`</span><br><span class="line">`[XI,YI]=meshgrid(-2:0.125:2);`</span><br><span class="line">`ZI=interp2(X,Y,Z,XI,YI);`</span><br><span class="line">`mesh(X,Y,Z)`</span><br><span class="line">`hold on`</span><br><span class="line">`mesh(XI,YI,ZI+10)</span><br></pre></td></tr></table></figure><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210926100153.png" alt="image-20210926100150073" loading="lazy"></p><p>interp3 ：3维数据插值法</p><p>​    VI=interp3(X,Y,Z,V,XI,YI,ZI)</p><p>​    VI=interp2(X,Y,Z,V,XI,YI,ZI,method)</p><p>​    （1）‘nearest’：最邻近插值法；</p><p>​    （2）‘linear’：线性插值法（默认插值方法）；</p><p>​    （3）‘spline’：三次样条插值法；</p><p>​    （4）’cubic’：三次插值法</p><p>​</p><p>interpft ：基于FFT方法的1维插值法 y=interpft(x,n) y=interpft(x,n,dim)</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">`y=[1 2 3 2 1 23];`</span><br><span class="line">`N=length(y);`</span><br><span class="line">`L=5;`</span><br><span class="line">`M=N*L;`</span><br><span class="line">`x=0:L:L*N-1`</span><br><span class="line">`xi=0:M-1`</span><br><span class="line">`yi=interpft(y,M)`</span><br><span class="line">`plot(x,y,&#x27;o&#x27;,xi,yi,&#x27;*&#x27;)`</span><br></pre></td></tr></table></figure><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210926100231.png" alt="image-20210926100216325" loading="lazy"></p><p>interpn ：n维数据插值（表格查询）VI=interpn(X1,X2,X3,…,V,Y1,Y2,Y3,…)</p><p>meshgrid ：为3维绘图生成X和Y矩阵</p><p>[X,Y]=meshgrid(x,y) [X,Y,Z]=meshgrid(x,y,z)</p><p>ndgrid ：生成可为函数和插值算法使用的n维矩阵</p><p>[X1,X2,X3,…]=ndgrid(x1,x2,x3,…)</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`[X1,X2]=ndgrid(-1:0.1:1,-1:0.1:1);`</span><br><span class="line">`Z=exp(-X1.^2-X2.^2);`</span><br><span class="line">`mesh(Z)`</span><br></pre></td></tr></table></figure><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210926100349.png" alt="image-20210926100345433" loading="lazy"></p><p>pchip ：分段三次厄密插值多项式（PCHIP） yi=pchip(x,y,xi)pp=pchip(x,y)</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">`x=-4:4`</span><br><span class="line">`y=[-3 -2 -2 0 0 0 2 2 3];`</span><br><span class="line">`t=-4:0.01:4;`</span><br><span class="line">`p=pchip(x,y,t);`</span><br><span class="line">`s=spline(x,y,t);`</span><br><span class="line">`plot(x,y,&#x27;o&#x27;,t,p,&#x27;-&#x27;,t,s,&#x27;-.&#x27;)`</span><br><span class="line">`legend(&#x27;data&#x27;,&#x27;pchip&#x27;,&#x27;spline&#x27;,4)`</span><br></pre></td></tr></table></figure><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210926100422.png" alt="image-20210926100418901" loading="lazy"></p><p>spline ：曲线三次样条插值  yy=spline(x,Y,xx)  pp=spline(x,Y)</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`x=0:10;`</span><br><span class="line">`y=cos(x);`</span><br><span class="line">`xx=0:0.1:10;`</span><br><span class="line">`yy=spline(x,y,xx);`</span><br><span class="line">`plot(x,y,&#x27;o&#x27;,xx,yy)`</span><br></pre></td></tr></table></figure><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210926100518.png" alt="image-20210926100515126" loading="lazy"></p><h5 id="2-线性方程解函数">2)线性方程解函数</h5><p>linsolve ：使用部分主元LU因子分解法求解线性方程组  X = linsolve(A,B) [X, R] = linsolve(A,B)  X = linsolve(A,B,opts)</p><p>lscov ：已知协方差时求解方程的最小二乘解</p><p>x = lscov(A,b)  线性方程组A*x = b的一般最小二乘解</p><p>x = lscov(A,b,w)  线性方程组A*x = b的加权最小二乘解</p><p>x = lscov(A,b,V)  线性方程组A*x = b 的广义最小二乘解</p><p>x =lscov(A,b,V,alg)</p><p>bicg ：求解线性方程的双共轭梯度法</p><p>x=bicg(A,b) bicg(A,b,tol)bicg(A,b,tol,maxit)</p><p>bicg(A,b,tol,maxit,M1,M2)bicg(A,b,tol,maxit,M1,M2,x0)[x,flag]=bicg(A,b,…)</p><p>[x,flag,relres]=bicg(A,b,…)[x,flag,relres,iter]=bicg(A,b,…)</p><p>[x,flag,relres,iter,resvec]=bicg(A,b,…)</p><p>bicgstab ：求解线性方程的稳定的双共轭梯度法</p><p>bicgstabl ：求解线性方程的双共轭梯度l稳定法</p><p>bicgstab ：求解线性方程的稳定的双共轭梯度法</p><p>bicgstabl ：求解线性方程的双共轭梯度l稳定法</p><p>cgs ：求解线性方程的共轭梯度平方法</p><p>gmres ：求线性方程的广义最小残差法</p><p>lsqr ：求解线性方程的LSQR 方法</p><p>minres :求解线性方程的最小残差法</p><p>pcg :求解线性方程的预处理共轭梯度法</p><p>qmr :求解线性方程的准最小残差法</p><p>symmlq :求解线性方程的对称 LQ 法</p><p>tfqmr :求解线性方程的自由转置准最小残差法</p><h5 id="3-多项式函数">3)多项式函数</h5><p>polyfit ：多项式拟合</p><p>​    p=polyfit(x,y,n) 根据拟合数据x,y求n阶多项式p(x)的系数，p是系数</p><p>​    [p,S]=polyfit(x,y,n) p是系数，使用S和多项式的值能得到误差估计值或预测</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`x=(-3:0.2:3)&#x27;;`</span><br><span class="line">`y=erf(x);`</span><br><span class="line">`p=polyfit(x,y,3)`</span><br><span class="line">`f=polyval(p,x);`</span><br><span class="line">`plot(x,y,&#x27;*&#x27;,x,f,&#x27;-&#x27;)`</span><br></pre></td></tr></table></figure><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210926101210.png" alt="image-20210926101206088" loading="lazy"></p><p>polyval ：多项式求值   y=polyval(p,x)</p><p>poly ：根据根求解多项式</p><p>polyder ：解析求解多项式微分表达式k=polyder§ k=polyder(a,b)</p><p>polyint ：解析求解多项式积分表达式系数  polyint(p,k)</p><p>mkpp ：构建分段多项式  pp=mkpp(breaks,coefs)</p><p>breaks是一个长度为L+1的向量，该向量元素严格递增。coefs为L*k的矩阵，每行元素代表</p><p>[breaks(i),breaks(i+1)]的k阶多项式的系数。</p><h4 id="十一-基本文件操作函数">十一、基本文件操作函数</h4><h5 id="1-文件创建函数">1）文件创建函数</h5><p>filemaker ：把文件名与文件中函数名分开 。</p><p>filesep ：文件目录分隔。</p><p>fileparts ：把目标文件名拆分成字符串形式输出 。</p><p>tempdir ：返回系统暂存地址名 。</p><p>tempname ：返回系统暂存文件名 。</p><p>fullfile :创建文件名</p><h5 id="2-文件打开-读取-存储函数">2）文件打开、读取、存储函数</h5><p>open:打开文件 —用法：open(‘name’)</p><p>load :将文件导入到MATLABworkspace中。loadfilename load filename X Y Z,</p><p>load-asciifilename ,load-mat filename,load(‘arg1’, ‘arg2’, ‘arg3’, …)</p><p>save:存储文件.save filename, save filename content, savefilename options</p><p>save(‘filename’, ‘var1’, ‘var2’, …)</p><p>daqread ：读数据采集工具箱(.daq)中的文件 。</p><p>​     [data, time, abstime, events, daqinfo]= daqread(‘filename’)</p><p>uiimport :调用文件导入助手</p><h5 id="3-简单文件输入输出函数">3)简单文件输入输出函数</h5><p>fopen ：打开文件。</p><p>​    fid = fopen(filename)</p><p>​    fid = fopen(filename,permission)</p><table><thead><tr><th>Permission值</th><th>打开模式</th></tr></thead><tbody><tr><td>‘r’</td><td>只读模式</td></tr><tr><td>‘w’</td><td>可写入模式，覆盖已有内容</td></tr><tr><td>‘a’</td><td>可写入模式，写入数据到文件末尾</td></tr><tr><td>‘r+’</td><td>可读写模式，</td></tr><tr><td>‘w+’</td><td>可写入模式，覆盖已有内容</td></tr><tr><td>‘a+’</td><td>可写入模式，写入数据到文件末尾</td></tr><tr><td>‘A’</td><td>无自动删除添加</td></tr><tr><td>‘W’</td><td>无自动删除写入</td></tr></tbody></table><p>fclose 关闭文件。status=fclose(fid) ,status=fclose(‘all’)</p><p>fprintf:以指定格式将数据写入文件 。count = fprintf(fid, format, A, …)</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> `x=1:0.1:2;`</span><br><span class="line">. `y=[x,sin(x)];`</span><br><span class="line">3. `fid=fopen(&#x27;sin.txt&#x27;,&#x27;wt&#x27;);`</span><br><span class="line">4. `fprintf(fid,&#x27;%5.2f %5.6f\n&#x27;,y);`</span><br><span class="line">5. `fclose(fid)`</span><br></pre></td></tr></table></figure><p>fscanf ：以指定格式读取文件中的内容 。A =fscanf(fid, format) , [A,count] = fscanf(fid, format, size)</p><p>fread ：读取文件中的二进制数据 。A =fread(fid, count ,precision, skip, machineformat)</p><p>fwrite ：将二进制数据写入到文件中 。</p><p>fseek ：设置文件位置指针 。status = fseek(fid,offset, origin)</p><p>ftell ：获取文件位置指针 。position = ftell(fid)</p><p>fwind ：把文件位置指针移动到文件起始位置 。fwind(fid)</p><p>fgetl ：按行读取文件内容，并删去换行符 。tline = fgetl(fid)</p><p>fgets ：按行读取文件内容，并保留换行符 。tline = fgets(fid, nchar)</p><p>frewind ：将文件指针移到文件的起始位置。 frewind(fid)</p><p>feof ：测试是否为文件的末尾 。message = ferror(fid)</p><p>ferro ：测试文件输入输出是否有错误 。message = ferror(fid,‘clear’) , [message,errnum] = ferror(…)</p><p>disp ：将目标文件所包含的信息以不同形式显示，如文本、数组等形式。</p><p>disp(obj)</p><h5 id="4-电子表格操作函数">4)电子表格操作函数</h5><p>xlsfinfo ：检测文件中是否包含Microsoft Excel电子表格文件 。</p><p>typ = xlsfinfo(filename) [typ,desc, fmt] = xlsfinfo(filename)</p><p>xlsread ：读Microsoft Excel电子表格文件中的内容 。</p><p>num = xlsread(filename)，num = xlsread(filename,sheet)，num =xlsread(filename, range)，num = xlsread(filename, sheet, range, ‘basic’)</p><p>[num,txt,raw,X]=xlsread(filename,sheet, range, ‘basic’)</p><p>xlswrite :将数据写入Microsoft Excel电子表格文件中 。</p><p>xlswrite(filename, M)，xlswrite(filename, M, sheet, range)，</p><p>[status, message] = xlswrite(filename, …)</p><p>wk1finfo ：检测文件中是否包含Lotus 1-2-3 WK1电子表格。</p><p>[extens, typ] = wk1finfo(filename)</p><p>wk1read ：读取Lotus 1-2-3 WK1电子表格文件 。</p><p>M = wk1read(filename) ，M = wk1read(filename,r,c,range)</p><p>wk1write ：将数据写入Lotus1-2-3 WK1电子表格文件中 。</p><p>wk1write(filename,M,r,c)</p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;center&gt;   &lt;/center&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>MATLAB基础__软件初展望</title>
    <link href="https://www.darkfox.top/posts/305021c5/"/>
    <id>https://www.darkfox.top/posts/305021c5/</id>
    <published>2021-09-25T07:44:25.000Z</published>
    <updated>2021-09-25T08:11:14.252Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center>   </center><span id="more"></span><h3 id="matlab最基础教程-零-：基本数学概念"><strong>MATLAB最基础教程（零）：基本数学概念</strong></h3><p>前言：matlab只是个软件，用来完成相关数学的计算，而如何安排这些计算，需要用户掌握最基本的数学概念。如果不理解相关的数学概念，则自然不会使用这个软件。</p><h4 id="1-数值与符号"><strong>1.数值与符号</strong></h4><p>如果给工程数学问题分类，最大的两类肯定是数值问题和符号问题，对应matlab的数值运算和符号运算。简而言之，数值运算就是所有的变量的值已知，求解的也是一些具体的值；符号运算则刚好相反，不要求所有的变量都已知，求解的结果也不是变量具体的值，而是变量之间的关系。一个简单的例子是<br>①数值问题：求解一元二次方程，<strong>ax2+bx+c=0</strong>，其中<strong>a=b=c=1</strong>，所求得的结果一定是<strong>x=几点几+几点几i</strong>，是个复数，是个具体的数值。<br>②符号问题：求解一元二次方程，<strong>ax2+bx+c=0</strong>，所求的的结果一定是<strong>x=求根公式</strong>，是abc的函数，是个关系<br>可见，一个问题是数值问题还是符号问题，很大程度上决定于结果需要求解的是数值还是关系。当然两个问题也可以相互转化，比如数值问题的一元二次方程，我们一般会先转化成符号问题，把abc代入求根公式，求出来变量x的具体数值。但实际中，一般我们并不推荐这样做，原因是matlab的数值和符号是完全不同的两套系统，相互转化不仅需要多余的数值符号转换语言，更可能带来查错的不便。</p><h4 id="2-典型数值问题"><strong>2.典型数值问题</strong></h4><p>以下是常见的数值问题，文中提到的解法均可在数值计算、科学计算、数值算法这类书中找到。</p><h4 id="2-1代数方程"><strong>2.1代数方程</strong></h4><p>代数方程又分为线性方程和非线性方程，线性方程一般可以转化为矩阵形式<strong>AX=b</strong>，对A求逆即可。求逆的数值解法一般有高斯赛德尔迭代，超松弛迭代等。非线性方程一般转化为<strong>f(x)=zeros</strong>其中x是个向量，右侧的<strong>zeros</strong>表示<strong>f</strong>是个多输出函数，数值解法一般是迭代，常见的有牛顿迭代，最速梯度，点斜式等。</p><h4 id="2-2常微分方程"><strong>2.2常微分方程</strong></h4><p>常微分方程一般转化为<strong>Dy=f(y,t)，且y(0)=y0</strong>是初始条件，其中<strong>y和Dy都是向量</strong>，f也是个多输出函数，数值解法有<strong>欧拉法，龙格库塔法</strong>。</p><h4 id="2-3偏微分方程"><strong>2.3偏微分方程</strong></h4><p>偏微分方程比较复杂，matlab处理偏微分方程也不专业，我也几乎不用matlab处理这类问题。但工程数学上，偏微分方程的解法有两类，差分法和有限元法。差分法需要采用中心差分，迎风差分等。有限元需要计算刚度矩阵等。</p><h4 id="2-4插值和拟合"><strong>2.4插值和拟合</strong></h4><p>插值和拟合是完全不同的两个数学概念，虽然很多时候很多人都混淆了。两者的描述都可以归结为：已知函数上的点**(x1,y1),(x2,y2)…(xn,yn)<strong>，求一个已知的</strong>x**，对应的<strong>y</strong>的数值。插值常用的<strong>多项式插值，三次样条插值</strong>。拟合的本质是一个<strong>最优化</strong>问题，其中最常用的一种拟合是线性拟合，求解方法是最小二乘法。</p><h4 id="2-5离散周期傅里叶变换"><strong>2.5离散周期傅里叶变换</strong></h4><p>严格说来，这并不能算一个数学问题，只是一种运算方式，就好像加减乘除一样。特殊性在于这种变换是对于一个向量进行，且运算后的结果依然是个向量。这里提出来是为了强调这种傅里叶变换的限定，要求是离散周期，这也是数值方法能处理的唯一一种傅里叶变换。</p><h4 id="2-6最优化问题"><strong>2.6最优化问题</strong></h4><p>最优化问题比较宽泛，一般可以归结为求目标函数f(x)的最大或者最小值，其中f是一个单输出的函数，x是一个向量。其中x需要满足线性约束条件、非线性约束条件、上下界。具体的解法有<strong>最速梯度，遗传，蚁群，退火等算法</strong>。</p><h4 id="2-7数值积分"><strong>2.7数值积分</strong></h4><p>已知函数上的点(x1,y1),(x2,y2),…(xn,yn)，求函数在x1到xn的定积分。常见算法有矩形公式，梯形公式，辛普森公式。类似的问题还有数值求导。</p><h4 id="3-典型符号问题"><strong>3.典型符号问题</strong></h4><p>以下是常见的符号问题，需要特别指出的是，无解问题。数值问题中也有一部分无解问题，但大多数工程中是碰不到的。而符号问题恰好相反，绝大部分我们遇到的符号问题都是没有解的，或者准确的说，没有解析解。比如求一元五次方程，我们知道x和这些系数存在关系，但无法写出显式的表达式，也就是说没有解析解。</p><h4 id="3-1递推转通项"><strong>3.1递推转通项</strong></h4><p>这个问题可以归结为：已知<strong>xn+1=f(xn)，求xn</strong>，常见于数列的推导。</p><h4 id="3-2代数方程"><strong>3.2代数方程</strong></h4><p>区别于数值问题中的代数方程， 这里的代数方程问题可以描述为：<strong>f(x,c)=0，求x=x©</strong>，这里需要求解的其实是x和c的关系。</p><h4 id="3-3常微分方程"><strong>3.3常微分方程</strong></h4><p>区别于数值问题中的常微分数方程， 这里的代数方程问题可以描述为：<strong>Dy=f(y,t,c)，求y=x(t,c)</strong>，一般无需初值条件。</p><h4 id="3-4符号积分"><strong>3.4符号积分</strong></h4><p>区别于数值问题中的数值积分，这里的符号积分可以描述为：已知函数关系<strong>y=f(x)</strong>，求<strong>y</strong>的不定积分。同样的问题还有符号求导。</p><h3 id="matlab最基础教程-一-：软件基本概念">matlab最基础教程（一）：软件基本概念</h3><h4 id="1-matlab的界面-汉化的可略过"><strong>1.matlab的界面</strong>（汉化的可略过）</h4><p>左上角，home标签下，找到layout进行设置/复位，可以设置各板块的显示与隐藏。其中有几个部分，请务必要显示<br>①<strong>Current Folder</strong>：中文一般翻译成工作路径，一般设置成一个自己建立的、有读写权限的文件夹，例如我的文档下建立一个matlab文件夹<br>②<strong>Command Window</strong>：字面意思是命令窗口，用来运行代码，所有的代码都是在这里输入<br>③<strong>Workspace</strong>：字面意思是工作空间，其实就是暂存所有运行结果的地方，“暂”的具体含义是：关闭matlab后丢失</p><h4 id="2-软件中的基本概念"><strong>2.软件中的基本概念</strong></h4><h5 id="2-1-函数"><strong>2.1 函数</strong></h5><p>matlab之所以强大，就是因为提供大量的函数，你也可以建立自定义函数，方法是：Home-&gt;New-&gt;function。自定义函数一般保存在工作路径下。函数文件的特征是：扩展名m，内容的第一行以function开头，后续内容是“输出变量=函数名(输入变量)”。且函数名和文件名相同。<br>每个函数在Command Window中运行，用来完成特定的计算任务，运行方式是输入“输出变量=函数名(输入变量)”，然后按回车。例如有个系统自带的函数是用来求绝对值的，函数名abs，所以在Command Window里输入“a=abs(-1)”，就会显示运算结果为“a=1”。且运算结果会在Workspace里出现一个变量a，双击后可看到a的值是1。</p><h5 id="2-2-脚本"><strong>2.2 脚本</strong></h5><p>可以理解为特殊的函数，这种函数内容的开头没有function那行，因此没有输入、输出变量，也没有函数名。文件扩展名和函数一样是m，也需要在Command Window里运行。脚本都是用户建立的，方法是：Home-&gt;New Script。一般保存在工作路径下。脚本的功能就是完成用户需要的、复杂的计算任务，通常脚本里会调用很多函数。</p><h5 id="2-3-gui"><strong>2.3 GUI</strong></h5><p>一般翻译为界面，就是人机交互界面的意思。写脚本处理问题的方法有点麻烦，让人看起来更像是码农，所以现在很多问题可以通过界面点点鼠标解决。这时候就需要打开界面，打开方法是：在APPS标签里可以找到所有已安装的GUI工具，单击即可。注意右边有个小三角可以点开。和函数一样，用户也可以自己建立自定义GUI，这部分较为复杂，对新手而言有点遥远。</p><h5 id="2-4-toolbox"><strong>2.4 toolbox</strong></h5><p>一般翻译成工具箱，matlab将功能相近或者应用上自成体系的一组函数和GUI打包成一个toolbox。正版的matlab在购买时，几乎每一个toolbox都是要单独收费的，所以toolbox也可以理解为matlab产品的模块，一个工具箱就是一个产品/商品。</p><h5 id="2-5-simulink-仿真"><strong>2.5 simulink</strong>（仿真）</h5><p>一般用matlab解决问题的过程是：用户自定义脚本，在Command Window里运行脚本。而脚本的运行逻辑是顺序执行，和一般的编程一样。simulink则提供另一种思路，图形化编程，有点像labview，这种方法很适合于物理模型的仿真，因此有时用“matlab编程”和“simulink仿真”强调。使用方法是在home标签下点击simulink。</p><h4 id="3-获得帮助"><strong>3.获得帮助</strong></h4><p>常用的获得帮助有四种方法<br>①home标签里，有个Help标志，点开后可以获得各工具箱/产品的完整帮助文档。新版本中默认使用在线，改用本地帮助的办法是在home标签里，Preferences下的matlab/Help里选择installed locally<br>②cn.mathworks.com官网上找到支持，然后可以获得教程。这种方法获得的帮助文档和第一种方法一样。<br>③在Command Window里输入 doc+函数名 来获得帮助。比如输入&quot;doc fft&quot;可以获得离散傅里叶变换函数fft的帮助和范例。这种方法获得的文档是前两种方法文档中的部分。当然，前提是你要知道函数名，才能找到帮助。这种方法适合于获得系统自带函数的使用说明。<br>④使用GUI时，通常界面的角落里有Help，点开可以获得帮助。这种方法获得的文档是第一和第二种方法文档中的部分。这种方法适合于获得系统自带GUI的使用说明。<br>这几种方法中，最常用的是第三种，只要知道自己需要的函数名，就可以用这种方式获得说明和范例。而实际使用中，一般常用的系统自带函数，也并不是非常多，大概几十个？真正需要牢记使用方法的可能就几个，通常都是知道函数名，要用的时候doc一下。</p><h3 id="matlab最基础教程-二-：变量类型与赋值"><strong>matlab最基础教程（二）：变量类型与赋值</strong></h3><p>前言：matlab解决问题的最基本思路是建立脚本文件，那么脚本文件的第一段就是定义一些变量，这和C语言等编程思想是一样的。matlab提供的变量类型很多，最基础的是三种：数值变量、符号变量、字符串，其他的类型还有cell、table等。这里仅说明最基础的变量类型。</p><h4 id="1-数值变量"><strong>1.数值变量</strong></h4><p>matlab中所有的数值变量都是矩阵，赋值时，以方括号作为开头和结尾，以英文逗号或空格分割同行元素，以英文分号分割各列。例如在Command Window里输入<br><strong>a=[1 2;3 4]</strong>* *可以看到运算结果，a是一个数值变量。同时workspace里出现一个田字形的变量a，说明变量a的类型是数值型。</p><p>向量和数字可以视为特殊的矩阵，例如</p><ol><li><strong>a=[1 2]</strong></li><li><strong>a=[1;2]</strong></li></ol><p>分别是行向量和列向量，<strong>a=[1]<strong>可以简写为<br><strong>a=1</strong> 是数字。<br>数值变量的命名要求是英文字母开头，不能包含特殊符号，大小写敏感。这里推荐采用下划线来进行分割，例如</strong>value_of_A</strong>，这和其他编程语言的命名规则大体相当。<br>赋值中，有时需要用到等差数列，例如定义一个向量<strong>a=[1 2 3]</strong>，如果比较长，赋值很麻烦，所以matlab提供了一个简单的方法<br>**a=[1:1:3]**这里两个冒号的意思是起始值:步长:终值。采用这种赋值方式时可以获得一个等差数列行向量，并可以省略两侧的方括号。当步长为1时，可以省略步长和一个冒号，于是可以简写为<br><strong>a=1:3</strong> 另一种灵活的赋值方法是分块矩阵，其方法是变量名后面加圆括号，圆括号中加序号。例如</p><ol><li><strong>a=[1 2;3 4]</strong></li></ol><p>定义变量a之后，<br><strong>b=a(1,2)</strong> 就可以把a的第一行第二列元素赋值给b，当然也可以用<br><strong>a(1,2)=1</strong> 来修改矩阵中部分元素的值。这里需要注意，序号必须是自然数，且不能是零。当矩阵中有多个元素需要赋值时，可以将序号部分改成向量，例如<br><strong>a([1 2],[1 2])=[1 2;3 4]</strong> 中把行数和列数都用向量表示，就是说对矩阵a的第1和2行，第1和2列，总共4个元素赋值。更进一步，也可以有**a([1 2],1)**表示a的第一列，也可以写成<br>**a(1:end,1)**这里的end表示终点，即a的行数2，也可以更进一步简写成<br>**a(:,1)**这里的冒号表示从头至尾。这类赋值方法最为常用，但基本的语法非常简单，方括号表示矩阵开头和结尾，圆括号表示从矩阵中选取部分，把握这个原则，有利于读懂程序。<br>当然分块矩阵也可以<br>**b=[a a]**这样的赋值方法，但需要注意的是，方括号中的元素必须满足矩阵的行列数要求，例如</p><ol><li><strong>a=[1 1]</strong></li><li><strong>b=[1;1]</strong></li><li><strong>c=[a b]</strong></li></ol><p>就会引起错误，因为此时matlab无法确定c的行列数。</p><h4 id="2-符号变量"><strong>2.符号变量</strong></h4><p>总体而言，符号变量比数值变量简单得多，因为变化非常少，常用的赋值命令是<br>syms a b这里syms表示这里要定义一些符号变量，a和b是变量名，符号变量的命名规则和数值变量一样。有时候也采用<br>syms a real来强调a是实数变量，具体可以doc syms来获得帮助。<br>有些变量之间存在依赖关系，此时可以定义<br>syms x y(x) 这里声明x是一个符号变量，又声明y是一个符号变量，且y的值由x决定，这相当于数学中函数的概念。当然具体的函数关系并没有明确规定。也可以<br>syms x y z(x,y)来定义符号变量z，z依赖x和y。这相当于二元函数的概念。这里的圆括号显然和数值变量中的圆括号含义完全不同，这也是学习matlab最不习惯的地方，同一个符号，由于变量类型不同会有完全不同的含义。所以在学习matlab的过程中，一定要区分数值变量和符号变量。<br>上述方法定义的符号变量是一个数，或者1*1矩阵，matlab中也可以定义符号矩阵，例如</p><ol><li><strong>syms a11 a12 a21 a22</strong></li><li><strong>A=[a11 a12;a21 a22]</strong></li></ol><p>就可以获得一个矩阵符号变量A。<br>定义符号变量后，workspace中出现相应的变量名，图形不是数值变量的田字形，而是方框里有个立方体，双击后可以看到行列数。</p><h4 id="3-字符串"><strong>3.字符串</strong></h4><p>比数值、符号更为简单的就是字符串了，其定义方法是以单引号开头和结尾，例如<br><strong>a='hello world’<strong>就定义了一个字符串</strong>a</strong>，其值为<strong>hello world</strong>。matlab中较为特殊的是，字符串可视为行向量，例如</p><ol><li><strong>b='hello '</strong></li><li><strong>c='world’</strong></li><li><strong>a=[b c]</strong></li></ol><p>也可以获得字符串a，其值为你好世界。另外，有时也可以将字符串视为矩阵，例如<strong>a=[‘ab’;‘cd’]<strong>但这种用法很罕见，同时要求各行字符串长度一样，否则将违反矩阵行列数规定。当然字符串的值也可以是特殊符号，比如’,'就定义了逗号，而最特殊的就是定义单引号，因为单引号会和字符串定义中的单引号混淆，因此matlab中用两个单引号表示一个单引号，也就是</strong>a=’’’'<strong>表示a是一个字符变量，值是一个单引号。语句中第一和第四个单引号是字符串类型的开头和结尾，中间两个单引号用来表示一个单引号。定义字符串变量后，workspace中出现相应的变量名，图像是方框里写了</strong>ch</strong>，双击后可以看到行列数。</p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">本文转载自互联网，遵从转载条约</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>PWM与PFM</title>
    <link href="https://www.darkfox.top/posts/aeef000a/"/>
    <id>https://www.darkfox.top/posts/aeef000a/</id>
    <published>2021-09-24T01:50:48.000Z</published>
    <updated>2021-09-25T07:54:54.173Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center>   </center><span id="more"></span><h3 id="pwm-和-pfm">PWM 和 PFM</h3><p>PWM 不是用来调节开关式转换器输出电压的唯一技术。 这种技术不是通过改变固定频率方波的占空比来调节电源输出，而是采用恒定占空比，然后以调制方波频率方式来实现调节。 采用恒定导通和关断时间控制方式的 DC/DC 电压转换器是 PFM 架构的典型例子。</p><p>另外一个 PFM 例子就是所谓的滞后电压转换器。这种转换器采用一种简单调节方法，使 <a href="http://www.elecfans.com/tags/mosfet/">MOSFET</a> 能根据转换器检测到的输出电压变化导通和关断。 这种架构使输出电压在设定点左右往连续摆动，因此有时也称作“纹波稳压器”或“双滞环控制器”。 滞后作用用于保持预期运行，避免开关抖动。 因为滞后架构会根据<a href="http://www.hqpcb.com/">电路</a>的运行情况改变 MOSFET 的驱动信号，所以开关频率会改变。</p><p>PFM 架构在 DC/DC 转换方面确实拥有一定的优势，具体包括更优的低功耗转换效率、更低的总解决方案成本和简单的转换器拓扑结构，这种架构不需要控制环补偿网络，但由于一些明显的不足而不及 PWM 受欢迎。</p><p>首先是 EMI 控制。 相对于工作频率范围宽的器件，固定开关<a href="http://www.elecfans.com/tags/%E9%A2%91%E7%8E%87%E8%BD%AC%E6%8D%A2%E5%99%A8/">频率转换器</a>的滤波电路更易于设计。 第二，PFM 架构容易在输出端导致更大的电压纹波，进而给被供电的敏感性硅器件造成问题。 第三，低频（或甚至频率为零）的 PFM 会增加开关转换器的瞬态响应时间，导致一些便携式应用响应缓慢，引起客户不满。</p><p>然而，将 PWM 架构的优点与单晶片“双模式”开关转换器中的 PEM 器件的优点相结合，制造商能为我们提供在整个运行范围内具有高效率的解决方案。 与 PFM 有关的 EMI 问题已大大缓解，此类干扰的根本原因是高电流和高电压条件下的快速切换，反之，在双模式芯片中，仅在低电流和低电压运行时才会变频运行。</p><h4 id="开关稳压器中的能量损耗"><a href="http://www.elecfans.com/tags/%E5%BC%80%E5%85%B3%E7%A8%B3%E5%8E%8B%E5%99%A8/">开关稳压器</a>中的能量损耗</h4><p>最常见的开关设备调压技术是采用<a href="http://www.elecfans.com/tags/%E6%8C%AF%E8%8D%A1%E5%99%A8/">振荡器</a>和 PWM 控制器产生方形脉冲波， 这种方波会按照通常为数百兆赫兹范围内的一组频率，对装置的内部 MOSFET（或者同步设备中的 MOSFET）进行切换操作。 （如果不考虑更严重的电磁干扰 ［EMI］，就允许采用体积越小的<a href="http://www.hqchip.com/app/868">磁性元件</a>。） 稳压器的输出电压与 PWM 波形占空比成比例关系。</p><p>这种技术一般情况下运行良好，但低频时效率降低。 要了解其中原因，就需要考虑那里出现损耗，即稳压器输入端吸取的能量没有传输至输出端的负载。</p><p>开关稳压器有四大损耗源。 首先是对 MOSFET 栅极<a href="http://www.elecfans.com/tags/%E7%94%B5%E5%AE%B9/">电容</a>进行充放电所用的能量造成的动态损耗，这是<a href="http://www.elecfans.com/tags/%E6%99%B6%E4%BD%93%E7%AE%A1/">晶体管</a>高频运行时的最大损耗。 电流流经漏源通道且该通道上压差显著时发生开关损耗。 当功率开关元件的近零通道<a href="http://www.hqchip.com/app/dianzudianrongdiangan">电阻</a>流过高电流时，会出现其它 MOSFET 损耗。 （这就是功率元件制造商努力减小产品“导通电阻”的原因。）</p><p>除开关元件外，开关稳压器电路中的无源器件也容易出现低效率。 <a href="http://www.elecfans.com/tags/%E7%94%B5%E6%84%9F%E5%99%A8/">电感器</a>损耗包括导通（绕组中）损耗和<a href="http://www.hqchip.com/app/523">磁芯</a>损耗。 <a href="http://www.elecfans.com/tags/%E7%94%B5%E5%AE%B9%E5%99%A8/">电容器</a>损耗通常与元件的等效串联电阻 （ESR） 有关，并由器件的电容大小、运行频率和负载电流决定。</p><p>开关稳压器有两种实施方法。 工程师可以利用分立元件从零开始构建一个开关稳压器，或者在 <a href="http://www.elecfans.com/tags/te/">Te</a>xas Instruments、<a href="http://www.elecfans.com/tags/linear/">Linear</a> Technology 和 <a href="http://www.elecfans.com/tags/fairchild/">Fairchild</a> Semiconductor 等主要半导体供应商提供的许多种转换器 IC 中，为他们的电源选择一种，然后构建一个开关稳压器。 模块的优势在于其设计过程简化。 （请参见 TechZone 中的《DC/DC 稳压器：如何在分立式和<a href="http://www.hqchip.com/app/1022">模块化</a>设计之间选择》</p><p>然而，转换器 IC 本身会增加开关稳压器的总损耗。 例如， 一些能量需要为<a href="http://www.elecfans.com/tags/%E6%94%BE%E5%A4%A7%E5%99%A8/">放大器</a>、<a href="http://www.elecfans.com/tags/%E6%AF%94%E8%BE%83%E5%99%A8/">比较器</a>和基准提供内部偏置电流，但 IC 的主要损耗与 PWM 控制器的内部振荡器和驱动电路有关。 相对来讲，此类损耗在开关稳压器驱动高负载时不明显，但随着负载减小，与开关动作和外部无源器件有关的损耗会降低，而与转换器有关的损耗则保持不变。</p><p>这种情况有时会让便携式产品设计人员进退两难。 面临压力的工程师会想方设法控制<a href="http://www.elecfans.com/dianyuan/603907.html">电池</a>预算，因此选择一款高效率开关稳压器（如与<a href="http://www.elecfans.com/tags/%E7%BA%BF%E6%80%A7%E7%A8%B3%E5%8E%8B%E5%99%A8/">线性稳压器</a>比较）似乎是一种再明显不过的选择。 （参见 TechZone 中的《延长<a href="http://www.elecfans.com/d/725725.html">锂离子电池</a>续航时间的设计方法》） 然而，便携式产品在低功耗“待机”或“休眠”模式下时间相当长，其中，对开关转换器的要求则比较温和，且开关稳压器的运行效率相对较差。</p><p>典型的手持式设备在完全运行时的电流消耗约为 1 安培，但在待机或者休眠模式下则小于 1 毫安。 考虑到转换 IC 保持运行状态时就需消耗多达几个毫安的电流，低负载条件下的低转换效率会让人有些感到意外，因为稳压器总负载电流中相当大的一部分是静态电流。</p><h4 id="提升能效">提升能效</h4><p>为解决主要损耗问题（即与 PWM 控制器的内部振荡器和驱动电路有关的损耗），设计人员可在市面上的多种双模式开关转换器中选择一种。 这些器件融合了正常 PWM 运行功能 PFM 技术（在 PWM 模式下运行时，这种技术的可变频率通常远低于正常固定频率）</p><p>双模式开关转换器在中等到高电流之间运行时，进入连续导通模式（因此，<a href="http://m.elecfans.com/article/570177.html">电感</a>器中的电流永远不会降为零）。 负载电流减小时，转换器会切换至断续模式（当电感器中的电流由于轻负载确实降为零时）。 负载非常轻时，转换器进入 PFM（有时被制造商称作“省电模式 ［PSM］”）。 其他供应商会通过完全停止振荡器将变频运行的优势发挥到极致（通常指“脉冲跳跃”）。</p><p>应指出，低负载时使用 PFM 并不表示开关转换器使用了 PFM 架构，而是使用了能够在需要时利用 PFM 运行功能的 PWM 架构。</p><p>轻负载条件下，开关转换器的输出电容器能在开关脉冲的间隔时间内保持输出电压一段时间。 理想情况下，振荡器在空载时可完全关闭，且输出电压由于输出电容器的充满状态将保持恒定。 然而，寄生损耗会消耗电容器电能，且电路要求功率开关至少具有偶发脉冲，以保持调节过程中的稳压输出。</p><p>在 PFM 运行期间，输出功率与脉冲链的平均频率成比例，并且输出电压低于由反馈控制回路测得的设定输出电压时，转换器开始工作。 然后，转换器的开关频率持续升高，直到输出电压达到由设定输出电压和高于设定输出电压 0.8 - 1.5% 的电压值确定的范围内（如图 1 所示）。</p><p><a href="http://file.elecfans.com/web1/M00/82/EB/pIYBAFw-c7KAaus3AADJPAYucSU974.jpg"><img src="http://file.elecfans.com/web1/M00/82/EB/pIYBAFw-c7KAaus3AADJPAYucSU974.jpg" alt="PFM的工作原理、优势及集成功率芯片中实现PFM技术" loading="lazy"></a></p><p>图 1：PFM 改变稳压器的固定占空比脉冲链频率，以满足负载要求。</p><h4 id="pfm-操作的负面影响">PFM 操作的负面影响</h4><p>由于需要一个容差频带（非固定点）来检测功率开关何时再次导通，因此在开关转换器切换至 PFM 模式时能经常观察到输出电压纹波增加。 如采用较窄容差频带，转换器会提升开关频率，造成省电能力减弱。 工程师必须在提升低负载能效和提升输出电压纹波之间找到平衡点。 图 2a 和 2b 所示分别为 PWM 和 PFM 模式下的开关转换器运行时的电压纹波差异。</p><p><a href="http://file.elecfans.com/web1/M00/82/6C/o4YBAFw-c5GAc79YAAIuPMw78FE428.jpg"><img src="http://file.elecfans.com/web1/M00/82/6C/o4YBAFw-c5GAc79YAAIuPMw78FE428.jpg" alt="PFM的工作原理、优势及集成功率芯片中实现PFM技术" loading="lazy"></a></p><p>图 2：PWM 模式 （a） 和 PFM 运行 （b） 的电压纹波（感谢 Analog Devices 提供数据）。</p><p>在负载过渡期间，任何开关转换器都会在高负载向低负载过渡时出现某种程度的过冲，或者由低负载向高负载过渡时出现下冲。 转换器在 PSM 模式运行时，负载水平已很低，因此下一次负载过渡就是从低电流过渡到高电流（通常对应于由休眠向激活模式过渡）。 稳压器输出端的负载提升经常会造成持续“输出电压陷”，直至转换回路有时间对其做出响应。</p><p>一些开关转换器具有将这种电压陷降至最低的措施。 <a href="http://www.elecfans.com/tags/ti/">TI</a> 的 TPS62400 采用“动态电压定位”功能。 PSM 运行期间，输出电压设定点会稍有提升（如，提升 1%），以预计考虑负载突然升高时发生的即时电压瞬间下降。 这样会防止输出电压在初始负载过渡时跌落至所需的调节窗口以下。</p><p>一些器件还具有增强功能，可用于对良好瞬态响应（PWM 模式下最佳）和低功耗（PSM 模式下最佳）之间的所做的让步进行平衡。 这种增强功能是一种间歇模式，工程师可对瞬态响应比 PSM 具有更优、能效比 PWM 更高的转换器 IC 使用 I²C 指令来实现。 对于从高负载向如休眠模式之类轻负载转换的系统，这种中间模式是一种很好的选择。</p><h4 id="商业芯片中的-pfm">商业芯片中的 PFM</h4><p>低负载下的 PFM 运行能将 IC 静态电流从数个 mA 降至几个 μA。 图 3 所示为 TPS62400 开关转换器在 PWM 模式下运行时相比轻负载 PSM 的功率转换效率。</p><p><a href="http://file.elecfans.com/web1/M00/82/EB/pIYBAFw-c7SAfFq4AAIhNxQqQ3U328.jpg"><img src="http://file.elecfans.com/web1/M00/82/EB/pIYBAFw-c7SAfFq4AAIhNxQqQ3U328.jpg" alt="PFM的工作原理、优势及集成功率芯片中实现PFM技术" loading="lazy"></a></p><p>图 3：对 TI TPS62400 执行 PSM 时的能效提升。</p><p>由图 3 可知，尽管 PWM 模式能保持高于 100 mA 的良好能效，但采用 PSM 后能在负载电流低于 1 mA 的情况下将效率提升至 80 - 90% 之间。 如果转换器在如此轻的负载期间在 PWM 模式下运行，其运行电流将明显高于负载电流，从而造成非常差的转换效率（远低于 30%）。</p><p>Analog Devices 提供多种采用 PSM 的开关转换器。 进入这种模式时，PWM 稳压级导致的偏移使输出电压持续升高，直至达到比 PWM 稳压级高 1.5% 的值，在该点处，PWM 运行停止：两个功率开关均关断并进入空载模式。 在 VOUT 降至 PWM 稳压值前，允许电容器放电。 然后，转换器会驱动电感器，使 VOUT 再次上升至阈值上限。 只要负载电流低于 PSM 电流阈值，该过程就会重复。</p><p>公司的 TPS7A8300 稳压器采用 PSM，以便在 2.3 V 输入电压和 10 mA 输出电流条件下，将效率从 40% 提升至 75%。 该芯片是一款 3 MHz <a href="http://www.elecfans.com/tags/%E9%99%8D%E5%8E%8B%E8%BD%AC%E6%8D%A2%E5%99%A8/">降压转换器</a>，能在高达的 600 mA 的电流下利用 2.3 - 5.5 V 输入提供 3.3 V 输出。 图 4 所示为发生 PWM 和 PSM 转换的点。</p><p><a href="http://file.elecfans.com/web1/M00/82/6C/o4YBAFw-c5OAa0CsAAFY9jTo2Lk221.jpg"><img src="http://file.elecfans.com/web1/M00/82/6C/o4YBAFw-c5OAa0CsAAFY9jTo2Lk221.jpg" alt="PFM的工作原理、优势及集成功率芯片中实现PFM技术" loading="lazy"></a></p><p>图 4：Analog Devices <a href="https://dfm.elecfans.com/uploads/software/hqdfm.zip?neilian">AD</a>P2108 的 PWM 到 PSM 的阈值。</p><p>其他功率元件制造商也提供双模式开关转换器。 Linear Technology 提供 LTC3412A 器件，该器件具有能在低负载条件下提升效率的“猝发模式”和脉冲跳跃运行功能。 该芯片是一款降压转换器，能在高达 3 A 的电流下将 2.25 - 5.5 V 输入提升至 0.8 - 5 V 输出。</p><p>猝发模式是上文介绍的中间 PFM 技术的一个例子，它能在保持合理瞬态响应能力的同时提升效率。 例如：通过实施猝发模式，在 10 mA 输出电流（VIN 3.3 V、VOUT 2.5 V）下的效率将从 30% 提升至 90%。 LTC3412A 还包括一个传统的脉冲跳跃运行模式，能在轻负载时进一步减小开关损耗。</p><h4 id="延长电池寿命">延长电池寿命</h4><p>设计工程师需要延长便携设备中的电池寿命时，PWM 控制式开关转换器是一种大众化选择。 不过应当牢记，许多便携式产品在大部分时间内是处于低功耗的休眠模式的，只是在工作时点转换器才处于最小能效状态。 虽然对电池的要求较温和，但长时间电流累加在一起，电池寿命就会缩短。</p><p>通过采用具有 PWM 架构、但在低于某一负载阈值时仍可以实现 PFM 和 PSM 技术优势的转换器，设计人员可以在正常运行期间获得 PWM 优势，同时在在许多便携式设备处于空闲状态时，又能在很长时间内保持电池容量。</p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">简单的讲述区别</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>太阳能板向阳自校准</title>
    <link href="https://www.darkfox.top/posts/ca5803cc/"/>
    <id>https://www.darkfox.top/posts/ca5803cc/</id>
    <published>2021-08-23T03:01:43.000Z</published>
    <updated>2021-08-23T04:10:41.991Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center>   </center><span id="more"></span><h4 id="太阳能自动追踪器">太阳能自动追踪器</h4><p>这个也挺新颖，只是这个玩意有简单的现成的了；我在想可不可以用复杂点的低功耗单片机做出来，准确度更高，耗能更少（虽然没啥）</p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210820183455.png" / loading="lazy"><p>这个玩意的构造很简单，红色面是两个太阳能板；如图</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210820183619.png" alt="" loading="lazy"><br>然后底座和支撑是一个3d打印的小座子，中间打胶固定了一个电机。<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210820183756.png" alt="" loading="lazy"><br>这种电机也挺常见的倒也没啥；<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210820183811.png" alt="" loading="lazy"><em>电机</em><br>原理也挺简单，就是简单的太阳能板连接到了电机上面，有电就转；</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210820190732.png" alt="" loading="lazy"><br>然后这种电机叫做直流电机，只是带了个减速器，简单理解为用来加大扭力的装置。这种电机正接就正转，反接就反转；然后两个太阳能板反着接，就可以在两边电压相同时停下；<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210820190755.png" alt="image-20210820190747997" loading="lazy"></p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;center&gt;   &lt;/center&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>新玩具</title>
    <link href="https://www.darkfox.top/posts/ef933535/"/>
    <id>https://www.darkfox.top/posts/ef933535/</id>
    <published>2021-08-09T11:03:15.000Z</published>
    <updated>2021-08-09T11:24:54.788Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center>   </center><span id="more"></span><h3 id="前言">前言</h3><p>数位板就不介绍了，省的有人说我打广告，不过我买的这个数位板是真的大，和我笔记本屏幕差不多了（我笔记本13.3）</p><p>电脑上也没有什么可以用来测试这个板子的软件，所以我就用了下微软的那个白板。简单的试了下感觉还可以。</p><p>ps：最后那个图是我瞎画的</p><h3 id="试用">试用</h3><p>这个新玩具看着还可以，颜值也不低，就是不耐脏，可以明显的看出使用痕迹。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210809191034.jpg" alt="" loading="lazy"></p><p>简单的试用了几下，手感还不错，就是bug略多。因为我有三块屏幕，来回切换时老是卡在一个地方，并且还有空气墙，数位板不能在整块屏幕上写字（(╯▔皿▔)╯）</p><h3 id="修正bug">修正bug</h3><p>但是问题不大，谁让咱是科技宅。经过简单的测试与判断，这个板子应该是在映射时发生了点小问题，导致了不能在比板子大的地方书写。在修正这个bug前，我找到了一个折中方案</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210809191433.jpg" alt="" loading="lazy"></p><p>我有一块这样的小屏幕 ，大概10寸（忽略那条黑线）。50块钱从学弟手里搞的，原来一直当作状态屏使用了（显示电脑的资源）。现在看来可以给它分配个新任务了；</p><p>可以用它来显示whiteboard；</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210809191906.jpg" alt="" loading="lazy"></p><p>然后它完美的完成了任务（内心ps：垃圾板子驱动，占我一块屏）；</p><p>试用了一下白板的一些功能，比如图形自动矫正之类的，画了一篇屑作。</p><h3 id="效果">效果</h3><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210809190330.png" alt="瞎几把画的" loading="lazy"></p><p>右下角是我的签名，我打赌你猜不出来写的啥(<em>^_^</em>)</p><h3 id="结尾">结尾</h3><p>我也是刚拿到这个板子一天不到，还有很多功能（bug）还没测试，例如上面的按键，对于手机的适配等。改天没事了测试一下再补上吧。</p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">最近觉得做电子笔记不太方便，但是没有太多的money买ipad，于是乎买了个数位板.</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>无线音频发射器（简易）</title>
    <link href="https://www.darkfox.top/posts/db42bff8/"/>
    <id>https://www.darkfox.top/posts/db42bff8/</id>
    <published>2021-08-07T09:06:31.000Z</published>
    <updated>2021-08-07T10:02:00.665Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center>   </center><span id="more"></span><h3 id="前言">前言</h3><p>这个小实验是我模仿油管中的一个小玩意做的（可惜实物已经被我拆了），所以大伙权当开开眼了。</p><p>大致长这个模样<strong>↓</strong></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210807173829.png" alt="" loading="lazy"></p><p><a href="https://www.bilibili.com/video/BV1cX4y1G7Jc">原视频链接</a></p><p>感兴趣的可以去康康</p><h3 id="正文">正文</h3><h4 id="原理">原理</h4><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210807171627.png" alt="原理图" loading="lazy"></p><p>其实这个小实验的原理也很简单，但是也有难点，难点都在那个三极管上面其他的倒是没啥</p><p>可惜我没时间讲述三极管的基本原理，在此借别人的光照亮一下。</p><p><a href="https://www.bilibili.com/video/BV1Fx411D71n">三极管动画演示</a></p><p><a href="https://www.bilibili.com/video/BV1kv411574Y">三极管原理</a></p><p>在此只需要知道三极管是一个用于信号放大的器件就可以了（改天没事了我亲自讲述一下三极管的原理）。用三极管组成一个共射放大电路，并使其工作在它的放大区，然后放大了咪头（麦克风）或者其他声源产生的电信号(<a href="https://www.bilibili.com/video/BV1sK4y1n79k">麦克风原理</a>)。之后这个信号作用在激光管上（工作电压看型号而定），就可以产生和声信号对应的光亮变化。你也可以不用麦克风，改用一根音频线（就是你的耳机线，只不过是只使用单声道）。如果使用麦克风的话，麦克风必须是有源的（用于上面那个电路的话）。</p><p>而其他的元器件，类如电阻、电容、开关（开关就不用说了吧）,电阻是用来限流的，电容的话，看下面这个视频你就会有个大致的了解了。</p><p><a href="https://www.bilibili.com/video/BV1mK4y1f7DQ">电容作用</a></p><p>基本原理大致就这样，就是用激光发出去你的声信号，或者说把你的声信号加载到光信号上面。</p><p>我们再来康康<strong>接收端</strong></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210807174025.png" alt="太阳能板" loading="lazy"></p><p>接收端是一个太阳能板（头一次见用这个当接受器的），太阳能板可以将光信号转化成电信号（相当于一个解码器），然后我们只需要放大这个信号就可以了。只是这个信号放大的倍数较大，建议用个成品，类似于音响之类的，或者你可以用个功放（全损音质警告）。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210807174453.png" alt="" loading="lazy"></p><p>然后就可以听到传输出去的声音了。</p><h3 id="总结">总结</h3><p>之前我把它做出来了，然后写文前不小心被我给拆了（淦）；</p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210807175812.jpg" style="zoom:67%;" / loading="lazy"><p>如图所示，被我拆下来后的模块。蓝色的是功放，带个咪头的是麦克，黑的那个是激光管，全部被做成模块化</p><h4 id="优点">优点</h4><p>传输距离远，电路简单，造价便宜（一共花不了十块钱）</p><h4 id="缺点">缺点</h4><p>干扰多，户外受天气影响较大，户内也受灯光影响，音质感人，不可调参</p><h4 id="拓展">拓展</h4><p>如果使用的是有源麦克风，那么只需要做出来两个就可以实现远距离通话了，具体距离看你的激光源有多nb吧。原理上来讲是可以无线远的（因为卫星也有类似的通讯模式）。二十块钱做个对讲机，岂不美哉！</p><p>本次分享就到这了，以后有时间再(￣_,￣ )补写上我自己做的成品。</p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">这两天有点无聊，搞点小东西玩一玩！</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>杀千刀的电赛推迟</title>
    <link href="https://www.darkfox.top/posts/2009afe4/"/>
    <id>https://www.darkfox.top/posts/2009afe4/</id>
    <published>2021-08-04T14:15:34.000Z</published>
    <updated>2021-08-06T05:12:06.779Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center>   </center><span id="more"></span><h3 id="前言">前言</h3><p>不知道该从何说起</p><p>本来我组都准备好奋战四天三夜的准备了，计划都定制好了，而我，打完电赛准备回家来着，票都买好了</p><p>结果，捏码的延迟了，本来根据清单我题目都猜出来一二了。。。。。。。。</p><div class="row">    <embed src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/ele/20210726102910400.pdf" width="100%" height="550" type="application/pdf"></div><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210806112719.png" style="zoom:67%;" / loading="lazy"><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210806112746.png" style="zoom: 50%;" / loading="lazy"><p>因为电赛只是推迟了，但是还是要进行比赛的所以我现在还不能把我的猜想说出来，但是可以给你们点提示，上面这两张图片里面含有关键词的属性。能不能提炼出来看你们的本事了</p><hr><h3 id="正片">正片</h3><h4 id="纪念一下我的手残">纪念一下我的手残</h4><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/IMG_20210804_162708.jpg" alt="手残1" loading="lazy"></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210806113155.jpg" alt="手残2" loading="lazy"></p><p>先纪念一下为了测试电机，插线插到吐的我。。。。。。</p><h4 id="印刷电路板">印刷电路板</h4><p>好在后来争分夺秒，印刷了电路板</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210806122001.jpg" alt="" loading="lazy"></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210806113349.jpg" alt="电路板" loading="lazy"></p><p><strong>省去了各种接插线材的麻烦</strong></p><p>按照惯例，点亮一下灯试试，顺便测试下电机</p><hr><p><strong>一切正常</strong></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210806113550.jpg" alt="点亮测试" loading="lazy"></p><hr><h4 id="最后装车">最后装车</h4><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210806122151.jpg" alt="车车" loading="lazy"></p><p>此时这个小破车只是初步装配，后续还会不断完善（因为时间紧张，只能打绿板，这绿板子真难看）</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210806122610.png" alt="" loading="lazy"></p><p>但是我画的板子还是很有艺术性和未来感的（😀）</p><h4 id="程序">程序</h4><p>你在想peach</p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">捏码的，电赛无限期延迟了！！！</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>电机驱动模块-TB6612FNG</title>
    <link href="https://www.darkfox.top/posts/78f126d1/"/>
    <id>https://www.darkfox.top/posts/78f126d1/</id>
    <published>2021-07-31T08:24:33.000Z</published>
    <updated>2021-08-10T08:58:28.614Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center>   </center><span id="more"></span><p>TB6612的用法<br>双驱动，也就是可以驱动两个电机。<br>STBY:接单片机的IO口，清零，电机全部停止。<br>置1，通过AIN1 AIN2,BIN1,BIN2来控制正反转<br>VM 接12V电源<br>VCC 接5V电源<br>GND 接地</p><p>驱动1路<br>PWMA 接单片机的PWM口<br>TB6612FNG每通道输出最高<strong>1A</strong>的连续驱动电流，启动峰值电流达2A／3A(连续脉冲／单脉冲)；4种电机控制模式：正转／反转／制动／停止；<strong>PWM支持频率高达100 kHz</strong>；待机状态；片内低压检测电路与热停机保护电路；工作温度：-20～85℃；SSOP24小型贴片封装。<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20170715172312975" alt="这里写图片描述" loading="lazy"><br>[刹车和自由停车有什么区别]</p><p><strong>刹车耗能，自由停车不耗能。刹车耗能来源于刹车片摩擦和电机制动，自由停车相当于断电。</strong><em>冥狐注</em></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/image-20210731211614943.png" alt="image-20210731211614943" loading="lazy"></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20170715172500813" alt="接法" loading="lazy"></p><p><strong>TB6612FNG的主要引脚功能：</strong><br>(1)<strong>AINl／AIN2、BIN1／BIN2、PWMA／PWMB为控制信号输入端；</strong><br>(2)<strong>AO1／A02、B01／B02为2路电机控制输出端；</strong><br>(3)<strong>STBY为正常工作／待机状态控制引脚；</strong><br>(4)<strong>VM(3～13.5 V)和VCC(2．7～5．5 V)分别为电机驱动电压输入和逻辑电平输入端。</strong></p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;center&gt;   &lt;/center&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>陀螺仪基本原理</title>
    <link href="https://www.darkfox.top/posts/611f9591/"/>
    <id>https://www.darkfox.top/posts/611f9591/</id>
    <published>2021-07-27T13:57:06.000Z</published>
    <updated>2021-08-20T10:25:09.035Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center>   </center><span id="more"></span><p>本帖翻译自 <a href="http://www.starlino.com/imu_guide.html">IMU（加速度计和陀螺仪设备）在嵌入式应用中使用的指南。</a><br>这篇文章主要介绍加速度计和陀螺仪的数学模型和基本算法，以及如何融合这两者，侧重算法、思想的讨论</p><p>介绍<br>本指南旨在向兴趣者介绍惯性MEMS（微机电系统）传感器，特别是加速度计和陀螺仪以及其他整合IMU（ <a href="http://en.wikipedia.org/wiki/Inertial_measurement_unit">惯性测量单元</a>）设备。<br><img src="http://image.geek-workshop.com/forum/201208/22/163854b9769h9p7kvq7omh.jpg" alt="1.jpg" loading="lazy"></p><p>2012-8-22 16:38 上传</p><p><a href="http://blog.csdn.net/zhuanghe_xing/article/details/forum.php?mod=attachment&amp;aid=NjQxM3xhNDgxYjAxZnwxMzQ2NTg2MjYwfDMxOTV8MTY5NQ%3D%3D&amp;nothumb=yes"><strong>下载附件</strong>(16.48 KB)</a></p><p>IMU单元例子：上图中MCU顶端的 <a href="http://www.starlino.com/store/acc-gyro">ACC Gyro 6DOF</a>，名为 <a href="http://www.gadgetgangster.com/find-a-project/56?projectnum=240">USBThumb</a>，支持USB/串口通信</p><p>在这篇文章中我将概括这么几个基本并且重要的话题：<br>- 加速度计（accelerometer）检测什么<br>- 陀螺仪（gyroscope，也称作 gyro）检测什么<br>- 如何将传感器ADC读取的数据转换为物理单位（加速度传感器的单位是g，陀螺仪的单位是 度/秒）<br>- 如何结合加速度传感器和陀螺仪的数据以得到设备和地平面之间的倾角的准确信息<br>在整篇文章中我尽量将数学运算降低到最少。如果你知道什么是正弦、余弦、正切函数，那无论你的项目使用哪种平台你应该都会明白和运用这篇文章中的思想，这些平台如Arduino、Propeller、Basic Stamp、Ateml芯片、PIC芯片等等。总有些人认为使用IMU单元需要复杂的数学运算（复杂的FIR或IIR滤波，如卡尔曼滤波，Parks-McClellan滤波等）。你如果研究这些会得到很棒且很复杂的结果。我解释事情的方式，只需要基本的数学。我非常坚信简单的原则。我认为一个简单的系统更容易操作和监控，另外许多嵌入式设备并不具备能力和资源去实现需要进行矩阵运算的复杂算法。<br>我会用我设计的一个新IMU模块—— <a href="http://www.starlino.com/store/acc-gyro">Acc_Gyro Accelerometer + Gyro IMU</a>作为例子。在下面的例子中我们会使用这个设备的参数。用这个模块作为介绍非常合适，因为它由3个设备组成：<br>- LIS331AL ( <a href="http://www.starlino.com/wp-content/uploads/data/acc_gyro/LIS331AL.pdf">datasheet</a>) – 3轴 2G 模拟加速度计<br>- LPR550AL ( <a href="http://www.starlino.com/wp-content/uploads/data/acc_gyro/LPR550AL.pdf">datasheet</a>) – 双轴（俯仰、翻滚） 500°/s 加速度传感器<br>- LY550ALH ( <a href="http://www.starlino.com/wp-content/uploads/data/acc_gyro/LY550ALH.pdf">datasheet</a>) –单轴（偏航）陀螺仪 最后这个设备在这篇介绍中不使用，不过他在 <a href="http://www.starlino.com/dcm_tutorial.html">DCM Matrix implementation</a>中有重要作用<br>它们一起组成了一个6自由度的惯性测量单元。这是个花哨的名字！然而，在花哨的名字后面是个非常有用的设备组合，接下来我们会详细介绍之。<br>第一部分 加速度计<br>要了解这个模块我们先从加速度计开始。当我们在想象一个加速度计的时候我们可以把它想作一个圆球在一个方盒子中。你可能会把它想作一个饼干或者甜圈，但我就把它当做一个球好了：<br><img src="http://image.geek-workshop.com/forum/201208/22/163855d7e99tne77u81b12.png" alt="2.png" loading="lazy"></p><p>2012-8-22 16:38 上传</p><p><a href="http://blog.csdn.net/zhuanghe_xing/article/details/forum.php?mod=attachment&amp;aid=NjQxNHw0ZDkxOTU3NXwxMzQ2NTg2MjYwfDMxOTV8MTY5NQ%3D%3D&amp;nothumb=yes"><strong>下载附件</strong>(15.85 KB)</a></p><p>我们假定这个盒子不在重力场中或者其他任何会影响球的位置的场中，球处于盒子的正中央。你可以想象盒子在外太空中，远离任何天体，如果很难想象，那就当做盒子在航天飞机中，一切东西都处于无重力状态。在上面的图中你可以看到我们给每个轴分配了一对墙（我们移除了Y+以此来观察里面的情况）。设想每面墙都能感测压力。如果我们突然把盒子向左移动（加速度为1g=9.8m/s^2），那么球会撞上X-墙。然后我们检测球撞击墙面产生的压力，X轴输出值为-1g。<br><img src="http://image.geek-workshop.com/forum/201208/22/163856r6orns2rocpzz5sp.png" alt="3.png" loading="lazy"></p><p>2012-8-22 16:38 上传</p><p><a href="http://blog.csdn.net/zhuanghe_xing/article/details/forum.php?mod=attachment&amp;aid=NjQxNXwxM2U2NjRkZXwxMzQ2NTg2MjYwfDMxOTV8MTY5NQ%3D%3D&amp;nothumb=yes"><strong>下载附件</strong>(19.23 KB)</a></p><p>请注意加速度计检测到得力的方向与它本身加速度的方向是相反的。这种力量通常被称为 <a href="http://en.wikipedia.org/wiki/Fictitious_force">惯性力或假想力</a> 。在这个模型中你你应该学到加速度计是通过间接测量力对一个墙面的作用来测量加速度的，在实际应用中，可能通过弹簧等装置来测量力。这个力可以是加速度引起的，但在下面的例子中，我们会发现它不一定是加速度引起的。<br>如果我们把模型放在地球上，球会落在Z-墙面上并对其施加一个1g的力，见下图：<br><img src="http://image.geek-workshop.com/forum/201208/22/163856lxjiqd8xlvzh775b.png" alt="4.png" loading="lazy"></p><p>2012-8-22 16:38 上传</p><p><a href="http://blog.csdn.net/zhuanghe_xing/article/details/forum.php?mod=attachment&amp;aid=NjQxNnxjNGIzNDM1YnwxMzQ2NTg2MjYwfDMxOTV8MTY5NQ%3D%3D&amp;nothumb=yes"><strong>下载附件</strong>(19.54 KB)</a></p><p>在这种情况下盒子没有移动但我们任然读取到Z轴有-1g的值。球在墙壁上施加的压力是由引力造成的。在理论上，它可以是不同类型的力量 - 例如，你可以想象我们的球是铁质的，将一个磁铁放在盒子旁边那球就会撞上另一面墙。引用这个例子只是为了说明加速度计的本质是检测力而非加速度。只是加速度所引起的惯性力正好能被加速度计的检测装置所捕获。<br>虽然这个模型并非一个MEMS传感器的真实构造，但它用来解决与加速度计相关的问题相当有效。实际上有些类似传感器中有金属小球，它们称作倾角开关，但是它们的功能更弱，只能检测设备是否在一定程度内倾斜，却不能得到倾斜的程度。<br>到目前为止，我们已经分析了单轴的加速度计输出，这是使用单轴加速度计所能得到的。三轴加速度计的真正价值在于它们能够检测全部三个轴的惯性力。让我们回到盒子模型，并将盒子向右旋转45度。现在球会与两个面接触：Z-和X-，见下图：<br><img src="http://image.geek-workshop.com/forum/201208/22/163857bferffolflo9ly9l.png" alt="5.png" loading="lazy"></p><p>2012-8-22 16:38 上传</p><p><a href="http://blog.csdn.net/zhuanghe_xing/article/details/forum.php?mod=attachment&amp;aid=NjQxN3w1ZGVjODFhOXwxMzQ2NTg2MjYwfDMxOTV8MTY5NQ%3D%3D&amp;nothumb=yes"><strong>下载附件</strong>(34.03 KB)</a></p><p>0.71g这个值是不是任意的，它们实际上是1/2的平方根的近似值。我们介绍加速度计的下一个模型时这一点会更清楚。<br>在上一个模型中我们引入了重力并旋转了盒子。在最后的两个例子中我们分析了盒子在两种情况下的输出值，力矢量保持不变。虽然这有助于理解加速度计是怎么和外部力相互作用的，但如果我们将坐标系换为加速度的三个轴并想象矢量力在周围旋转，这会更方便计算。<br><img src="http://image.geek-workshop.com/forum/201208/22/163858sssxmnssijjjczf3.png" alt="6.png" loading="lazy"></p><p>2012-8-22 16:38 上传</p><p><a href="http://blog.csdn.net/zhuanghe_xing/article/details/forum.php?mod=attachment&amp;aid=NjQxOHxjNDNlNzY5Y3wxMzQ2NTg2MjYwfDMxOTV8MTY5NQ%3D%3D&amp;nothumb=yes"><strong>下载附件</strong>(7.19 KB)</a></p><p>请看看在上面的模型，我保留了轴的颜色，以便你的思维能更好的从上一个模型转到新的模型中。想象新模型中每个轴都分别垂直于原模型中各自的墙面。矢量R是加速度计所检测的矢量（它可能是重力或上面例子中惯性力的合成）。RX，RY，RZ是矢量R在X，Y，Z上的投影。请注意下列关系：<br>，R ^ 2 = RX ^ 2 + RY ^ 2 + RZ ^ 2（ 公式1）<br>此公式等价于 <a href="http://demonstrations.wolfram.com/PythagoreanTheorem3D/">三维空间勾股定理</a>。<br>还记得我刚才说的1/2的平方根0.71不是个随机值吧。如果你把它们代回上式，回顾一下重力加速度是1g，那我们就能验证：<br>1 ^ 2 =（SQRT（1/2））^ 2 + 0 ^ 2 +（SQRT（1/2））^ 2<br>在 公式1中简单的取代： R=1, Rx = -SQRT(1/2), Ry = 0 , Rz = -SQRT(1/2)<br>经过一大段的理论序言后，我们和实际的加速度计很靠近了。RX，RY，RZ值是实际中加速度计输出的线性相关值，你可以用它们进行各种计算。<br>在我们运用它之前我们先讨论一点获取加速度计数据的方法。大多数加速度计可归为两类：数字和模拟。数字加速度计可通过I2C，SPI或USART方式获取信息，而模拟加速度计的输出是一个在预定范围内的电压值，你需要用ADC（模拟量转数字量）模块将其转换为数字值。我将不会详细介绍ADC是怎么工作的，部分原因是这是个很广的话题，另一个原因是不同平台的ADC都会有差别。有些MCU具有内置ADC模块，而有些则需要外部电路进行ADC转换。不管使用什么类型的ADC模块，你都会得到一个在一定范围内的数值。例如一个10位ADC模块的输出值范围在0 … 1023间，请注意，1023 = 2 ^ 10 -1。一个12位ADC模块的输出值范围在0 … 4095内，注意，4095 = 2 ^ 12-1。<br>我们继续，先考虑下一个简单的例子，假设我们从10位ADC模块得到了以下的三个轴的数据：<br>AdcRx = 586<br>AdcRy = 630<br>AdcRz = 561<br>每个ADC模块都有一个参考电压，假设在我们的例子中，它是3.3V。要将一个10位的ADC值转成电压值，我们使用下列公式：<br>VoltsRx = AdcRx * VREF / 1023<br>小注：8位ADC的最大值是255 = 2 ^ 8 -1，12位ADC最大值是4095 = 2 ^ 12 -1。<br>将3个轴的值代入上式，得到：<br>VoltsRx = 586 * 3.3 / 1023 =～1.89V（结果取两位小数）<br>VoltsRy = 630 * 3.3 / 1023 =～2.03V<br>VoltsRz = 561 * 3.3 / 1023 =～1.81V<br>每个加速度计都有一个零加速度的电压值，你可以在它的说明书中找到，这个电压值对应于加速度为0g。通过计算相对0g电压的偏移量我们可以得到一个有符号的电压值。比方说，0g电压值 VzeroG= 1.65V，通过下面的方式可以得到相对0g电压的偏移量:<br>DeltaVoltsRx = 1.89V - 1.65V = 0.24V<br>DeltaVoltsRy = 2.03V - 1.65V = 0.38V<br>DeltaVoltsRz = 1.81V - 1.65V = 0.16V<br>现在我们得到了加速度计的电压值，但它的单位还不是g（9.8m/s^2），最后的转换，我们还需要引入加速度计的灵敏度（Sensitivity），单位通常是 mV/g。比方说，加速度计的灵敏度 Sensitivity= 478.5mV / g = 0.4785V /g。灵敏度值可以在加速度计说明书中找到。要获得最后的单位为g的加速度，我们使用下列公式计算：<br>RX = DeltaVoltsRx /Sensitivity<br>RX = 0.24V / 0.4785V / G =～0.5g<br>RY = 0.38V / 0.4785V / G =～0.79g<br>RZ = 0.16V / 0.4785V / G =～0.33g<br>当然，我们可以把所有的步骤全部放在一个式子里，但我想通过介绍每一个步骤以便让你了解怎么读取一个ADC值并将其转换为单位为g的矢量力的分量。<br>Rx = (AdcRx * Vref / 1023 – VzeroG) / Sensitivity (公式2)<br>Ry = (AdcRy * Vref / 1023 – VzeroG) / Sensitivity<br>Rz = (AdcRz * Vref / 1023 – VzeroG) / Sensitivity<br>现在我们得到了惯性力矢量的三个分量，如果设备除了重力外不受任何外力影响，那我们就可以认为这个方向就是重力矢量的方向。如果你想计算设备相对于地面的倾角，可以计算这个矢量和Z轴之间的夹角。如果你对每个轴的倾角都感兴趣，你可以把这个结果分为两个分量：X轴、Y轴倾角，这可以通过计算重力矢量和X、Y轴的夹角得到。计算这些角度比你想象的简单，现在我们已经算出了Rx，Ry，Rz的值，让我们回到我们的上一个加速度模型，再加一些标注上去：<br><img src="http://image.geek-workshop.com/forum/201208/22/1638594bjbb147i1lqb7cz.png" alt="7.png" loading="lazy"></p><p>2012-8-22 16:38 上传</p><p><a href="http://blog.csdn.net/zhuanghe_xing/article/details/forum.php?mod=attachment&amp;aid=NjQxOXw1YTRiMGIyYnwxMzQ2NTg2MjYwfDMxOTV8MTY5NQ%3D%3D&amp;nothumb=yes"><strong>下载附件</strong>(9.9 KB)</a></p><p>我们感兴趣的角度是向量R和X，Y，Z轴之间的夹角，那就令这些角度为Axr，Ayr，Azr。观察由R和Rx组成的直角三角形：<br>cos(Axr) = Rx / R , 类似的：<br>cos(Ayr) = Ry / R<br>cos(Azr) = Rz / R<br>从 公式1我们可以推导出 R = SQRT( Rx^2 + Ry^2 + Rz^2)<br>通过arccos()函数（cos()的反函数）我们可以计算出所需的角度：<br>Axr = arccos(Rx/R)<br>Ayr = arccos(Ry/R)<br>Azr = arccos(Rz/R)<br>我们花了大段的篇幅来解释加速度计模型，最后所要的只是以上这几个公式。根据你的应用场合，你可能会用到我们推导出来的几个过渡公式。我们接下来要介绍陀螺仪模块，并向大家介绍怎么融合加速度计和陀螺仪的数据以得到更精确的倾角值。<br>但在此之前，我们再介绍几个很常用的公式：<br>cosX = cos(Axr) = Rx / R<br>cosY = cos(Ayr) = Ry / R<br>cosZ = cos(Azr) = Rz / R<br>这三个公式通常称作 <a href="http://en.wikipedia.org/wiki/Direction_cosine">方向余弦</a> ，它主要表达了单位向量（长度为1的向量）和R向量具有相同的方向。你可以很容易地验证：<br>SQRT（cosX ^ 2 + COSY ^ 2 + cosZ ^ 2）= 1<br>这是个很好的性质，因为它避免了我们一直检测R向量的模（长度）。通常如果我们只是对惯性力的方向感兴趣，那标准化模长以简化其他计算是个明智的选择。<br>第二部分陀螺仪<br>对于陀螺仪我们将不会像加速度计一样介绍它的等价盒子模型，而是直接跳到加速度计的第二个模型，通过这个模型我们会向大家介绍陀螺仪是怎么工作的。<br><img src="http://image.geek-workshop.com/forum/201208/22/163859eepfepkeh1glt1lw.png" alt="8.png" loading="lazy"></p><p>2012-8-22 16:38 上传</p><p><a href="http://blog.csdn.net/zhuanghe_xing/article/details/forum.php?mod=attachment&amp;aid=NjQyMHxlMzYwMGE3ZHwxMzQ2NTg2MjYwfDMxOTV8MTY5NQ%3D%3D&amp;nothumb=yes"><strong>下载附件</strong>(12.55 KB)</a></p><p>陀螺仪的每个通道检测一个轴的旋转。例如，一个2轴陀螺仪检测绕X和Y轴的旋转。为了用数字来表达这些旋转，我们先引进一些符号。首先我们定义：<br>Rxz – 惯性力矢量R在XZ平面上的投影<br>Ryz – 惯性力矢量R在YZ平面的上投影<br>在由Rxz和Rz组成的直角三角形中，运用勾股定理可得：<br>Rxz^2 = Rx^2 + Rz^2 ，同样：<br>Ryz^2 = Ry^2 + Rz^2<br>同时注意：<br>R^2 = Rxz^2 + Ry^2 ，这个公式可以 公式1和上面的公式推导出来，也可由R和Ryz所组成的直角三角形推导出来<br>R ^ 2 = Ryz ^ 2 + RX ^ 2<br>在这篇文章中我们不会用到这些公式，但知道模型中的那些数值间的关系有助于理解。<br>相反，我们按如下方法定义Z轴和Rxz、Ryz向量所成的夹角：<br>AXZ - Rxz（矢量R在XZ平面的投影）和Z轴所成的夹角<br>AYZ - Ryz（矢量R在YZ平面的投影）和Z轴所成夹角<br>现在我们离陀螺仪要测量的东西又近了一步。陀螺仪测量上面定义的角度的变化率。换句话说，它会输出一个与上面这些角度变化率线性相关的值。为了解释这一点，我们先假设在t0时刻，我们已测得绕Y轴旋转的角度（也就是Axz），定义为Axz0，之后在t1时刻我们再次测量这个角度，得到Axz1。角度变化率按下面方法计算：<br>RateAxz = (Axz1 – Axz0) / (t1 – t0).<br>如果用度来表示角度，秒来表示时间，那这个值的单位就是 度/秒。这就是陀螺仪检测的东西。<br>在实际运用中，陀螺仪一般都不会直接给你一个单位为度/秒的值（除非它是个特殊的数字陀螺仪）。就像加速度计一样，你会得到一个ADC值并且要用类似 公式2的式子将其转换成单位为 度/秒的值。让我们来介绍陀螺仪输出值转换中的ADC部分（假设使用10位ADC模块，如果是8位ADC，用1023代替255，如果是12为ADC用4095代替1023）。<br>RateAxz = (AdcGyroXZ * Vref / 1023 – VzeroRate) / Sensitivity <strong>公式3</strong><br>RateAyz = (AdcGyroYZ * Vref / 1023 – VzeroRate) / Sensitivity<br>AdcGyroXZ，AdcGyroYZ - 这两个值由ADC读取，它们分别代表矢量R的投影在XZ和YZ平面内里的转角，也可等价的说，旋转可分解为单独绕Y和X轴的运动。<br>Vref – ADC的参考电压，上例中我们使用3.3V<br>VzeroRate – 是零变化率电压，换句话说它是陀螺仪不受任何转动影响时的输出值，对 <a href="http://gadgetgangster.com/find-a-project/56?projectnum=213">Acc Gyro</a>板来说，可以认为是1.23V（此值通常可以在说明书中找到——但千万别相信这个值，因为大多数的陀螺仪在焊接后会有一定的偏差，所以可以使用电压计测量每个通道的输出值，通常这个值在焊接后就不会改变，如果有跳动，在设备使用前写一个校准程序对其进行测量，用户应当在设备启动的时候保持设备静止以进行校准）。<br>Sensitivity –陀螺仪的灵敏度，单位mV/(deg/s)，通常写作mV/deg/s,它的意思就是如果旋转速度增加1°/s,陀螺仪的输出就会增加多少mV。 <a href="http://gadgetgangster.com/find-a-project/56?projectnum=213">Acc_Gyro</a>板的灵敏度值是2mV/deg/s或0.002V/deg/s<br>让我们举个例子，假设我们的ADC模块返回以下值：<br>AdcGyroXZ = 571<br>AdcGyroXZ = 323<br>用上面的公式，在代入 <a href="http://gadgetgangster.com/find-a-project/56?projectnum=213">Acc Gyro</a>板的参数，可得：<br>RateAxz = (571 * 3.3V / 1023 – 1.23V) / ( 0.002V/deg/s) =~ 306 deg/s<br>RateAyz = (323 * 3.3V / 1023 – 1.23V) / ( 0.002V/deg/s) =~ -94 deg/s<br>换句话说设备绕Y轴（也可以说在XZ平面内）以306°/s速度和绕X轴（或者说YZ平面内）以-94°/s的速度旋转。请注意，负号表示该设备朝着反方向旋转。按照惯例，一个方向的旋转是正值。一份好的陀螺仪说明书会告诉你哪个方向是正的，否则你就要自己测试出哪个旋转方向会使得输出脚电压增加。最好使用示波器进行测试，因为一旦你停止了旋转，电压就会掉回零速率水平。如果你使用的是万用表，你得保持一定的旋转速度几秒钟并同时比较电压值和零速率电压值。如果值大于零速率电压值那说明这个旋转方向是正向。<br>第三部分 将它们综合起来。融合加速度计和陀螺仪的数据。<br>如果你在阅读这篇文章你可能已经有了或准备购买一个IMU设备，或者你准备用独立的加速度计和陀螺仪搭建一个。<br>注：具体的代码实现和算法测试，请阅读这篇文章：<br><a href="http://starlino.com/imu_kalman_arduino.html">http://starlino.com/imu_kalman_arduino.html</a></p><p>在使用整合了加速度计和陀螺仪的IMU设备时，首先要做的就是统一它们的坐标系。最简单的办法就是将加速度计作为参考坐标系。大多数的加速度计技术说明书都会指出对应于物理芯片或设备的XZY轴方向。例如，下面就是Acc Gyro板的说明书中给出的XYZ轴方向：<br><img src="http://image.geek-workshop.com/forum/201208/22/16390056u825bbb2j10x80.png" alt="9.png" loading="lazy"></p><p>2012-8-22 16:39 上传</p><p><a href="http://blog.csdn.net/zhuanghe_xing/article/details/forum.php?mod=attachment&amp;aid=NjQyMXxmZDNmNmQ3MnwxMzQ2NTg2MjYwfDMxOTV8MTY5NQ%3D%3D&amp;nothumb=yes"><strong>下载附件</strong>(35.18 KB)</a></p><p>接下来的步骤是：<br>- 确定陀螺仪的输出对应到上述讨论的RateAxz，RateAyz值。<br>- 根据陀螺仪和加速度计的位置决定是否要反转输出值<br>不要设想陀螺仪陀的输出有XY，它会适应加速度计坐标系里的任何轴，尽管这个输出是IMU模块的一部分。最好的办法就是测试。<br>接下来的示例用来确定哪个陀螺仪的输出对应RateAxz。<br>- 首先将设备保持水平。加速度计的XY轴输出会是零加速度电压（ <a href="http://gadgetgangster.com/find-a-project/56?projectnum=213">Acc Gyro</a>板的值是1.65V）<br>- 接下来将设备绕Y轴旋转，换句话说就是将设备在XZ平面内旋转，所以X、Z的加速度输出值会变化而Y轴保持不变。<br>-当以匀速旋转设备的时候，注意陀螺仪的哪个通道输出值变化了，其他输出应该保持不变。<br>- 在陀螺仪绕Y轴旋转（在XZ平面内旋转）的时候输出值变化的就是AdcGyroXZ，用于计算RateAxz<br>-最后一步，确认旋转的方向是否和我们的模型对应，因为陀螺仪和加速度的位置关系，有时候你可能要把RateAxz值反向<br>-重复上面的测试，将设备绕Y轴旋转，这次查看加速度计的X轴输出（也就是AdcRx）。如果AdcRx增大（从水平位置开始旋转的第一个90°），那AdcGyroXZ应当减小。这是因为我们观察的是重力矢量，当设备朝一个方向旋转时矢量会朝相反的方向旋转（相对坐标系运动）。所以，如果你不想反转RateAxz，你可以在 <strong>公式3</strong>中引入正负号来解决这个问题：<br>RateAxz = InvertAxz * (AdcGyroXZ * Vref / 1023 – VzeroRate) / Sensitivity ,其中InvertAxz= 1 或-1<br>同样的方法可以用来测试RateAyz，将设备绕X轴旋转，你就能测出陀螺仪的哪个输出对应于RateAyz，以及它是否需要反转。一旦你确定了InvertAyz，你就能可以用下面的公式来计算RateAyz：<br>RateAyz = InvertAyz * (AdcGyroYZ * Vref / 1023 – VzeroRate) / Sensitivity<br>如果对Acc Gyro板进行这些测试，你会得到下面的这些结果：<br>- RateAxz的输出管脚是GX4，InvertAxz = 1<br>- RateAyz输出管脚是GY4，InvertAyz = 1<br>从现在开始我们认为你已经设置好了IMU模块并能计算出正确的Axr，Ayr，Azr值（在第一部分加速度计中定义）以及RateAyz，RateAyz（在第二部分陀螺仪中）。下一步，我们分析这些值之间的关系并得到更准确的设备和地平面之间的倾角。<br>你可能会问自己一个问题，如果加速度计已经告诉我们Axr，Ayr，Azr的倾角，为什么还要费事去得到陀螺仪的数据？答案很简单：加速度计的数据不是100%准确的。有几个原因，还记加速度计测量的是惯性力，这个力可以由重力引起（理想情况只受重力影响），当也可能由设备的加速度（运动）引起。因此，就算加速度计处于一个相对比较平稳的状态，它对一般的震动和机械噪声很敏感。这就是为什么大部分的IMU系统都需要陀螺仪来使加速度计的输出更平滑。但是怎么办到这点呢？陀螺仪不受噪声影响吗？<br>陀螺仪也会有噪声，但由于它检测的是旋转，因此对线性机械运动没那么敏感，不过陀螺仪有另外一种问题，比如漂移（当选择停止的时候电压不会回到零速率电压）。然而，通过计算加速度计和陀螺仪的平均值我们能得到一个相对更准确的当前设备的倾角值，这比单独使用加速度计更好。<br>接下来的步骤我会介绍一种算法，算法受卡尔曼滤波中的一些思想启发，但是它更简单并且更容易在嵌入式设备中实现。在此之前，让我们先看看我们需要算法计算什么值。所要算的就是重力矢量R=[Rx,Ry,Rz]，它可由其他值推导出来，如Axr，Ayr，Azr或者cosX，cosY，cosZ，由这些值我们能得到设备相对地平面的倾角值，这些关系我们在第一部分已经讨论过。有人可能会说-根据第一部分的 公式2我们不是已经得到Rx，Ry，Rz的值了吗？是的，但是记住，这些值只是由加速度计数据推导出来的，如果你直接将它们用于你的程序你会得到难以忍受的噪声。为了避免进一步的混乱，我们重新定义加速度计的测量值：<br>Racc – 是由加速度计测量到得惯性力矢量，它可分解为下面的分量（在XYZ轴上的投影）：<br>RxAcc = (AdcRx * Vref / 1023 – VzeroG) / Sensitivity<br>RyAcc = (AdcRy * Vref / 1023 – VzeroG) / Sensitivity<br>RzAcc = (AdcRz * Vref / 1023 – VzeroG) / Sensitivity<br>现在我们得到了一组只来自于加速度计ADC的值。我们把这组数据叫做“vector”，并使用下面的符号：<br>Racc = [RxAcc,RyAcc,RzAcc]<br>因为这些Racc的分量可由加速度计数据得到，我们可以把它当做算法的输入。<br>请注意Racc测量的是重力，如果你得到的矢量长度约等于1g那么你就是正确的：<br>|Racc| = SQRT(RxAcc^2 +RyAcc^2 + RzAcc^2),<br>但是请确定把矢量转换成下面的矢量非常重要：<br>Racc(normalized) = [RxAcc/|Racc| , RyAcc/|Racc| , RzAcc/|Racc|].<br>这可以确保标准化Racc始终是1。<br>接来下我们引进一个新的向量：<br>Rest = [RxEst,RyEst,RzEst]<br>这就是算法的输出值，它经过陀螺仪数据的修正和基于上一次估算的值。<br>这是算法所做的事：<br>-加速度计告诉我们：“你现在的位置是Racc”<br>我们回答：“谢谢，但让我确认一下”<br>-然后根据陀螺仪的数据和上一次的Rest值修正这个值并输出新的估算值Rest。<br>-我们认为Rest是当前设备姿态的“最佳值”。<br>让我们看看它是怎么实现的。<br>数列的开始，我们先认为加速度值正确并赋值：<br>Rest(0) = Racc(0)<br>Rest和Racc是向量，所以上面的式子可以用3个简单的式子代替，注意别重复了：<br>RxEst（0）= RxAcc（0）<br>RyEst（0）= RyAcc（0）<br>RzEst（0）= RzAcc（0）<br>接下来我们在每个等时间间隔T秒做一次测量，得到新的测量值，并定义为Racc（1），Racc（2），Racc（3）等等。同时，在每个时间间隔我们也计算出新的估算值Rest（1）,Rest（2），Rest（3），等等。<br>假设我们在第n步。我们有两列已知的值可以用：<br>Rest(n-1) – 前一个估算值，Rest(0) = Racc(0)<br>Racc(n) – 当前加速度计测量值<br>在计算Rest（n）前，我们先引进一个新的值，它可由陀螺仪和前一个估算值得到。<br>叫做Rgyro，同样它是个矢量并由3个分量组成：<br>Rgyro = [RxGyro,RyGyro,RzGyro]<br>我们分别计算这个矢量的分量，从RxGyro开始。<br><img src="http://image.geek-workshop.com/forum/201208/22/163901qa8wfgaj8z8ca8kk.png" alt="10.png" loading="lazy"></p><p>2012-8-22 16:39 上传</p><p><a href="http://blog.csdn.net/zhuanghe_xing/article/details/forum.php?mod=attachment&amp;aid=NjQyMnwxZDk2MjFlNXwxMzQ2NTg2MjYwfDMxOTV8MTY5NQ%3D%3D&amp;nothumb=yes"><strong>下载附件</strong>(12.55 KB)</a></p><p>首先观察陀螺仪模型中下面的关系，根据由Rz和Rxz组成的直角三角形我们能推出：<br>tan(Axz) = Rx/Rz =&gt; Axz = atan2(Rx,Rz)<br>你可能从未用过atan2这个函数，它和atan类似，但atan返回值范围是（-PI/2,PI/2），atan2返回值范围是（-PI，PI），并且他有两个参数。它能将Rx，Rz值转换成360°（-PI，PI）内的角度。更多信息请阅读 <a href="http://en.wikipedia.org/wiki/Atan2">atan2</a>.<br>所以，知道了RxEst（n-1）和RzEst（n-1）我们发现：<br>Axz(n-1) = atan2( RxEst(n-1) , RzEst(n-1) ).<br>记住，陀螺仪测量的是Axz角度变化率，因此，我们可以按如下方法估算新的角度Axz（n）：<br>Axz(n) = Axz(n-1) + RateAxz(n) * T<br>请记住，RateAxz可由陀螺仪ADC读取得到。通过使用平均转速可由得到一个更准确的公式：<br>RateAxzAvg =（RateAxz（N）+ RateAxz（N-1））/ 2<br>Axz(n) = Axz(n-1) + RateAxzAvg * T<br>同理可得：<br>Ayz(n) = Ayz(n-1) + RateAyz(n) * T<br>好了，现在我们有了Axz（n），Ayz（n）。现在我们如何推导出RxGyro/RyGyro?根据 公式1我们可以把Rgyro长度写成下式：<br>| Rgyro | = SQRT（RxGyro ^ 2 + RyGyro ^ 2 + RzGyro ^ 2）<br>同时，因为我们已经将Racc标准化，我们可以认为它的长度是1并且旋转后保持不变，所以写成下面的方式相对比较安全：<br>| Rgyro | = 1<br>我们暂时采用更短的符号进行下面的计算：<br>x =RxGyro , y=RyGyro, z=RzGyro<br>根据上面的关系可得：<br>x = x / 1 = x / SQRT(x^2+y^2+z^2)<br>分子分母同除以SQRT（X ^ 2 + Z ^ 2）<br>x = ( x / SQRT(x^2 + z^2) ) / SQRT( (x^2 + y^2 + z^2) / (x^2 + z^2) )<br>注意x / SQRT(x^2 + z^2) = sin(Axz), 所以:<br>x = sin(Axz) / SQRT (1 + y^2 / (x^2 + z^2) )<br>将SQRT内部分式的分子分母同乘以z^2<br>x = sin(Axz) / SQRT (1 + y^2 * z ^2 / (z^2 * (x^2 + z^2)) )<br><strong>注意 z / SQRT(x^2 + z^2) = cos(Axz)， y / z = tan(Ayz), 所以最后可得:</strong><br>x = sin(Axz) / SQRT (1 + cos(Axz)^2 * tan(Ayz)^2 )<br>替换成原来的符号可得：<br>RxGyro = sin(Axz(n)) / SQRT (1 + cos(Axz(n))^2 * tan(Ayz(n))^2 )<br>同理可得：<br>RyGyro = sin(Ayz(n)) / SQRT (1 + cos(Ayz(n))^2 * tan(Axz(n))^2 )<br>提示：这个公式还可以更进一步简化。分式两边同除以sin（axz（你））可得：<br>RxGyro = 1 / SQRT (1/ sin(Axz(n))^2 + cos(Axz(n))^2 / sin(Axz(n))^2 * tan(Ayz(n))^2 )<br>RxGyro = 1 / SQRT (1/ sin(Axz(n))^2 + cot(Axz(n))^2 * sin(Ayz(n))^2 / cos(Ayz(n))^2 )<br>现在加减  cos(Axz(n))^2/sin(Axz(n))^2  = cot(Axz(n))^2<br>RxGyro = 1 / SQRT (1/ sin(Axz(n))^2 - cos(Axz(n))^2/sin(Axz(n))^2  + cot(Axz(n))^2 * sin(Ayz(n))^2 / cos(Ayz(n))^2 + cot(Axz(n))^2 )<br>综合条件1、2和3、4可得：<br>RxGyro = 1 / SQRT (1 +  cot(Axz(n))^2 * sec(Ayz(n))^2 ),   其中 cot(x) = 1 / tan(x) ， sec(x) = 1 / cos(x)<br>这个公式只用了2个三角函数并且计算量更低。如果你有Mathematica程序，通过使用 FullSimplify [Sin[A]^2/ ( 1 + Cos[A]^2 * Tan[B]^2)]你可以验证这个公式。</p><p>现在我们发现：<br>RzGyro = Sign(RzGyro)*SQRT(1 – RxGyro^2 – RyGyro^2).<br>其中，当 RzGyro&gt;=0时，Sign(RzGyro) = 1 , 当 RzGyro&lt;0时，Sign(RzGyro) = -1 。<br>一个简单的估算方法：<br>Sign(RzGyro) = Sign(RzEst(n-1))<br>在实际应用中，当心RzEst（n-1）趋近于0。这时候你可以跳过整个陀螺仪阶段并赋值：Rgyro=Rest（n-1）。Rz可以用作计算Axz和Ayz倾角的参考，当它趋近于0时，它可能会溢出并引发不好的后果。这时你会得到很大的浮点数据，并且tan()/atan()函数得到的结果会缺乏精度。</p><p>现在我们回顾一下已经得到的结果，我们在算法中的第n步，并计算出了下面的值：<br>Racc – 加速度计读取的当前值<br>Rgyro –根据Rest(-1)和当前陀螺仪读取值所得<br>我们根据哪个值来更新Rest（n）呢？你可能已经猜到，两者都采用。我们会用一个加权平均值，得：<br>Rest(n) = (Racc * w1 + Rgyro * w2 ) / (w1 + w2)<br>分子分母同除以w1，公式可简化成：<br>Rest(n) = (Racc * w1/w1 + Rgyro * w2/w1 ) / (w1/w1 + w2/w1)<br>令w2=w1=wGyro，可得：<br>Rest(n) = (Racc + Rgyro * wGyro ) / (1 + wGyro)<br>在上面的公式中，wGyro表示我们对加速度计和陀螺仪的相信程度。这个值可以通过测试确定，根据经验值5-20之间会得到一个很好的结果。<br>此算法和卡尔曼滤波最主要的差别是它的权重是相对固定的，而卡尔曼滤波中的权重会随着加速度计读取的噪声而改变。卡尔曼滤波注重给你一个“最好”的理论结果，而此算法给你的是实际项目中“够用”的结果。你可以实现一个算法，它能根据测量的噪声而改变wGyro值，但对大部分应用来说固定的权重也能工作的很好。<br>现在得到最新的估算值还差一步：<br>RxEst(n) = (RxAcc + RxGyro * wGyro ) / (1 + wGyro)<br>RyEst(n) = (RyAcc + RyGyro * wGyro ) / (1 + wGyro)<br>RzEst(n) = (RzAcc + RzGyro * wGyro ) / (1 + wGyro)<br>现在，再次标准化矢量：<br>R = SQRT(RxEst(n) ^2 + RyEst(n)^2 + RzEst(n)^2 )<br>RxEst(n) = RxEst(n)/R<br>RyEst(n) = RyEst(n)/R<br>RzEst(n) = RzEst(n)/R<br>现在，可以再次进行下一轮循环了。<br>**注：**关于此算法的具体实现和测试，请阅读这篇文章：<br><a href="http://starlino.com/imu_kalman_arduino.html">http://starlino.com/imu_kalman_arduino.html</a></p><p>加速度计和陀螺仪IMU融合的其他资源：<br><a href="http://www.mikroquad.com/pub/Research/ComplementaryFilter/filter.pdf">http://www.mikroquad.com/pub/Res … ryFilter/filter.pdf</a></p><p><a href="http://stackoverflow.com/questions/1586658/combine-gyroscope-and-accelerometer-data">http://stackoverflow.com/questio … -accelerometer-data</a><br><a href="http://www.dimensionengineering.com/accelerometers.htm">http://www.dimensionengineering.com/accelerometers.htm</a></p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;center&gt;   &lt;/center&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>陀螺仪--九轴</title>
    <link href="https://www.darkfox.top/posts/962b2335/"/>
    <id>https://www.darkfox.top/posts/962b2335/</id>
    <published>2021-07-27T13:50:59.000Z</published>
    <updated>2021-08-20T10:24:26.560Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center>   </center><span id="more"></span><h1>前言</h1><p>传感器的调试过程，一般根据原厂提供demo代码，调试数据接口，将数据流打通即可，在VR中，当带上头显设备，运行应用时，出现漂移、延迟、不回归问题，往往束手无策，解决这些小问题，往往占用很多的时间，希望通过自己整理的知识，明确调试的方向，提高调试效率，达到好的调试效果。自己近几年在Android平台上导入过多种9轴传感器，做过一些sensor内部分享，而且近半年来从事VR开发工作，VR对9轴传感器要求比手机、平板严格更多，遇到的问题也更多，在开发过程中不断学习和思考，与传感器原厂RD沟通和学习。</p><h1>9轴传感器</h1><p>9轴传感器包括3轴加速度计、3轴陀螺仪、3轴磁力计，在实际应用中，需要把这些数据需要经过融合算法后，才能够被应用程序使用，下面对每种传感器功能、原理以及融合算法进行介绍。</p><h2 id="加速度计">加速度计</h2><p>人们常说的G-sensor，用来检测物理在X、Y、Z轴上的重力加速度，单位:m/s^2.<br>以手机为例，X、Y、Z轴如下图所示（右手坐标系）：<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20161223101251281" alt="这里写图片描述" loading="lazy"><br>当手机平放在桌面时，Z轴指向天空，这时候X、Y轴的数值接近为0，Z轴的重力加速度约为9.81m/s^2，将手机翻转后，即屏幕面朝向桌面，此时的Z轴重力加速度约为-9.81m/s^2。<br>X、Y轴指向天空时，与上面Z轴同理，有兴趣的可以在手机上安装一个”sensor_list.apk”来抓取这些数据。</p><ul><li>原理<br><a href="http://www.starlino.com/imu_guide.html">这里是英文介绍</a>，中文版本如下：<br>当我们在想象一个加速度计的时候我们可以把它想作一个圆球在一个方盒子中。你可能会把它想作一个饼干或者甜圈，但我就把它当做一个球好了：<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20161223101306719" alt="这里写图片描述" loading="lazy"><br>我们假定这个盒子不在重力场中或者其他任何会影响球的位置的场中，球处于盒子的正中央。你可以想象盒子在外太空中，远离任何天体，如果很难想象，那就当做盒子在航天飞机中，一切东西都处于无重力状态。在上面的图中你可以看到我们给每个轴分配了一对墙（我们移除了Y+以此来观察里面的情况）。设想每面墙都能感测压力。如果我们突然把盒子向左移动（加速度为1g=9.8m/s^2），那么球会撞上X-墙。然后我们检测球撞击墙面产生的压力，根据F=ma，计算出X轴加速度输出值为-1g。<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20161223101317203" alt="这里写图片描述" loading="lazy"><br>请注意加速度计检测到的力方向与它本身加速度的方向是相反的。这种力量通常被称为惯性力或假想力 。在这个模型中你应该明白加速度计是通过间接测量力对一个墙面的作用来测量加速度的，在实际应用中，可能通过弹簧等装置来测量力。这个力可以是加速度引起的，但在下面的例子中，我们会发现它不一定是加速度引起的。<br>如果我们把模型放在地球上，球会落在Z-墙面上并对其施加一个1g的力，见下图：<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20161223101342743" alt="这里写图片描述" loading="lazy"><br>在这种情况下盒子没有移动但我们任然读取到Z轴有-1g的值。球在墙壁上施加的压力是由引力造成的。在理论上，它可以是不同类型的力量，例如，你可以想象我们的球是铁质的，将一个磁铁放在盒子旁边那球就会撞上另一面墙。引用这个例子只是为了说明加速度计的本质是检测力而非加速度。只是加速度所引起的惯性力正好能被加速度计的检测装置所捕获。<br>虽然这个模型并非一个MEMS传感器的真实构造，但它用来解决与加速度计相关的问题相当有效。实际上有些类似传感器中有金属小球，它们称作倾角开关，但是它们的功能更弱，只能检测设备是否在一定程度内倾斜，却不能得到倾斜的程度。<br>到目前为止，我们已经分析了单轴的加速度计输出，这是使用单轴加速度计所能得到的。三轴加速度计的真正价值在于它们能够检测全部三个轴的惯性力。让我们回到盒子模型，并将盒子向右旋转45度。现在球会与两个面接触：Z-和X-，见下图：<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20161223101354118" alt="这里写图片描述" loading="lazy"><br>0.71g这个值是不是任意的，它们实际上是1/2的平方根的近似值。我们介绍加速度计的下一个模型时这一点会更清楚。<br>在上一个模型中我们引入了重力并旋转了盒子。在最后的两个例子中我们分析了盒子在两种情况下的输出值，力矢量保持不变。虽然这有助于理解加速度计是怎么和外部力相互作用的，但如果我们将坐标系换为加速度的三个轴并想象矢量力在周围旋转，这会更方便计算。<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20161223101540369" alt="这里写图片描述" loading="lazy"><br>请看看在上面的模型，我保留了轴的颜色，以便你的思维能更好的从上一个模型转到新的模型中。想象新模型中每个轴都分别垂直于原模型中各自的墙面。矢量R是加速度计所检测的矢量（它可能是重力或上面例子中惯性力的合成）。RX，RY，RZ是矢量R在X，Y，Z上的投影。请注意下列关系：<br>R ^ 2 = RX ^ 2 + RY ^ 2 + RZ ^ 2（公式1）<br>此公式等价于三维空间勾股定理。<br>还记得我刚才说的1/2的平方根0.71不是个随机值吧。如果你把它们代回上式，回顾一下重力加速度是1g，那我们就能验证：<br>1 ^ 2 =（SQRT（1/2））^ 2 + 0 ^ 2 +（SQRT（1/2））^ 2<br>在公式1中简单的取代： R=1, Rx = -SQRT(1/2), Ry = 0 , Rz = -SQRT(1/2)<br>经过一大段的理论序言后，我们和实际的加速度计很靠近了。RX，RY，RZ值是实际中加速度计输出的线性相关值，你可以用它们进行各种计算。<br>在我们运用它之前我们先讨论一点获取加速度计数据的方法。大多数加速度计可归为两类：数字和模拟。数字加速度计可通过I2C，SPI或USART方式获取信息，而模拟加速度计的输出是一个在预定范围内的电压值，你需要用ADC（模拟量转数字量）模块将其转换为数字值。我将不会详细介绍ADC是怎么工作的，部分原因是这是个很广的话题，另一个原因是不同平台的ADC都会有差别。有些MCU具有内置ADC模块，而有些则需要外部电路进行ADC转换。不管使用什么类型的ADC模块，你都会得到一个在一定范围内的数值。例如一个10位ADC模块的输出值范围在0 … 1023间，请注意，1023 = 2 ^ 10 -1。一个12位ADC模块的输出值范围在0 … 4095内，注意，4095 = 2 ^ 12-1。<br>我们继续，先考虑下一个简单的例子，假设我们从10位ADC模块得到了以下的三个轴的数据：<br>AdcRx = 586<br>AdcRy = 630<br>AdcRz = 561<br>每个ADC模块都有一个参考电压，假设在我们的例子中，它是3.3V。要将一个10位的ADC值转成电压值，我们使用下列公式：<br>VoltsRx = AdcRx * VREF / 1023<br>小注：8位ADC的最大值是255 = 2 ^ 8 -1，12位ADC最大值是4095 = 2 ^ 12 -1。<br>将3个轴的值代入上式，得到：<br>VoltsRx = 586 * 3.3 / 1023 =～1.89V（结果取两位小数）<br>VoltsRy = 630 * 3.3 / 1023 =～2.03V<br>VoltsRz = 561 * 3.3 / 1023 =～1.81V<br>每个加速度计都有一个零加速度的电压值，你可以在它的说明书中找到，这个电压值对应于加速度为0g。通过计算相对0g电压的偏移量我们可以得到一个有符号的电压值。比方说，0g电压值 VzeroG= 1.65V，通过下面的方式可以得到相对0g电压的偏移量:<br>DeltaVoltsRx = 1.89V - 1.65V = 0.24V<br>DeltaVoltsRy = 2.03V - 1.65V = 0.38V<br>DeltaVoltsRz = 1.81V - 1.65V = 0.16V<br>现在我们得到了加速度计的电压值，但它的单位还不是g（9.8m/s^2），最后的转换，我们还需要引入加速度计的灵敏度（Sensitivity），单位通常是 mV/g。比方说，加速度计的灵敏度 Sensitivity= 478.5mV / g = 0.4785V /g。灵敏度值可以在加速度计说明书中找到。要获得最后的单位为g的加速度，我们使用下列公式计算：<br>RX = DeltaVoltsRx /Sensitivity<br>RX = 0.24V / 0.4785V / G =～0.5g<br>RY = 0.38V / 0.4785V / G =～0.79g<br>RZ = 0.16V / 0.4785V / G =～0.33g<br>当然，我们可以把所有的步骤全部放在一个式子里，但我想通过介绍每一个步骤以便让你了解怎么读取一个ADC值并将其转换为单位为g的矢量力的分量。<br>Rx = (AdcRx * Vref / 1023 – VzeroG) / Sensitivity (公式2)<br>Ry = (AdcRy * Vref / 1023 – VzeroG) / Sensitivity<br>Rz = (AdcRz * Vref / 1023 – VzeroG) / Sensitivity<br>现在我们得到了惯性力矢量的三个分量，如果设备除了重力外不受任何外力影响，那我们就可以认为这个方向就是重力矢量的方向。如果你想计算设备相对于地面的倾角，可以计算这个矢量和Z轴之间的夹角。如果你对每个轴的倾角都感兴趣，你可以把这个结果分为两个分量：X轴、Y轴倾角，这可以通过计算重力矢量和X、Y轴的夹角得到。计算这些角度比你想象的简单，现在我们已经算出了Rx，Ry，Rz的值，让我们回到我们的上一个加速度模型，再加一些标注上去：<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20161223101555463" alt="这里写图片描述" loading="lazy"><br>我们感兴趣的角度是向量R和X，Y，Z轴之间的夹角，那就令这些角度为Axr，Ayr，Azr。观察由R和Rx组成的直角三角形：<br>cos(Axr) = Rx / R , 类似的：<br>cos(Ayr) = Ry / R<br>cos(Azr) = Rz / R<br>从公式1我们可以推导出 R = SQRT( Rx^2 + Ry^2 + Rz^2)<br>通过arccos()函数（cos()的反函数）我们可以计算出所需的角度：<br>Axr = arccos(Rx/R)<br>Ayr = arccos(Ry/R)<br>Azr = arccos(Rz/R)<br>我们花了大段的篇幅来解释加速度计模型，最后所要的只是以上这几个公式。根据你的应用场合，你可能会用到我们推导出来的几个过渡公式。我们接下来要介绍陀螺仪模块，并向大家介绍怎么融合加速度计和陀螺仪的数据以得到更精确的倾角值。<br>但在此之前，我们再介绍几个很常用的公式：<br>cosX = cos(Axr) = Rx / R<br>cosY = cos(Ayr) = Ry / R<br>cosZ = cos(Azr) = Rz / R<br>这三个公式通常称作方向余弦 ，它主要表达了单位向量（长度为1的向量）和R向量具有相同的方向。你可以很容易地验证：<br>SQRT（cosX ^ 2 + COSY ^ 2 + cosZ ^ 2）= 1<br>这是个很好的性质，因为它避免了我们一直检测R向量的模（长度）。通常如果我们只是对惯性力的方向感兴趣，那标准化模长以简化其他计算是个明智的选择。</li><li>常用加速度传感器<br>加速度计种类繁多，MMA、LSM、MPU、BMA等系列，如：MMA7460、MMA8452、MPU6050（A+G）、MPU6800(A+G)、LSM6DSL(A+G)、IMC20603(A+G)、MPU9150（A+G+M）</li><li>使用场景<br>加速度计通过一定的算法，就可以做成我们常用的功能，如：计步器、拍照防抖、GPS补偿、跌落保护、图像旋转、游戏控制器等。</li></ul><h2 id="陀螺仪">陀螺仪</h2><p>通常称为Gyro-sensor，用来测量在X、Y、Z轴上的旋转速率，单位:rad/s。<br>以手机为例，将手机平放桌面，屏幕朝上，以逆时针方向旋转手机，获得到的是Z轴的加速度值。<br>有兴趣可以安装“sensor_list.apk”工具，来查看X、Y、Z轴的加速度值。</p><ul><li>原理<br>对于陀螺仪我们将不会像加速度计一样介绍它的等价盒子模型，而是直接跳到加速度计的第二个模型，通过这个模型我们会向大家介绍陀螺仪是怎么工作的。<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20161223101615317" alt="这里写图片描述" loading="lazy"><br>陀螺仪的每个通道检测一个轴的旋转。例如，一个2轴陀螺仪检测绕X和Y轴的旋转。为了用数字来表达这些旋转，我们先引进一些符号。首先我们定义：<br>Rxz – 惯性力矢量R在XZ平面上的投影<br>Ryz – 惯性力矢量R在YZ平面的上投影<br>在由Rxz和Rz组成的直角三角形中，运用勾股定理可得：<br>Rxz^2 = Rx^2 + Rz^2 ，同样：<br>Ryz^2 = Ry^2 + Rz^2<br>同时注意：<br>R^2 = Rxz^2 + Ry^2 ，这个公式可以公式1和上面的公式推导出来，也可由R和Ryz所组成的直角三角形推导出来<br>R ^ 2 = Ryz ^ 2 + RX ^ 2<br>在这篇文章中我们不会用到这些公式，但知道模型中的那些数值间的关系有助于理解。<br>相反，我们按如下方法定义Z轴和Rxz、Ryz向量所成的夹角：<br>AXZ - Rxz（矢量R在XZ平面的投影）和Z轴所成的夹角<br>AYZ - Ryz（矢量R在YZ平面的投影）和Z轴所成夹角<br>现在我们离陀螺仪要测量的东西又近了一步。陀螺仪测量上面定义的角度的变化率。换句话说，它会输出一个与上面这些角度变化率线性相关的值。为了解释这一点，我们先假设在t0时刻，我们已测得绕Y轴旋转的角度（也就是Axz），定义为Axz0，之后在t1时刻我们再次测量这个角度，得到Axz1。角度变化率按下面方法计算：<br>RateAxz = (Axz1 – Axz0) / (t1 – t0).<br>如果用度来表示角度，秒来表示时间，那这个值的单位就是 度/秒。这就是陀螺仪检测的东西。<br>在实际运用中，陀螺仪一般都不会直接给你一个单位为度/秒的值（除非它是个特殊的数字陀螺仪）。就像加速度计一样，你会得到一个ADC值并且要用类似公式2的式子将其转换成单位为 度/秒的值。让我们来介绍陀螺仪输出值转换中的ADC部分（假设使用10位ADC模块，如果是8位ADC，用1023代替255，如果是12为ADC用4095代替1023）。<br>RateAxz = (AdcGyroXZ * Vref / 1023 – VzeroRate) / Sensitivity 公式3<br>RateAyz = (AdcGyroYZ * Vref / 1023 – VzeroRate) / Sensitivity<br>AdcGyroXZ，AdcGyroYZ - 这两个值由ADC读取，它们分别代表矢量R的投影在XZ和YZ平面内里的转角，也可等价的说，旋转可分解为单独绕Y和X轴的运动。<br>Vref – ADC的参考电压，上例中我们使用3.3V<br>VzeroRate – 是零变化率电压，换句话说它是陀螺仪不受任何转动影响时的输出值，对调试板来说，可以认为是1.23V（此值通常可以在说明书中找到——但千万别相信这个值，因为大多数的陀螺仪在焊接后会有一定的偏差，所以可以使用电压计测量每个通道的输出值，通常这个值在焊接后就不会改变，如果有跳动，在设备使用前写一个校准程序对其进行测量，用户应当在设备启动的时候保持设备静止以进行校准）。<br>Sensitivity –陀螺仪的灵敏度，单位mV/(deg/s)，通常写作mV/deg/s,它的意思就是如果旋转速度增加1°/s,陀螺仪的输出就会增加多少mV。调试板的灵敏度值是2mV/deg/s或0.002V/deg/s<br>让我们举个例子，假设我们的ADC模块返回以下值：<br>AdcGyroXZ = 571<br>AdcGyroXZ = 323<br>用上面的公式，在代入调试板的参数，可得：<br>RateAxz = (571 * 3.3V / 1023 – 1.23V) / ( 0.002V/deg/s) =~ 306 deg/s<br>RateAyz = (323 * 3.3V / 1023 – 1.23V) / ( 0.002V/deg/s) =~ -94 deg/s<br>换句话说设备绕Y轴（也可以说在XZ平面内）以306°/s速度和绕X轴（或者说YZ平面内）以-94°/s的速度旋转。请注意，负号表示该设备朝着反方向旋转。按照惯例，一个方向的旋转是正值。一份好的陀螺仪说明书会告诉你哪个方向是正的，否则你就要自己测试出哪个旋转方向会使得输出脚电压增加。最好使用示波器进行测试，因为一旦你停止了旋转，电压就会掉回零速率水平。如果你使用的是万用表，你得保持一定的旋转速度几秒钟并同时比较电压值和零速率电压值。如果值大于零速率电压值那说明这个旋转方向是正向。</li><li>常用陀螺仪传感器<br>目前市面上较多的都是二合一模块（加速度+陀螺仪），如：MPU6050（A+G）、MPU6800(A+G)、LSM6DSL(A+G)、IMC20603(A+G)、MPU9150（A+G+M）。</li><li>使用场景<br>航海、航空、游戏、拍照防抖、控制等。</li></ul><h2 id="磁力计">磁力计</h2><ul><li>原理<br><a href="http://www.stmcu.org/article/id-261634">ST对电子罗盘的详细介绍</a>。</li><li>常用磁力计传感器<br>AKM8963（很经典的一颗，目前停产）、AKM09911、AKM09915、LIS3MDL，磁传感器目前还是AKM一家独大，其他家的性能差距还是比较明显的。</li><li>使用场景<br>主要是指南针，在应用中对6轴数据进行偏航校正。</li></ul><h2 id="融合算法">融合算法</h2><p>想想我们为什么需要9轴的数据来确认物体的姿态呢？有了加速度计数据可以确定物体摆放的状态，例如有加速度计的手机，可以根据手机的横竖屏状态来触发屏幕相应的旋转，但对于物体的翻转、旋转的快慢无从得知，检测不到物体的瞬时状态，这时候就需要加入陀螺仪，通过加速度和陀螺仪的积分运算（这部分计算可以看下面Oculus的融合算法说明），可以获得到物体的运动状态，积分运算与真实状态存在微小差值，短时间内影响很小，但这个误差会一直累积，随着使用时间增加，就会有明显的偏离，6轴的设备，在转动360度后，图像并不能回到原点，就是这个原因，就像人迷路后找不着北一样，这时候就需要一个准确的方向，因此引入磁力计，来找到正确的方向进行校正。融合算法是通过这9轴的数据来计算出物体正确的姿态。目前9轴融合算法包括卡尔曼滤波、粒子滤波、互补滤波算法，对于开发者而言，所有的融合算法本基本都是丢入9轴传感器的数据和时间戳，然后获取到融合算法输出的四元素，应用所需的就是这组四元素，目前我这里接触到的算法包括：</p><ul><li>Oculus融合算法<br>目前卡尔曼滤波和例子滤波都存在一定的局限性，比较好的选择是互补滤波算法，之前翻译过oculus传感器算法<a href="http://blog.csdn.net/dabenxiong666/article/details/52957370">Oculus:”sensor fusion:Keeping It Simple”</a><br>它的代码实现在openHMD中ofusion_update接口中，有兴趣可以下载openHMD来研究一下。<br><strong>注</strong>：openHMD中的oculus融合算法（已更新于2016.12.01），我们曾经把它应用到项目当中，后来发现这部分算法不包含航向偏移校正。</li><li>互补滤波算法<br>MIT上发表的互补滤波算法的原理和基于Android平台的算法实现，很完整的算法，oculus的算法也是基于互补滤波的，个人认为目前入门融合算法最好的选择<a href="https://www.codeproject.com/articles/729759/android-sensor-fusion-tutorial">MIT互补滤波算法</a>。</li><li>AHRS<br>在四轴飞行器论坛上，比较多人使用AHRS开源融合算法,<a href="https://github.com/TobiasSimon/MadgwickTests/blob/master/MadgwickAHRS.c">这里获取源码</a><br>如果是爱好者，使用开源的算法能满足大多数的需求，另外可以看一下AMO论坛上的这个讨论<a href="http://www.amobbs.com/thread-5492189-1-1.html">捷联惯导算法心得</a>。<br>产品化还是依赖原厂提供的算法。</li></ul><h2 id="传感器调试">传感器调试</h2><p>这里不对特定平台（MCU、Android、Linux等），传感器通讯接口（I2C、SPI等）、数据传递子系统(input、IIO等)详细说明，这部分代码由各sensor厂家直接提供，这里主要说明一下调试基本流程和方法：</p><ul><li>通讯接口<br>传感器IC的通讯接口I2C或SPI，通讯接口能够读写正常即可。</li><li>寄存器配置<br>寄存器参数配置，一般原厂会提供，根据自己需求设置full scale(量程)、ODR（采样速率）、中断、休眠模式 即可。</li><li>坐标系转换<br>这3种传感器在实际应用中，都需要调整IC的坐标系与实际坐标系相匹配。IC的坐标系是固定的，参考规格书，这里以20602为例：<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20161223101725183" alt="这里写图片描述" loading="lazy"><br>而实际应用当中，也有自己的坐标系，手机应用（右手坐标系）：<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20161223101733085" alt="这里写图片描述" loading="lazy"><br>unity应用（左手坐标系）：<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20161223101748589" alt="这里写图片描述" loading="lazy"><br>坐标系的匹配，一般通过驱动的旋转矩阵，来调整。这里需要注意，融合算法一般直接适配的是右手坐标系，而VR应用多数是基于unity引擎开发的，即采用左手坐标系，这里不能将IC的坐标系直接与左手坐标系做匹配，否则会有漂移！这个转换应用会有对应的API去做转换，将驱动坐标系与世界坐标系匹配。</li><li>硬件环境<br>另外传感器对于硬件有所要求，比如IC摆放不能靠近边缘，下方走线规范，附近几毫米内不允许有大电流，马达，软磁、硬磁干扰等等，这方面最好是把PCB给原厂审核，磁方面用他们专门的设备扫描磁力计周围的磁场环境是否正常。<br>基本理论搞清楚调试起来就会得心应手，这里提供一个<a href="http://download.csdn.net/detail/dabenxiong666/9718883?locationNum=4&amp;fps=1">Android平台调试sensor的文档</a>，其他平台类似。</li></ul><h2 id="9轴方案选择">9轴方案选择</h2><p>上面主要对传感器的知识做了一些整理和归纳，下面是我们在做9轴方案选择的一些实验,目前选择市面上使用较多的两家（ST和Invensense）9轴方案进行评估、测试，均是用官方建议最优方案，即：<br>ST:LSM6DSL+LIS3MDL<br>Invensense: imc20603+akm09915<br>对比内容包括静态、动态对比以及结合应用体验来评估2种传感器方案，<a href="https://drive.google.com/open?id=0Bx5hCqFqKCggZHRRdV80ZXk0MWc">测试数据包和测试视频</a>。</p><ul><li><p>静态数据</p><p>放置30秒后，开始采集5分钟静态数据,3000~5000组数据（包括欧拉角、四元素、磁数据），数据见附件中的“静态数据”表格</p><ul><li>静态漂移：<br>根据四元素均方差数据计算，5分钟内ST与Invensense静态角度偏差均小于1度，此项2种方案相同。</li><li>Yaw角偏移：<br>Yaw均方差数值接近(ST为0.19，invensense为0.20)，YAW角偏移大概在1度左右，此项2种方案相同。</li></ul></li><li><p>动态数据</p><ul><li>回归测试：<br>放置到固定位置，任意角度运动1分钟，运动过程未超量程（即：运动中，加速度不超过4g，陀螺仪不超过2000dps），放回原位置，然后对比运动前后，看应用的画面是否与运动前一致。如”回归测试视频”所示，Invensense的画面能够基本回到原来的位置，ST的有明显偏移,这个视频对于2种sensor的优劣还是比较明显的。<br>此项Invensense优于ST。</li><li>磁数据测试<br>固定桌面，缓慢旋转2周，抓取3500个数据点，通过matlab作图。<br>Invensense磁数据图：<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20161223101802996" alt="这里写图片描述" loading="lazy"><br>ST磁数据图：<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20161223101810965" alt="这里写图片描述" loading="lazy"><br>说明:测试时，平放板子到桌面，然后缓慢旋转2周（绕Z轴旋转），上图x/y轴分别未经算法处理的X、Y的磁数据，因为ST和Invensense抓取到的磁数据放大倍数不同所以看起来数据量级不一样，但不影响判断，数据的放大倍数只影响圆的半径大小。磁数据是用来对航向（yaw）校正的，关系到9轴数据的准确性。从图上可以看出invensense的磁数据基本落在一个圆内，ST的磁数据在圆内、圆外都有很多离散的点，影响9周数据的准确性。<br>此项Invensense优于ST。</li></ul></li><li><p>应用体验</p><ul><li>收敛速度<br>结合应用测试，Invensense在运动后1秒内收敛完成，而ST的需要2-3秒的校正时间后，才能收敛完。<br>此项Invensense优于ST.</li></ul></li></ul><p>结论：静态数据2种方案相差不大，5分钟内偏移角度都在1度以内，且有磁力计可以纠正航向问题，都能满足需要，但在动态数据上，Invense明显优于ST，在实际体验中Invense收敛快，能回归，所以9轴方案Invensense优于ST。</p><h1>参考链接</h1><p><a href="https://developer3.oculus.com/blog/sensor-fusion-keeping-it-simple/">oculars sensor doc</a><br><a href="http://www.starlino.com/imu_guide.html">starlino Imu introduce</a><br><a href="https://developer.android.com/guide/topics/sensors/sensors_overview.html">goole sensor introduce</a><br><a href="http://www.geek-workshop.com/thread-1695-1-1.html">geek-workshop</a><br><a href="http://www.amobbs.com/thread-5492189-1-1.html">捷联惯导算法心得</a></p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;center&gt;   &lt;/center&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>陀螺仪--mpu6050</title>
    <link href="https://www.darkfox.top/posts/aff2bd6e/"/>
    <id>https://www.darkfox.top/posts/aff2bd6e/</id>
    <published>2021-07-27T13:49:10.000Z</published>
    <updated>2021-08-20T10:23:04.936Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><span id="more"></span><h1>Ⅰ.陀螺仪</h1><p>陀螺仪是用高速回转体的动量矩敏感壳体相对惯性空间绕正交于自转轴的一个或二个轴的角运动检测装置。利用其他原理制成的角运动检测装置起同样功能的也称陀螺仪。<br>从力学的观点近似的分析陀螺的运动时，可以把它看成是一个刚体，刚体上有一个万向支点，而陀螺可以绕着这个支点作三个自由度的转动，所以陀螺的运动是属于刚体绕一个定点的转动运动。更确切地说，一个绕对称铀高速旋转的飞轮转子叫陀螺。将陀螺安装在框架装置上，使陀螺的自转轴有角转动的自由度，这种装置的总体叫做陀螺仪。<br>陀螺仪的原理就是，一个旋转物体的旋转轴所指的方向在不受外力影响时，是不会改变的。人们根据这个道理，用它来保持方向，制造出来的东西就叫陀螺仪。我们骑自行车其实也是利用了这个原理。轮子转得越快越不容易倒，因为车轴有一股保持水平的力量。陀螺仪在工作时要给它一个力，使它快速旋转起来，一般能达到每分钟几十万转，可以工作很长时间。然后用多种方法读取轴所指示的方向，并自动将数据信号传给控制系统。</p><h1>Ⅱ.MPU6050模块</h1><p>简介：<br>MPU6050内部整合了<strong>三轴MEMS陀螺仪</strong>、<strong>三轴MEMS加速度计</strong>以及一个可扩展的<strong>数字运动处理器DMP(Digital Motion Processor)</strong>，而且还可以连接一个第三方数字传感器(如磁力计)，这样的话，就可以通过IIC接口输出一个9轴信号(链接第三方数字传感器才可以输出九轴信号，否则只有六轴信号)。更加方便的是，有了DMP，可以结合InvenSense公司提供的运动处理资料库，实现姿态解算。通过自带的DMP，可以通过<strong>IIC接口</strong>输出9轴融合演算的数据，大大降低了运动处理运算对操作系统的负荷，同时也降低了开发难度。<em><strong>其实，简单一句话说，陀螺仪就是测角速度的，加速度传感器就是测角加速度的，二者数据通过算法就可以得到PITCH、YAW、ROLL角了。</strong></em></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20140401183456562" alt="右手笛卡尔坐标系" loading="lazy"></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20140401183518578" alt="img" loading="lazy"></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20140401183525562" alt="img" loading="lazy"></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20140401183537890" alt="img" loading="lazy"></p><p>特点：</p><ol><li>以数字形式输出 6 轴或 9 轴（需外接磁传感器）的旋转矩阵、四元数(quaternion)、欧拉角格式(Euler Angle forma)的融合演算数据（需 DMP 支持）</li><li>具有 131 LSBs/° /sec 敏感度与全格感测范围为±250、±500、±1000 与±2000° /sec的 3 轴角速度感测器(陀螺仪)</li><li>集成可程序控制，范围为±2g、±4g、±8g 和±16g 的 3 轴加速度传感器</li><li>移除加速器与陀螺仪轴间敏感度，降低设定给予的影响与感测器的飘移</li><li>自带数字运动处理(DMP: Digital Motion Processing)引擎可减少 MCU 复杂的融合演算数据、感测器同步化、姿势感应等的负荷</li><li>内建运作时间偏差与磁力感测器校正演算技术，免除了客户须另外进行校正的需求</li><li>自带一个数字温度传感器</li><li>带数字输入同步引脚(Sync pin)支持视频电子影相稳定技术与 GPS</li><li>可程序控制的中断(interrupt)，支持姿势识别、摇摄、画面放大缩小、滚动、快速下降中断、 high-G 中断、零动作感应、触击感应、摇动感应功能</li><li>VDD 供电电压为 2.5V±5%、 3.0V±5%、 3.3V±5%； VLOGIC 可低至 1.8V± 5%</li><li>陀螺仪工作电流： 5mA，陀螺仪待机电流： 5uA； 加速器工作电流：500uA，加速器省电模式电流： 40uA@10Hz</li><li>自带 1024 字节 FIFO，有助于降低系统功耗</li><li>高达 400Khz 的 IIC 通信接口</li><li>超小封装尺寸： 4x4x0.9mm（QFN）</li></ol><p>MPU6050三轴角(姿态角)<br><img src="https://img-blog.csdnimg.cn/20210527164308375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpaGFvdGlhbjExMQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"><br><strong>绕向即为正方向，可根据右手螺旋定则确定方向。</strong><br>MPU6050框图：<br><img src="https://img-blog.csdnimg.cn/20210527152447545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpaGFvdGlhbjExMQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy">可以很清晰地观察到，MPU6050芯片中内置了三轴加速度传感器、三轴陀螺仪和一个温度传感器。右侧INT为中断输出脚，TCS为片选脚、AD0为设置地址脚、SCL和SDA为主IIC接口、AUX_CL和AUX_DA为从IIC接口，主要用到的是AD0、SCL、SDA。</p><p>相关寄存器(想深入了解的朋友可以看一下)结合后面的代码更容易理解一些<br>①<br><img src="https://img-blog.csdnimg.cn/20210527153154426.jpg#pic_center" alt="在这里插入图片描述" loading="lazy"><br>DEVICE_RESE=1，复位MPU6050，复位完成后，自动清零。SLEEP=1，进入睡眠模式；SLEEP=0，正常工作模式。TEMP_DIS，用于设置是否使能温度传感器，设置为0，则使能CLKSEL[2:0]，用于选择系统时钟源，如下所示：</p><table><thead><tr><th>CLKSEL[2:0]</th><th>时钟源</th></tr></thead><tbody><tr><td>001</td><td>内部8M RC晶振</td></tr><tr><td>010</td><td>PLL，使用X轴陀螺作为参考</td></tr><tr><td>011</td><td>PLL，使用Y轴陀螺作为参考</td></tr><tr><td>100</td><td>PLL，使用Z轴陀螺作为参考</td></tr><tr><td>101</td><td>PLL，使用外部32.768Khz作为参考</td></tr><tr><td>110</td><td>PLL，使用外部19.2Mhz作为参考</td></tr><tr><td>11</td><td>保留</td></tr><tr><td>001</td><td>关闭时钟，保持时序产生电路复位状态</td></tr></tbody></table><p>总之，电源管理寄存器就是复位MPU6050<br>②<br><img src="https://img-blog.csdnimg.cn/20210527154441137.jpg#pic_center" alt="在这里插入图片描述" loading="lazy"><br>该寄存器我们只关心FS_SEL[1:0]这两个位，用于设置陀螺仪的满量程范围：0，±250°/s；1，±500°/s；2，±1000°/s；3，±2000°/s；我们一般设置为3，即±2000°/S，因为陀螺仪的ADC为16位分辨率，所以得到灵敏度为：65536/4000=16.4LSB/(°/S)。<br>总之，陀螺仪配置寄存器就是配置陀螺仪满量程范围，设置最大<br>③<br><img src="https://img-blog.csdnimg.cn/20210527154625454.jpg#pic_center" alt="在这里插入图片描述" loading="lazy"><br>该寄存器我们只关心AFS_SEL[1:0]这两个位，用于设置加速度传感器的满量程范围：0，±2g；1，±4g；2，±8g；3，±16g；我们一般设置为0，即±2g，因为加速度传感器的ADC也是16位，所以得到灵敏度为：65536/4=16384LSB/g。<br>总之，加速度传感器配置寄存器就是配置加速度传感器满量程范围，不宜过大<br>④<br><img src="https://img-blog.csdnimg.cn/20210527154801757.jpg#pic_center" alt="在这里插入图片描述" loading="lazy"><br>该寄存器用于控制FIFO使能，在简单读取传感器数据的时候，可以不用FIFO，设置对应位为：0，即可禁止FIFO，设置为1，则使能FIFO。加速度传感器的三个轴，全由一个位(ACCEL_FIFO_EN)控制，只要该位为1，则加速度传感器三个通道都开启FIFO；但是陀螺仪传感器的三个轴需要一个一个设置，即XYZ轴分别配置。<br>总之，FIFO使能寄存器用于控制使能FIFO(First Input First Output)<br>⑤<br><img src="https://img-blog.csdnimg.cn/20210527160414156.jpg#pic_center" alt="在这里插入图片描述" loading="lazy"><br>该寄存器用于设置MPU6050的陀螺仪采样频率，计算公式为：<strong>采样频率 = 陀螺仪输出频率 / (1+SMPLRT_DIV)</strong>。这里陀螺仪的输出频率，是1Khz或者8Khz，与数字低通滤波器（DLPF）的设置有关，当DLPF_CFG=0或7的时候，频率为8Khz，其他情况是1Khz。而且DLPF滤波频率一般设置为采样率的一半。采样率，我们假定设置为50Hz，那么：SMPLRT_DIV=1000/50-1=19。<br>总之，陀螺仪采样率分频寄存器就是用于设置陀螺仪的采样频率，如果采样频率为50Hz，那么采样周期就为1/50=20ms，即20ms采集一次陀螺仪的数据。<br>⑥<br><img src="https://img-blog.csdnimg.cn/20210527160935948.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpaGFvdGlhbjExMQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"><br>总之，配置寄存器就是设置数字低通滤波器的DLPF_CFG位来结合陀螺仪采样分频寄存器来共同设置采样周期。<br>⑦<br><img src="https://img-blog.csdnimg.cn/20210527162315369.jpg#pic_center" alt="在这里插入图片描述" loading="lazy"><br>该寄存器的LP_WAKE_CTRL用于控制低功耗时的唤醒频率，用不到。剩下的6位，分别控制加速度和陀螺仪的x/y/z轴是否进入待机模式，这里我们全部都不进入待机模式，所以全部设置为：0 ，即可。<br>总之，电源管理寄存器2就是用于设置加速度传感器和陀螺仪的X/Y/Z轴是进入休眠还是正常工作。<br>⑧<img src="https://img-blog.csdnimg.cn/20210527162507349.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpaGFvdGlhbjExMQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"><br>加速度传感器数据输出寄存器总共由6个寄存器组成，输出X/Y/Z三个轴的加速度传感器值，高字节在前，低字节在后。<br>总之，加速度传感器数据输出寄存器就是把加速度传感器测量到的数据输出出来。<br>⑨<br><img src="https://img-blog.csdnimg.cn/2021052716305611.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpaGFvdGlhbjExMQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"><br>陀螺仪数据输出寄存器总共由6个寄存器组成，输出X/Y/Z三个轴的陀螺仪传感器数据，高字节在前，低字节在后。<br>总之，陀螺仪数据输出寄存器就是把陀螺仪测量到的数据输出出来。<br>⑩<br><img src="https://img-blog.csdnimg.cn/20210527163838510.jpg#pic_center" alt="在这里插入图片描述" loading="lazy"><br>通过读取0X41（高8位）和0X42（低8位）寄存器得到，温度换算公式为：<br>Temperature = 36.53 + regval/340。其中，Temperature为计算得到的温度值，单位为℃，regval为从0X41和0X42读到的温度传感器值。<br>总之，温度传感器数据输出寄存器就是把温度寄存器测量到的数据处处出来。</p><h1>3.硬件连接</h1><p><img src="https://img-blog.csdnimg.cn/20210527164235503.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpaGFvdGlhbjExMQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"><br><strong>VCC</strong>:接5V电源<br><strong>GND</strong>:接地<br><strong>SCL</strong>:主IIC时钟线 (我接的PB10)<br><strong>SDA</strong>:主IIC数据线 (我接的PB11)<br><strong>AD0</strong>:地址线，接3V地址为0x68，接地地址为0x69（我接的PA15，高电平，地址为0x68）</p><h1>4.软件代码————官方自带库</h1><p>MPU6050处理寄存器的相关数据时需要移植几个官方库，以便将数据处理为所需要的欧拉角。正点原子共提供了五个源码，如下图：<br><img src="https://img-blog.csdnimg.cn/20210527171530241.jpg#pic_center" alt="在这里插入图片描述" loading="lazy"><br>这些是需要在写MPU6050代码之前移植过来的，具体代码内容大家可以下载下方源码查看。</p><h1>5.软件代码————其他代码</h1><p>MPU6050.h<br><strong>主要宏定义一些MPU6050寄存器的地址，方便IIC发送给寄存器数据初始化MPU6050。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __MPU6050_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __MPU6050_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mpuiic.h&quot;</span>       </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//MPU6050 AD0控制脚</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_AD0_CTRLPAout(15)<span class="comment">//控制AD0电平,从而控制MPU地址</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define MPU_ACCEL_OFFS_REG0X06//accel_offs寄存器,可读取版本号,寄存器手册未提到</span></span><br><span class="line"><span class="comment">//#define MPU_PROD_ID_REG0X0C//prod id寄存器,在寄存器手册未提到</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_SELF_TESTX_REG0X0D<span class="comment">//自检寄存器X</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_SELF_TESTY_REG0X0E<span class="comment">//自检寄存器Y</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_SELF_TESTZ_REG0X0F<span class="comment">//自检寄存器Z</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_SELF_TESTA_REG0X10<span class="comment">//自检寄存器A</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_SAMPLE_RATE_REG0X19<span class="comment">//采样频率分频器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_CFG_REG0X1A<span class="comment">//配置寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_GYRO_CFG_REG0X1B<span class="comment">//陀螺仪配置寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_ACCEL_CFG_REG0X1C<span class="comment">//加速度计配置寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_MOTION_DET_REG0X1F<span class="comment">//运动检测阀值设置寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_FIFO_EN_REG0X23<span class="comment">//FIFO使能寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_I2CMST_CTRL_REG0X24<span class="comment">//IIC主机控制寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_I2CSLV0_ADDR_REG0X25<span class="comment">//IIC从机0器件地址寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_I2CSLV0_REG0X26<span class="comment">//IIC从机0数据地址寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_I2CSLV0_CTRL_REG0X27<span class="comment">//IIC从机0控制寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_I2CSLV1_ADDR_REG0X28<span class="comment">//IIC从机1器件地址寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_I2CSLV1_REG0X29<span class="comment">//IIC从机1数据地址寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_I2CSLV1_CTRL_REG0X2A<span class="comment">//IIC从机1控制寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_I2CSLV2_ADDR_REG0X2B<span class="comment">//IIC从机2器件地址寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_I2CSLV2_REG0X2C<span class="comment">//IIC从机2数据地址寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_I2CSLV2_CTRL_REG0X2D<span class="comment">//IIC从机2控制寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_I2CSLV3_ADDR_REG0X2E<span class="comment">//IIC从机3器件地址寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_I2CSLV3_REG0X2F<span class="comment">//IIC从机3数据地址寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_I2CSLV3_CTRL_REG0X30<span class="comment">//IIC从机3控制寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_I2CSLV4_ADDR_REG0X31<span class="comment">//IIC从机4器件地址寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_I2CSLV4_REG0X32<span class="comment">//IIC从机4数据地址寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_I2CSLV4_DO_REG0X33<span class="comment">//IIC从机4写数据寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_I2CSLV4_CTRL_REG0X34<span class="comment">//IIC从机4控制寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_I2CSLV4_DI_REG0X35<span class="comment">//IIC从机4读数据寄存器</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_I2CMST_STA_REG0X36<span class="comment">//IIC主机状态寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_INTBP_CFG_REG0X37<span class="comment">//中断/旁路设置寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_INT_EN_REG0X38<span class="comment">//中断使能寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_INT_STA_REG0X3A<span class="comment">//中断状态寄存器</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_ACCEL_XOUTH_REG0X3B<span class="comment">//加速度值,X轴高8位寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_ACCEL_XOUTL_REG0X3C<span class="comment">//加速度值,X轴低8位寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_ACCEL_YOUTH_REG0X3D<span class="comment">//加速度值,Y轴高8位寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_ACCEL_YOUTL_REG0X3E<span class="comment">//加速度值,Y轴低8位寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_ACCEL_ZOUTH_REG0X3F<span class="comment">//加速度值,Z轴高8位寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_ACCEL_ZOUTL_REG0X40<span class="comment">//加速度值,Z轴低8位寄存器</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_TEMP_OUTH_REG0X41<span class="comment">//温度值高八位寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_TEMP_OUTL_REG0X42<span class="comment">//温度值低8位寄存器</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_GYRO_XOUTH_REG0X43<span class="comment">//陀螺仪值,X轴高8位寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_GYRO_XOUTL_REG0X44<span class="comment">//陀螺仪值,X轴低8位寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_GYRO_YOUTH_REG0X45<span class="comment">//陀螺仪值,Y轴高8位寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_GYRO_YOUTL_REG0X46<span class="comment">//陀螺仪值,Y轴低8位寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_GYRO_ZOUTH_REG0X47<span class="comment">//陀螺仪值,Z轴高8位寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_GYRO_ZOUTL_REG0X48<span class="comment">//陀螺仪值,Z轴低8位寄存器</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_I2CSLV0_DO_REG0X63<span class="comment">//IIC从机0数据寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_I2CSLV1_DO_REG0X64<span class="comment">//IIC从机1数据寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_I2CSLV2_DO_REG0X65<span class="comment">//IIC从机2数据寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_I2CSLV3_DO_REG0X66<span class="comment">//IIC从机3数据寄存器</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_I2CMST_DELAY_REG0X67<span class="comment">//IIC主机延时管理寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_SIGPATH_RST_REG0X68<span class="comment">//信号通道复位寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_MDETECT_CTRL_REG0X69<span class="comment">//运动检测控制寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_USER_CTRL_REG0X6A<span class="comment">//用户控制寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_PWR_MGMT1_REG0X6B<span class="comment">//电源管理寄存器1</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_PWR_MGMT2_REG0X6C<span class="comment">//电源管理寄存器2 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_FIFO_CNTH_REG0X72<span class="comment">//FIFO计数寄存器高八位</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_FIFO_CNTL_REG0X73<span class="comment">//FIFO计数寄存器低八位</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_FIFO_RW_REG0X74<span class="comment">//FIFO读写寄存器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_DEVICE_ID_REG0X75<span class="comment">//器件ID寄存器</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//如果AD0脚(9脚)接地,IIC地址为0X68(不包含最低位).</span></span><br><span class="line"><span class="comment">//如果接V3.3,则IIC地址为0X69(不包含最低位).</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_ADDR0X68</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//因为模块AD0默认接GND,所以转为读写地址后,为0XD1和0XD0(如果接VCC,则为0XD3和0XD2)  </span></span><br><span class="line"><span class="comment">//#define MPU_READ    0XD1</span></span><br><span class="line"><span class="comment">//#define MPU_WRITE   0XD0</span></span><br><span class="line"></span><br><span class="line"><span class="function">u8 <span class="title">MPU_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//初始化MPU6050</span></span><br><span class="line"><span class="function">u8 <span class="title">MPU_Write_Len</span><span class="params">(u8 addr,u8 reg,u8 len,u8 *buf)</span></span>;<span class="comment">//IIC连续写</span></span><br><span class="line"><span class="function">u8 <span class="title">MPU_Read_Len</span><span class="params">(u8 addr,u8 reg,u8 len,u8 *buf)</span></span>; <span class="comment">//IIC连续读 </span></span><br><span class="line"><span class="function">u8 <span class="title">MPU_Write_Byte</span><span class="params">(u8 reg,u8 data)</span></span>;<span class="comment">//IIC写一个字节</span></span><br><span class="line"><span class="function">u8 <span class="title">MPU_Read_Byte</span><span class="params">(u8 reg)</span></span>;<span class="comment">//IIC读一个字节</span></span><br><span class="line"></span><br><span class="line"><span class="function">u8 <span class="title">MPU_Set_Gyro_Fsr</span><span class="params">(u8 fsr)</span></span>;</span><br><span class="line"><span class="function">u8 <span class="title">MPU_Set_Accel_Fsr</span><span class="params">(u8 fsr)</span></span>;</span><br><span class="line"><span class="function">u8 <span class="title">MPU_Set_LPF</span><span class="params">(u16 lpf)</span></span>;</span><br><span class="line"><span class="function">u8 <span class="title">MPU_Set_Rate</span><span class="params">(u16 rate)</span></span>;</span><br><span class="line"><span class="function">u8 <span class="title">MPU_Set_Fifo</span><span class="params">(u8 sens)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">MPU_Get_Temperature</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function">u8 <span class="title">MPU_Get_Gyroscope</span><span class="params">(<span class="keyword">short</span> *gx,<span class="keyword">short</span> *gy,<span class="keyword">short</span> *gz)</span></span>;</span><br><span class="line"><span class="function">u8 <span class="title">MPU_Get_Accelerometer</span><span class="params">(<span class="keyword">short</span> *ax,<span class="keyword">short</span> *ay,<span class="keyword">short</span> *az)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105</span></span><br></pre></td></tr></table></figure><p>MPU6050.c<br><strong>主要是单片机通过IIC协议向MPU6050写数据读数据的函数以及MPU6050初始化函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mpu6050.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;usart.h&quot;</span>   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">函数名称：MPU_Init</span></span><br><span class="line"><span class="comment">函数功能：初始化MPU6050</span></span><br><span class="line"><span class="comment">函数参数：无</span></span><br><span class="line"><span class="comment">函数返回值：0,初始化成功  其他,初始化失败</span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="function">u8 <span class="title">MPU_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">u8 res;</span><br><span class="line">  </span><br><span class="line">GPIO_InitTypeDef  GPIO_InitStructure;</span><br><span class="line"></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);<span class="comment">//使能AFIO时钟 </span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//先使能外设IO PORTA时钟 </span></span><br><span class="line"></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15;  <span class="comment">//端口配置</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;  <span class="comment">//推挽输出</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  <span class="comment">//IO口速度为50MHz</span></span><br><span class="line">  GPIO_Init(GPIOA, &amp;GPIO_InitStructure);      <span class="comment">//根据设定参数初始化GPIOA</span></span><br><span class="line"></span><br><span class="line">GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE);<span class="comment">//禁止JTAG,从而PA15可以做普通IO使用,否则PA15不能做普通IO!!!</span></span><br><span class="line"></span><br><span class="line">MPU_AD0_CTRL=<span class="number">0</span>;<span class="comment">//控制MPU6050的AD0脚为低电平,从机地址为:0X68</span></span><br><span class="line"></span><br><span class="line">MPU_IIC_Init();<span class="comment">//初始化IIC总线</span></span><br><span class="line">MPU_Write_Byte(MPU_PWR_MGMT1_REG,<span class="number">0X80</span>);<span class="comment">//复位MPU6050</span></span><br><span class="line">  delay_ms(<span class="number">100</span>);</span><br><span class="line">MPU_Write_Byte(MPU_PWR_MGMT1_REG,<span class="number">0X00</span>);<span class="comment">//唤醒MPU6050 </span></span><br><span class="line">MPU_Set_Gyro_Fsr(<span class="number">3</span>);<span class="comment">//陀螺仪传感器,±2000dps</span></span><br><span class="line">MPU_Set_Accel_Fsr(<span class="number">0</span>);<span class="comment">//加速度传感器,±2g</span></span><br><span class="line">MPU_Set_Rate(<span class="number">50</span>);<span class="comment">//设置采样率50Hz</span></span><br><span class="line">MPU_Write_Byte(MPU_INT_EN_REG,<span class="number">0X00</span>);<span class="comment">//关闭所有中断</span></span><br><span class="line">MPU_Write_Byte(MPU_USER_CTRL_REG,<span class="number">0X00</span>);<span class="comment">//I2C主模式关闭</span></span><br><span class="line">MPU_Write_Byte(MPU_FIFO_EN_REG,<span class="number">0X00</span>);<span class="comment">//关闭FIFO</span></span><br><span class="line">MPU_Write_Byte(MPU_INTBP_CFG_REG,<span class="number">0X80</span>);<span class="comment">//INT引脚低电平有效</span></span><br><span class="line"></span><br><span class="line">res=MPU_Read_Byte(MPU_DEVICE_ID_REG);</span><br><span class="line"><span class="keyword">if</span>(res==MPU_ADDR)<span class="comment">//器件ID正确,即res = MPU_ADDR = 0x68</span></span><br><span class="line">&#123;</span><br><span class="line">MPU_Write_Byte(MPU_PWR_MGMT1_REG,<span class="number">0X01</span>);<span class="comment">//设置CLKSEL,PLL X轴为参考</span></span><br><span class="line">MPU_Write_Byte(MPU_PWR_MGMT2_REG,<span class="number">0X00</span>);<span class="comment">//加速度与陀螺仪都工作</span></span><br><span class="line">MPU_Set_Rate(<span class="number">50</span>);<span class="comment">//设置采样率为50Hz</span></span><br><span class="line"> &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;    <span class="comment">//地址设置错误,返回1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//地址设置正确,返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">函数名称：MPU_Set_Gyro_Fsr</span></span><br><span class="line"><span class="comment">函数功能：设置MPU6050陀螺仪传感器满量程范围</span></span><br><span class="line"><span class="comment">函数参数：fsr:0,±250dps;1,±500dps;2,±1000dps;3,±2000dps</span></span><br><span class="line"><span class="comment">函数返回值：0,设置成功  其他,设置失败</span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="function">u8 <span class="title">MPU_Set_Gyro_Fsr</span><span class="params">(u8 fsr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> MPU_Write_Byte(MPU_GYRO_CFG_REG,fsr&lt;&lt;<span class="number">3</span>); <span class="comment">//设置陀螺仪满量程范围</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">函数名称：MPU_Set_Accel_Fsr</span></span><br><span class="line"><span class="comment">函数功能：设置MPU6050加速度传感器满量程范围</span></span><br><span class="line"><span class="comment">函数参数：fsr:0,±2g;1,±4g;2,±8g;3,±16g</span></span><br><span class="line"><span class="comment">函数返回值：0,设置成功  其他,设置失败</span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="function">u8 <span class="title">MPU_Set_Accel_Fsr</span><span class="params">(u8 fsr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> MPU_Write_Byte(MPU_ACCEL_CFG_REG,fsr&lt;&lt;<span class="number">3</span>); <span class="comment">//设置加速度传感器满量程范围  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">函数名称：MPU_Set_LPF</span></span><br><span class="line"><span class="comment">函数功能：设置MPU6050的数字低通滤波器</span></span><br><span class="line"><span class="comment">函数参数：lpf:数字低通滤波频率(Hz)</span></span><br><span class="line"><span class="comment">函数返回值：0,设置成功  其他,设置失败</span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="function">u8 <span class="title">MPU_Set_LPF</span><span class="params">(u16 lpf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u8 data=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(lpf&gt;=<span class="number">188</span>)data=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(lpf&gt;=<span class="number">98</span>)data=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(lpf&gt;=<span class="number">42</span>)data=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(lpf&gt;=<span class="number">20</span>)data=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(lpf&gt;=<span class="number">10</span>)data=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">else</span> data=<span class="number">6</span>; </span><br><span class="line"><span class="keyword">return</span> MPU_Write_Byte(MPU_CFG_REG,data);<span class="comment">//设置数字低通滤波器  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">函数名称：MPU_Set_Rate</span></span><br><span class="line"><span class="comment">函数功能：设置MPU6050的采样率(假定Fs=1KHz)</span></span><br><span class="line"><span class="comment">函数参数：rate:4~1000(Hz)  初始化中rate取50</span></span><br><span class="line"><span class="comment">函数返回值：0,设置成功  其他,设置失败</span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="function">u8 <span class="title">MPU_Set_Rate</span><span class="params">(u16 rate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u8 data;</span><br><span class="line"><span class="keyword">if</span>(rate&gt;<span class="number">1000</span>)rate=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">if</span>(rate&lt;<span class="number">4</span>)rate=<span class="number">4</span>;</span><br><span class="line">data=<span class="number">1000</span>/rate<span class="number">-1</span>;</span><br><span class="line">data=MPU_Write_Byte(MPU_SAMPLE_RATE_REG,data);<span class="comment">//设置数字低通滤波器</span></span><br><span class="line"> <span class="keyword">return</span> MPU_Set_LPF(rate/<span class="number">2</span>);<span class="comment">//自动设置LPF为采样率的一半</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">函数名称：MPU_Get_Temperature</span></span><br><span class="line"><span class="comment">函数功能：得到温度传感器值</span></span><br><span class="line"><span class="comment">函数参数：无</span></span><br><span class="line"><span class="comment">函数返回值：温度值(扩大了100倍)</span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">MPU_Get_Temperature</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   u8 buf[<span class="number">2</span>]; </span><br><span class="line">   <span class="keyword">short</span> raw;</span><br><span class="line"> <span class="keyword">float</span> temp;</span><br><span class="line"></span><br><span class="line"> MPU_Read_Len(MPU_ADDR,MPU_TEMP_OUTH_REG,<span class="number">2</span>,buf); </span><br><span class="line">   raw=((u16)buf[<span class="number">0</span>]&lt;&lt;<span class="number">8</span>)|buf[<span class="number">1</span>];</span><br><span class="line">   temp=<span class="number">36.53</span>+((<span class="keyword">double</span>)raw)/<span class="number">340</span>;</span><br><span class="line">   <span class="keyword">return</span> temp*<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">函数名称：MPU_Get_Gyroscope</span></span><br><span class="line"><span class="comment">函数功能：得到陀螺仪值(原始值)</span></span><br><span class="line"><span class="comment">函数参数：gx,gy,gz:陀螺仪x,y,z轴的原始读数(带符号)</span></span><br><span class="line"><span class="comment">函数返回值：0,读取成功  其他,读取失败</span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="function">u8 <span class="title">MPU_Get_Gyroscope</span><span class="params">(<span class="keyword">short</span> *gx,<span class="keyword">short</span> *gy,<span class="keyword">short</span> *gz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  u8 buf[<span class="number">6</span>],res;</span><br><span class="line"></span><br><span class="line">res=MPU_Read_Len(MPU_ADDR,MPU_GYRO_XOUTH_REG,<span class="number">6</span>,buf);</span><br><span class="line"><span class="keyword">if</span>(res==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">*gx=((u16)buf[<span class="number">0</span>]&lt;&lt;<span class="number">8</span>)|buf[<span class="number">1</span>];</span><br><span class="line">*gy=((u16)buf[<span class="number">2</span>]&lt;&lt;<span class="number">8</span>)|buf[<span class="number">3</span>];</span><br><span class="line">*gz=((u16)buf[<span class="number">4</span>]&lt;&lt;<span class="number">8</span>)|buf[<span class="number">5</span>];</span><br><span class="line">&#125; </span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">函数名称：MPU_Get_Accelerometer</span></span><br><span class="line"><span class="comment">函数功能：得到加速度值(原始值)</span></span><br><span class="line"><span class="comment">函数参数：ax,ay,az:加速度传感器x,y,z轴的原始读数(带符号)</span></span><br><span class="line"><span class="comment">函数返回值：0,读取成功  其他,读取失败</span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="function">u8 <span class="title">MPU_Get_Accelerometer</span><span class="params">(<span class="keyword">short</span> *ax,<span class="keyword">short</span> *ay,<span class="keyword">short</span> *az)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u8 buf[<span class="number">6</span>],res;  </span><br><span class="line">res=MPU_Read_Len(MPU_ADDR,MPU_ACCEL_XOUTH_REG,<span class="number">6</span>,buf);</span><br><span class="line"><span class="keyword">if</span>(res==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">*ax=((u16)buf[<span class="number">0</span>]&lt;&lt;<span class="number">8</span>)|buf[<span class="number">1</span>];  </span><br><span class="line">*ay=((u16)buf[<span class="number">2</span>]&lt;&lt;<span class="number">8</span>)|buf[<span class="number">3</span>];  </span><br><span class="line">*az=((u16)buf[<span class="number">4</span>]&lt;&lt;<span class="number">8</span>)|buf[<span class="number">5</span>];</span><br><span class="line">&#125; </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">函数名称：MPU_Write_Len</span></span><br><span class="line"><span class="comment">函数功能：IIC连续写(写器件地址、寄存器地址、数据)</span></span><br><span class="line"><span class="comment">函数参数：addr:器件地址      reg:寄存器地址</span></span><br><span class="line"><span class="comment"> len:写入数据的长度  buf:数据区</span></span><br><span class="line"><span class="comment">函数返回值：0,写入成功  其他,写入失败</span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="function">u8 <span class="title">MPU_Write_Len</span><span class="params">(u8 addr,u8 reg,u8 len,u8 *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u8 i;</span><br><span class="line"></span><br><span class="line">MPU_IIC_Start();</span><br><span class="line">MPU_IIC_Send_Byte((addr&lt;&lt;<span class="number">1</span>)|<span class="number">0</span>);      <span class="comment">//发送器件地址+写命令(0为写,1为读)</span></span><br><span class="line"><span class="keyword">if</span>(MPU_IIC_Wait_Ack()) <span class="comment">//等待应答</span></span><br><span class="line">&#123;</span><br><span class="line">MPU_IIC_Stop();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    MPU_IIC_Send_Byte(reg); <span class="comment">//写寄存器地址</span></span><br><span class="line">    MPU_IIC_Wait_Ack();             <span class="comment">//等待应答</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">MPU_IIC_Send_Byte(buf[i]);       <span class="comment">//发送数据</span></span><br><span class="line"><span class="keyword">if</span>(MPU_IIC_Wait_Ack())         <span class="comment">//等待ACK</span></span><br><span class="line">&#123;</span><br><span class="line">MPU_IIC_Stop();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    MPU_IIC_Stop();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">函数名称：MPU_Read_Len</span></span><br><span class="line"><span class="comment">函数功能：IIC连续读(写入器件地址后,读寄存器地址、数据)</span></span><br><span class="line"><span class="comment">函数参数：addr:器件地址        reg:要读的寄存器地址</span></span><br><span class="line"><span class="comment"> len:要读取的数据长度  buf:读取到的数据存储区</span></span><br><span class="line"><span class="comment">函数返回值：0,读取成功  其他,读取失败</span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="function">u8 <span class="title">MPU_Read_Len</span><span class="params">(u8 addr,u8 reg,u8 len,u8 *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MPU_IIC_Start();</span><br><span class="line">MPU_IIC_Send_Byte((addr&lt;&lt;<span class="number">1</span>)|<span class="number">0</span>);<span class="comment">//发送器件地址+写命令</span></span><br><span class="line"><span class="keyword">if</span>(MPU_IIC_Wait_Ack())<span class="comment">//等待应答</span></span><br><span class="line">&#123;</span><br><span class="line">MPU_IIC_Stop(); </span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    MPU_IIC_Send_Byte(reg);<span class="comment">//写寄存器地址</span></span><br><span class="line">    MPU_IIC_Wait_Ack();<span class="comment">//等待应答</span></span><br><span class="line">    MPU_IIC_Start();</span><br><span class="line">MPU_IIC_Send_Byte((addr&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>);<span class="comment">//发送器件地址+读命令</span></span><br><span class="line">    MPU_IIC_Wait_Ack();<span class="comment">//等待应答 </span></span><br><span class="line"><span class="keyword">while</span>(len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(len==<span class="number">1</span>) *buf=MPU_IIC_Read_Byte(<span class="number">0</span>);   <span class="comment">//读数据,发送nACK </span></span><br><span class="line"><span class="keyword">else</span>  *buf=MPU_IIC_Read_Byte(<span class="number">1</span>);<span class="comment">//读数据,发送ACK  </span></span><br><span class="line">len--;</span><br><span class="line">buf++;</span><br><span class="line">&#125;</span><br><span class="line">    MPU_IIC_Stop();<span class="comment">//产生一个停止条件 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">函数名称：MPU_Write_Byte</span></span><br><span class="line"><span class="comment">函数功能：IIC写一个字节</span></span><br><span class="line"><span class="comment">函数参数：data:写入的数据    reg:要写的寄存器地址</span></span><br><span class="line"><span class="comment">函数返回值：0,写入成功  其他,写入失败</span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="function">u8 <span class="title">MPU_Write_Byte</span><span class="params">(u8 reg,u8 data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  MPU_IIC_Start();</span><br><span class="line">MPU_IIC_Send_Byte((MPU_ADDR&lt;&lt;<span class="number">1</span>)|<span class="number">0</span>);<span class="comment">//发送器件地址+写命令</span></span><br><span class="line"><span class="keyword">if</span>(MPU_IIC_Wait_Ack()) <span class="comment">//等待应答</span></span><br><span class="line">&#123;</span><br><span class="line">MPU_IIC_Stop();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">  MPU_IIC_Send_Byte(reg);<span class="comment">//写寄存器地址</span></span><br><span class="line">  MPU_IIC_Wait_Ack();<span class="comment">//等待应答</span></span><br><span class="line">MPU_IIC_Send_Byte(data);<span class="comment">//发送数据</span></span><br><span class="line"><span class="keyword">if</span>(MPU_IIC_Wait_Ack())  <span class="comment">//等待ACK</span></span><br><span class="line">&#123;</span><br><span class="line">MPU_IIC_Stop();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">  MPU_IIC_Stop();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">函数名称：MPU_Read_Byte</span></span><br><span class="line"><span class="comment">函数功能：IIC读一个字节</span></span><br><span class="line"><span class="comment">函数参数：reg:要读的寄存器地址</span></span><br><span class="line"><span class="comment">函数返回值：res:读取到的数据</span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="function">u8 <span class="title">MPU_Read_Byte</span><span class="params">(u8 reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u8 res;</span><br><span class="line"></span><br><span class="line">  MPU_IIC_Start(); </span><br><span class="line">MPU_IIC_Send_Byte((MPU_ADDR&lt;&lt;<span class="number">1</span>)|<span class="number">0</span>);<span class="comment">//发送器件地址+写命令</span></span><br><span class="line">MPU_IIC_Wait_Ack();<span class="comment">//等待应答 </span></span><br><span class="line">  MPU_IIC_Send_Byte(reg);<span class="comment">//写寄存器地址</span></span><br><span class="line">  MPU_IIC_Wait_Ack();<span class="comment">//等待应答</span></span><br><span class="line">  MPU_IIC_Start();</span><br><span class="line">MPU_IIC_Send_Byte((MPU_ADDR&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>);<span class="comment">//发送器件地址+读命令</span></span><br><span class="line">  MPU_IIC_Wait_Ack();<span class="comment">//等待应答 </span></span><br><span class="line">res=MPU_IIC_Read_Byte(<span class="number">0</span>);<span class="comment">//读取数据,发送nACK </span></span><br><span class="line">  MPU_IIC_Stop();<span class="comment">//产生一个停止条件 </span></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279</span></span><br></pre></td></tr></table></figure><p>mpuiic.h<br><strong>MPU的IIC协议函数头文件，PB11为SDA，PB10为SCL。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __MPUIIC_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __MPUIIC_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//IO方向设置  ---PB11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_SDA_IN()  &#123;GPIOB-&gt;CRH &amp;= 0XFFFF0FFF;GPIOB-&gt;CRH |= 8&lt;&lt;12;&#125;   <span class="comment">//上拉/下拉 输入模式</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_SDA_OUT() &#123;GPIOB-&gt;CRH &amp;= 0XFFFF0FFF;GPIOB-&gt;CRH |= 3&lt;&lt;12;&#125;<span class="comment">//推挽输出  输出模式</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//IO操作函数 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_IIC_SCL    PBout(10) <span class="comment">//SCL</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_IIC_SDA    PBout(11) <span class="comment">//SDA </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPU_READ_SDA   PBin(11) <span class="comment">//输入SDA </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//IIC所有操作函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MPU_IIC_Delay</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//IIC延时2ms函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MPU_IIC_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;                <span class="comment">//初始化IIC的IO口 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MPU_IIC_Start</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//发送IIC开始信号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MPU_IIC_Stop</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">//发送IIC停止信号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MPU_IIC_Send_Byte</span><span class="params">(u8 txd)</span></span>;<span class="comment">//IIC发送一个字节</span></span><br><span class="line"><span class="function">u8 <span class="title">MPU_IIC_Read_Byte</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> ack)</span></span>;<span class="comment">//IIC读取一个字节</span></span><br><span class="line"><span class="function">u8 <span class="title">MPU_IIC_Wait_Ack</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//IIC等待ACK信号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MPU_IIC_Ack</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//IIC发送ACK信号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MPU_IIC_NAck</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//IIC不发送ACK信号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IMPU_IC_Write_One_Byte</span><span class="params">(u8 daddr,u8 addr,u8 data)</span></span>;</span><br><span class="line"><span class="function">u8 <span class="title">MPU_IIC_Read_One_Byte</span><span class="params">(u8 daddr,u8 addr)</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829</span></span><br></pre></td></tr></table></figure><p>mpuiic.c<br><strong>MPU的IIC协议函数编写</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mpuiic.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">函数名称：MPU_IIC_Delay</span></span><br><span class="line"><span class="comment">函数功能：MPU IIC延时函数，延时2ms</span></span><br><span class="line"><span class="comment">函数参数：无</span></span><br><span class="line"><span class="comment">函数返回值：无</span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MPU_IIC_Delay</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">delay_us(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">函数名称：MPU_IIC_Init</span></span><br><span class="line"><span class="comment">函数功能：MPU IIC初始化</span></span><br><span class="line"><span class="comment">函数参数：无</span></span><br><span class="line"><span class="comment">函数返回值：无</span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MPU_IIC_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">  GPIO_InitTypeDef  GPIO_InitStructure;</span><br><span class="line"></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);<span class="comment">//先使能外设IO PORTB时钟 </span></span><br><span class="line"></span><br><span class="line">  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10|GPIO_Pin_11;  <span class="comment">//端口配置</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;   <span class="comment">//推挽输出</span></span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  <span class="comment">//IO口速度为50MHz</span></span><br><span class="line">  GPIO_Init(GPIOB, &amp;GPIO_InitStructure); <span class="comment">//根据设定参数初始化GPIO </span></span><br><span class="line"></span><br><span class="line">  GPIO_SetBits(GPIOB,GPIO_Pin_10|GPIO_Pin_11);  <span class="comment">//PB10,PB11 输出高</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">函数名称：MPU_IIC_Start</span></span><br><span class="line"><span class="comment">函数功能：MPU IIC发送起始信号</span></span><br><span class="line"><span class="comment">函数参数：无</span></span><br><span class="line"><span class="comment">函数返回值：无</span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MPU_IIC_Start</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MPU_SDA_OUT();     <span class="comment">//SDA线 输出</span></span><br><span class="line">MPU_IIC_SDA=<span class="number">1</span>;    </span><br><span class="line">MPU_IIC_SCL=<span class="number">1</span>;</span><br><span class="line">MPU_IIC_Delay();</span><br><span class="line"> MPU_IIC_SDA=<span class="number">0</span>;     <span class="comment">//START:当SCL线处于高电平时,SDA线突然从高变低,发送起始信号</span></span><br><span class="line">MPU_IIC_Delay();</span><br><span class="line">MPU_IIC_SCL=<span class="number">0</span>; <span class="comment">//钳住I2C总线，准备发送或接收数据 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">函数名称：MPU_IIC_Stop</span></span><br><span class="line"><span class="comment">函数功能：MPU IIC发送停止信号</span></span><br><span class="line"><span class="comment">函数参数：无</span></span><br><span class="line"><span class="comment">函数返回值：无</span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MPU_IIC_Stop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MPU_SDA_OUT(); <span class="comment">//SDA线输出</span></span><br><span class="line">MPU_IIC_SCL=<span class="number">0</span>;</span><br><span class="line">MPU_IIC_SDA=<span class="number">0</span>; <span class="comment">//STOP:当SCL线处于高电平时,SDA线突然从低变高,发送停止信号</span></span><br><span class="line"> MPU_IIC_Delay();</span><br><span class="line">MPU_IIC_SCL=<span class="number">1</span>; </span><br><span class="line">MPU_IIC_SDA=<span class="number">1</span>; <span class="comment">//发送I2C总线结束信号</span></span><br><span class="line">MPU_IIC_Delay();   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">函数名称：MPU_IIC_Wait_Ack</span></span><br><span class="line"><span class="comment">函数功能：MPU IIC等待信号到来</span></span><br><span class="line"><span class="comment">函数参数：无</span></span><br><span class="line"><span class="comment">函数返回值：1:接收应答信号成功  0:接收应答信号失败</span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="function">u8 <span class="title">MPU_IIC_Wait_Ack</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u8 ucErrTime=<span class="number">0</span>;</span><br><span class="line">MPU_SDA_IN();  <span class="comment">//SDA设置为输入  </span></span><br><span class="line">MPU_IIC_SDA=<span class="number">1</span>;MPU_IIC_Delay();</span><br><span class="line">MPU_IIC_SCL=<span class="number">1</span>;MPU_IIC_Delay();</span><br><span class="line"><span class="keyword">while</span>(MPU_READ_SDA)</span><br><span class="line">&#123;</span><br><span class="line">ucErrTime++;</span><br><span class="line"><span class="keyword">if</span>(ucErrTime&gt;<span class="number">250</span>)</span><br><span class="line">&#123;</span><br><span class="line">MPU_IIC_Stop();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MPU_IIC_SCL=<span class="number">0</span>;<span class="comment">//时钟输出0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">函数名称：MPU_IIC_Ack</span></span><br><span class="line"><span class="comment">函数功能：MPU IIC产生应答信号</span></span><br><span class="line"><span class="comment">函数参数：无</span></span><br><span class="line"><span class="comment">函数返回值：无</span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MPU_IIC_Ack</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MPU_IIC_SCL=<span class="number">0</span>;</span><br><span class="line">MPU_SDA_OUT();</span><br><span class="line">MPU_IIC_SDA=<span class="number">0</span>;</span><br><span class="line">MPU_IIC_Delay();</span><br><span class="line">MPU_IIC_SCL=<span class="number">1</span>;</span><br><span class="line">MPU_IIC_Delay();</span><br><span class="line">MPU_IIC_SCL=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">函数名称：MPU_IIC_NAck</span></span><br><span class="line"><span class="comment">函数功能：MPU IIC不产生应答信号</span></span><br><span class="line"><span class="comment">函数参数：无</span></span><br><span class="line"><span class="comment">函数返回值：无</span></span><br><span class="line"><span class="comment">**********************************************/</span>   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MPU_IIC_NAck</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MPU_IIC_SCL=<span class="number">0</span>;</span><br><span class="line">MPU_SDA_OUT();</span><br><span class="line">MPU_IIC_SDA=<span class="number">1</span>;</span><br><span class="line">MPU_IIC_Delay();</span><br><span class="line">MPU_IIC_SCL=<span class="number">1</span>;</span><br><span class="line">MPU_IIC_Delay();</span><br><span class="line">MPU_IIC_SCL=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">函数名称：MPU_IIC_Send_Byte</span></span><br><span class="line"><span class="comment">函数功能：MPU IIC发送一个字节</span></span><br><span class="line"><span class="comment">函数参数：txd：要发送的数据</span></span><br><span class="line"><span class="comment">函数返回值：无</span></span><br><span class="line"><span class="comment">注意：IIC发送字节是一个一个位发送的，发送一个字节需要发送八次</span></span><br><span class="line"><span class="comment">**********************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MPU_IIC_Send_Byte</span><span class="params">(u8 txd)</span></span></span><br><span class="line"><span class="function"></span>&#123;                        </span><br><span class="line">    u8 t;   </span><br><span class="line">MPU_SDA_OUT();     </span><br><span class="line">    MPU_IIC_SCL=<span class="number">0</span>;<span class="comment">//拉低时钟开始数据传输</span></span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;<span class="number">8</span>;t++)</span><br><span class="line">    &#123;              </span><br><span class="line">        MPU_IIC_SDA=(txd&amp;<span class="number">0x80</span>)&gt;&gt;<span class="number">7</span>;</span><br><span class="line">        txd&lt;&lt;=<span class="number">1</span>;   </span><br><span class="line">    MPU_IIC_SCL=<span class="number">1</span>;</span><br><span class="line">    MPU_IIC_Delay(); </span><br><span class="line">    MPU_IIC_SCL=<span class="number">0</span>;</span><br><span class="line">    MPU_IIC_Delay();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">函数名称：MPU_IIC_Read_Byte</span></span><br><span class="line"><span class="comment">函数功能：MPU IIC读取一个字节</span></span><br><span class="line"><span class="comment">函数参数：ack: 1,发送ACK   0,发送NACK </span></span><br><span class="line"><span class="comment">函数返回值：接收到的数据</span></span><br><span class="line"><span class="comment">注意：IIC读取字节是一个一个位读取的，读取一个字节需要读取八次</span></span><br><span class="line"><span class="comment">**********************************************/</span> </span><br><span class="line"><span class="function">u8 <span class="title">MPU_IIC_Read_Byte</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> ack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> i,receive=<span class="number">0</span>;</span><br><span class="line">  MPU_SDA_IN();              <span class="comment">//SDA设置为输入</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">        MPU_IIC_SCL=<span class="number">0</span>;</span><br><span class="line">        MPU_IIC_Delay();</span><br><span class="line">MPU_IIC_SCL=<span class="number">1</span>;</span><br><span class="line">        receive&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(MPU_READ_SDA)receive++;   <span class="comment">//如果读到了数据</span></span><br><span class="line">MPU_IIC_Delay(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (!ack)</span><br><span class="line">        MPU_IIC_NAck();   <span class="comment">//发送nACK</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        MPU_IIC_Ack();    <span class="comment">//发送ACK   </span></span><br><span class="line">    <span class="keyword">return</span> receive;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177</span></span><br></pre></td></tr></table></figure><p>还有一些函数就不做过多赘述了，上面的代码备注已经做好了，认真吃肯定是会吃透的。多下点功夫肯定可以看懂。</p><h1>6.学习补充</h1><p><strong>补充1：FIFO</strong><br><strong>FIFO</strong>( First Input First Output)简单说就是指先进先出。由于微电子技术的飞速发展，新一代FIFO芯片容量越来越大，体积越来越小，价格越来越便宜。作为一种新型大规模集成电路，FIFO芯片以其灵活、方便、高效的特性，逐渐在高速数据采集、高速数据处理、高速数据传输以及多机处理系统中得到越来越广泛的应用。在系统设计中，以增加数据传输率、处理大量数据流、匹配具有不同传输率的系统为目的而广泛使用FIFO存储器，从而提高了系统性能。FIFO存储器是一个<strong>先入先出的双口缓冲器</strong>，即第一个进入其内的数据第一个被移出，其中一个是存储器的输入口，另一个口是存储器的输出口。对于单片FIFO来说，主要有两种结构：触发导向结构和零导向传输结构。触发导向传输结构的FIFO是由寄存器阵列构成的，零导向传输结构的FIFO是由具有读和写地址指针的双口RAM构成。详见这篇博客：<a href="https://blog.csdn.net/qq_26652069/article/details/90765269">FIFO工作原理</a><br><strong>补充2：关于PA15使用问题</strong><br>在使用PA15作为普通IO口的时候，需要禁用JTAG才可以，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);<span class="comment">//使能AFIO时钟</span></span><br><span class="line">GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE);<span class="comment">//禁止JTAG,从而PA15可以做普通IO使用,否则PA15不能做普通IO!!!</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><p><strong>这是个大坑</strong><br><strong>补充3：关于MPU6050参考点</strong><br>当代码烧入后，MPU的参考点是什么呢？参考点其实就是MPU6050初始化之后一开始的位置，没有一个强制的规定哪一个方向就是基准点，<strong>初始化之后的初始位置就是(0，0，0)点</strong>。<br><strong>补充4：想到了再写吧</strong></p><h1>7.效果展示(可以先来看这个)</h1><p><img src="https://img-blog.csdnimg.cn/20210527174024629.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpaGFvdGlhbjExMQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"><br>PITCH(俯仰角)、ROLL(翻滚角)、YAW(偏航角)，单位均为 度。TEMP为当前温度，单位为摄氏度。</p><h1>8.参考链接</h1><p>[1]<a href="https://baike.baidu.com/item/%E9%99%80%E8%9E%BA%E4%BB%AA/84317?fr=aladdin">百度百科 陀螺仪</a><br>[2]<a href="http://www.openedv.com/docs/index.html">正点原子资料下载中心</a><br>[3]<a href="https://baike.baidu.com/item/FIFO%E5%AD%98%E5%82%A8%E5%99%A8/4530258?fr=aladdin">百度百科 FIFO储存器</a><br>[4]<a href="https://www.jianshu.com/p/1e38ad3d4bfb">姿态角Pitch、Roll、Yaw角介绍</a></p><h1>9.完整版代码链接</h1><p><a href="https://download.csdn.net/download/lihaotian111/19131254?spm=1001.2014.3001.5501">MPU6050模块通过OLED显示姿态角源码</a></p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css&quot;&gt;&lt;scrip</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>弱弱的说一声，我还活着</title>
    <link href="https://www.darkfox.top/posts/ffe6bb28/"/>
    <id>https://www.darkfox.top/posts/ffe6bb28/</id>
    <published>2021-07-19T02:48:31.000Z</published>
    <updated>2021-07-31T13:34:37.313Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center>  最近实在是太忙了，一直没时间写博客，今天终于可以摸一会鱼了（队友不在），写篇博客。 </center><span id="more"></span><h3 id="前言">前言</h3><p>没有更新的这几天我也没闲着，因为打电赛需要建模，机械部分才牢固，所以我就忙中偷闲学了一小下fusion360（截至今天学了两天），先展示一下这两天的成果吧。</p><h3 id="建模成果">建模成果</h3><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/%E4%B9%90%E9%AB%98" alt="乐高" loading="lazy"></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/%E7%8E%BB%E7%92%83%E7%93%B6" alt="酒瓶子" loading="lazy"></p><p>感觉还不错是吧，有内味了么？但是很明显，这两个模型的曲面很少，面数也少，也没有复杂的结构，所以哦还是要修炼一下的。</p><h3 id="电控">电控</h3><p>另外就是在不停的<strong>画板子，焊板子，画板子，焊板子</strong>。。。。。。</p><p>实验室买的那个焊锡丝，尼玛的，纯锡的（不含铅，含松香）再加上质量不好，要反复加热，这两天闻那个味道哦，妈的，上头。</p><p>就像尼玛的机油炒鸡蛋一样，我实在受不了了，于是去搞了个滤气面具。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/%E9%9D%A2%E5%85%B7" alt="面具" loading="lazy"></p><center>这个面具的基本原理就是活性炭吸附，对付焊锡的烟尘足够了,但是不能防其它的毒气哦！</center><p>下面几个破图就是我画的一部分的pcb</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/1" alt="中控板" loading="lazy"></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/2" alt="中控板pcb" loading="lazy"></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/image-20210719105914889.png" alt="一个简单的电源" loading="lazy"></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/image-20210719110000872.png" alt="电源的pcb预览" loading="lazy"></p><p>板子画了好多，由于现在开不能开源，电赛打完以后再补上。</p><p>画这几个破板子的时候，忘记考虑了好多事情，于是乎，又要重画，再打板，再焊接（习惯就好）</p><p>不说了，stn更新了，爷要去看视频了，拜拜</p><h3 id="补充">补充</h3><p>爷今天又搞了两个模型</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/%E8%9E%BA%E6%AF%8D" alt="无标题" loading="lazy"><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/paper%20clip%20v2.png" alt="paper clip v2" loading="lazy"></p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;center&gt;  最近实在是太忙了，一直没时间写博客，今天终于可以摸一会鱼了（队友不在），写篇博客。 &lt;/center&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>反省</title>
    <link href="https://www.darkfox.top/posts/3028d2b2/"/>
    <id>https://www.darkfox.top/posts/3028d2b2/</id>
    <published>2021-06-03T02:33:20.000Z</published>
    <updated>2021-09-06T06:09:19.248Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/KkhUIpj7YQaAWMi.jpg" alt="2" loading="lazy"></p><span id="more"></span><p>三分钟热度：浅尝则止<br>自我设限：自知之明<br>犹豫不决：懂得思考<br>拒绝学习：掌握时间分配<br>懒惰：不参与争论<br>整天吹牛不见行动：心怀梦想</p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">看看你占了几样。。。。。。。</summary>
    
    
    
    
  </entry>
  
</feed>
