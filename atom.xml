<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>冥狐的小站</title>
  
  <subtitle>如无必要，勿增实体</subtitle>
  <link href="https://www.darkfox.top/atom.xml" rel="self"/>
  
  <link href="https://www.darkfox.top/"/>
  <updated>2022-06-27T09:21:08.853Z</updated>
  <id>https://www.darkfox.top/</id>
  
  <author>
    <name>DarkFox</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于pscad软件的110kv系统故障仿真</title>
    <link href="https://www.darkfox.top/posts/3ad2927e/"/>
    <id>https://www.darkfox.top/posts/3ad2927e/</id>
    <published>2022-06-23T03:02:19.000Z</published>
    <updated>2022-06-27T09:21:08.853Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://fastly.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center>   </center><span id="more"></span><h1>基于PSCAD软件的110kV系统故障仿真</h1><p>本程序的仿真对象为110kV高压配电网，主要用于故障分析。本模型主要对B母线处A相接地故障进行仿真。</p><p>110kV配电网并不配置反应相间短路的过电流保护。因此，在继电保护用的故障电气量分析过程中，更侧重于接地故障时的零序电气量分析。利用本模型进行接地故障仿真时，可认为A相电流即是三倍零序电流。<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/image-20220622110045411.png" alt="image-20220622110045411" loading="lazy"></p><p>四个要求：</p><p>1、110kV配电网故障电气量分析示例</p><p>2、110kV系统仿真模型</p><p>3 、参数设置</p><p>4 、故障仿真结果</p><h2 id="开始操作">开始操作</h2><p>首先是获取软件，然后简单熟悉一下操作的步骤。<a href="https://zhuanlan.zhihu.com/p/30626835">教程</a>在此</p><p>接着是按照给的图例稍微搭建一下，由于示意图不能直接用，那么咱就稍微改一下，将电源改成三相，以及加入电流测量器。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/image-20220623104931575.png" alt="image-20220623104931575" loading="lazy"><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/image-20220623105009662.png" alt="image-20220623105009662" loading="lazy"></p><p>同样的阻抗也要改成三相的</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/image-20220623105148315.png" alt="image-20220623105148315" loading="lazy"><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/image-20220623105110326.png" alt="image-20220623105110326" loading="lazy"><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/image-20220623105135740.png" alt="image-20220623105135740" loading="lazy"></p><p>然后按照图例简单的搭建一下电路,以及设置一下参数.参数的设置为仿真的时间的设置以及短路时间的设置。另外为了方便观察,还要引入两个示波器。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/image-20220623105528048.png" alt="image-20220623105528048" loading="lazy"></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/image-20220623105641588.png" alt="image-20220623105641588" loading="lazy"></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/image-20220622111806205.png" alt="image-20220622111806205" loading="lazy"></p><p>接着就可以run了,得到如下A相接地短路图像，因为没有负载，所以只有短路的时候才有信号。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/image-20220622111920598.png" alt="image-20220622111920598" loading="lazy"><br>接着改一下短路类型,双击一下短路点就可以调参,改成三相相间短路（想改成其他的也可以自行操作）</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/image-20220623105800277.png" alt="image-20220623105800277" loading="lazy"></p><p>然后变成如下示意图,接着再run一下得到三相短路数据.</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/image-20220622111738325.png" alt="image-20220622111738325" loading="lazy"><br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20220622111629.png" alt="" loading="lazy"></p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">最近做课设闲的无聊，新实验室也是刚建好没网络，写篇文章打发一下时间</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>pcb名片</title>
    <link href="https://www.darkfox.top/posts/c5db6973/"/>
    <id>https://www.darkfox.top/posts/c5db6973/</id>
    <published>2022-05-29T13:37:40.000Z</published>
    <updated>2022-05-29T13:54:36.370Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://fastly.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>许久之前的小玩具了，想了想还是整理出来让大家乐呵乐呵（笑）<br>先放上来<a href="https://github.com/godmid/pcb_idcard.git">仓库开源地址</a></p><h1>原理图</h1><p>原理吧，其实很简单，现在的无线充电器或者手机的nfc等都是利用线圈电磁感应（共振）。所以我们在pcb板子上画个线圈也可以产生电磁感应，获得一定量的能量（点个灯是足够了）。顺便一提，磁场必须是变化磁场才能有这个现象，因而线圈里面通的是交流电。你可以把线圈想象成为一个快速变化极性的电池，因而两个灯是交替变化的，但是实际上这个极性变化速度极快，人的肉眼是分辨不出来的，所以看上去灯是一直亮的。</p><p><img src="https://user-images.githubusercontent.com/36893724/157664892-a7bf1b1a-56fc-4a23-9329-32f6f5bd838d.png" alt="Snipaste_2022-03-10_20-42-18" loading="lazy"></p><h1>渲染图</h1><p>板子的话，就随便画了画，毕竟只是画着玩，你可以加入任意的图案和设计，甚至还能镀金（得加钱）。</p><p><img src="https://user-images.githubusercontent.com/36893724/157664911-44dd87ca-0cd6-46ce-aeea-2df059064b5c.png" alt="Snipaste_2022-03-10_20-42-09" loading="lazy"></p><p><img src="https://user-images.githubusercontent.com/36893724/157664916-cbdf59aa-77a2-4a9f-bf15-c6283ed59cbd.png" alt="Snipaste_2022-03-10_20-42-00" loading="lazy"></p><h1>实际效果图</h1><p>手机比较渣，就不发亮灯的图了；</p><p><img src="https://user-images.githubusercontent.com/36893724/159691322-4837931c-7a5e-4af5-bad6-28b7bfba96e3.jpg" alt="1648035553756 jpg" loading="lazy"></p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">之前闲的无聊，自己就想着设计个名片，正好jlc有活动就画了个pcb名片发个</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>公告</title>
    <link href="https://www.darkfox.top/posts/43ee71e3/"/>
    <id>https://www.darkfox.top/posts/43ee71e3/</id>
    <published>2022-04-21T01:30:28.000Z</published>
    <updated>2022-06-02T01:10:13.018Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://fastly.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center>  </center><span id="more"></span><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">最近cdn加速挂了，所以一些js挂掉了，等有时间了我会修复的，最近忙于准备夏令营的事项，有时间一定去修复！</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>STM32</title>
    <link href="https://www.darkfox.top/posts/b900f0d0/"/>
    <id>https://www.darkfox.top/posts/b900f0d0/</id>
    <published>2022-03-20T05:53:50.000Z</published>
    <updated>2022-06-23T03:28:50.624Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://fastly.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center>   </center><span id="more"></span><h1>stm32的启动模式</h1><p>STM32三种启动模式对应的存储介质均是芯片内置的，它们分别是：<br><strong>1）用户闪存 = 芯片内置的Flash。</strong><br><strong>2）SRAM = 芯片内置的RAM区，就是内存啦。</strong><br><strong>3）系统存储器 = 芯片内部一块特定的区域，芯片出厂时在这个区域预置了一段Bootloader，就是通常说的ISP程序。这个区域的内容在芯片出厂后没有人能够修改或擦除，即它是一个ROM区。</strong></p><p>在每个STM32的芯片上都有两个管脚BOOT0和BOOT1，这两个管脚在芯片复位时的电平状态决定了芯片复位后从哪个区域开始执行程序，见下表：<img src="https://img-blog.csdnimg.cn/20200317092226217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTA3NzQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br><strong>1、Main Flash memory</strong><br>是STM32内置的Flash，一般我们使用JTAG或者SWD模式下载程序时，就是下载到这个里面，重启后也直接从这启动程序。</p><p><strong>2、System memory</strong><br>从系统存储器启动，这种模式启动的程序功能是由厂家设置的。一般来说，我们选用这种启动模式时，是为了从串口下载程序，因为在厂家提供的BootLoader中，提供了串口下载程序的固件，可以通过这个BootLoader将程序下载到系统的Flash中。<strong>但是这个下载方式需要以下步骤：</strong></p><p>Step1:将BOOT0设置为1，BOOT1设置为0，然后按下复位键，这样才能从系统存储器启动BootLoader<br>Step2:最后在BootLoader的帮助下，通过串口下载程序到Flash<br>Step3:程序下载完成后，又有需要将BOOT0设置为GND，手动复位，这样，STM32才可以从Flash中启动</p><p><strong>可以看到，利用串口下载程序还是比较的麻烦，需要跳帽跳来跳去的，非常的不注重用户体验。</strong></p><p><strong>3、Embedded Memory</strong><br>内置SRAM，既然是SRAM，自然也就没有程序存储的能力了，这个模式一般用于程序调试。假如我只修改了代码中一个小小的地方，然后就需要重新擦除整个Flash，比较的费时，可以考虑从这个模式启动代码（也就是STM32的内存中），用于快速的程序调试，等程序调试完成后，再将程序下载到Flash中。</p><p>要注意的是，一般不使用内置SRAM启动(BOOT1=1，BOOT0=1)，因为SRAM掉电后数据就丢失。多数情况下SRAM只是在调试时使用，也可以做其他一些用途。如做故障的局部诊断，写一段小程序加载到SRAM中诊断板上的其他电路，或用此方法读写板上的Flash或EEPROM等。还可以通过这种方法解除内部Flash的读写保护，当然解除读写保护的同时Flash的内容也被自动清除，以防止恶意的软件拷贝。</p><p>一般BOOT0和BOOT1跳线都跳到0(地)</p><p><strong>顺便说一下STM32 启动过程：</strong></p><p>STM32的内部闪存（flash）地址起始于0x08000000,一般情况下，程序文件就从地址开始写入，此外STM32是基于Cortex-M3内核的微控制器，其内部通过一张中断向量表来响应。程序启动后，首先从&quot;中断向量表&quot;取出复位中断向量执行复位中断程序完成启动，而这张&quot;中断向量表&quot;的起始地址是0x8000004,当中断来临，STM32的内部硬件机制会自动将PC指针定位到中断向量表处，并根据中断源取出对应的中断向量执行中断服务程序。</p><p>在图53.1.1,STM32 在复位后，先从0x08000004地址取出复位中断向量的地址，并跳转到复位中断服务程序，如标号①所示，在复位中断执行完后，会跳转到我们的Main函数，如标号②所示，而我们的main一般都是一个死循环，在main函数执行过程中，如果收到中断请求，此时STM32强制将PC指针指回中断向量表处，如标号③所示，然后，根据中断源进入相应的中断服务程序，如标号④所示，在执行完中断服务以后，程序再次返回main函数执行，如标号5⑤所示<br><img src="https://img-blog.csdnimg.cn/20200317093403541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTA3NzQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy">正点原子STM32 ISP下载一般步骤和程序执行步骤<br><img src="https://img-blog.csdnimg.cn/20200320103959316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTA3NzQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p>但是由于下载电路采用一键下载方案，如下图所示，所以我们只需要在刚开始的时候就设置BOOT0/BOOT1都为0即可，后面不需要再修改了<br><img src="https://img-blog.csdnimg.cn/20200320103941759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTA3NzQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><h1>8种IO口模式</h1><p>输入模式</p><p>-输入浮空（GPIO_Mode_IN_FLOATING）  -输入上拉(GPIO_Mode_IPU)</p><p>-输入下拉(GPIO_Mode_IPD)  -模拟输入(GPIO_Mode_AIN)</p><p>输出模式</p><p>-开漏输出(GPIO_Mode_Out_OD)  -开漏复用功能(GPIO_Mode_AF_OD)</p><p>-推挽式输出(GPIO_Mode_Out_PP)  -推挽式复用功能(GPIO_Mode_AF_PP)</p><table><thead><tr><th>4种输入模式</th><th>4种输出模式 （带上拉或者下拉）</th></tr></thead><tbody><tr><td>浮空输入</td><td>推挽输出</td></tr><tr><td>上拉输入</td><td>复用式推挽输出</td></tr><tr><td>下拉输入</td><td>开漏输出</td></tr><tr><td>模拟输入</td><td>复用式开漏输出</td></tr></tbody></table><h2 id="1-浮空输入">1、浮空输入</h2><p><img src="https://img-blog.csdnimg.cn/20210122101349507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Njk5MTk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>浮空输入模式下，I/O端口的电平信号直接进入输入数据寄存器。MCU直接读取I/O口电平，I/O的电平状态是不确定的，完全由外部输入决定；如果在该引脚悬空（在无信号输入)的情况下，读取该端口的电平是不确定的，一般多用于外部按键输入。</p><h2 id="2-上拉输入">2、上拉输入</h2><p><img src="https://img-blog.csdnimg.cn/20210122103213234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Njk5MTk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>IO内部接上拉电阻，此时如果IO口外部没有信号输入或者引脚悬空，IO口默认为高电平 如果I/O口输入低电平，那么引脚就为低电平，MCU读取到的就是低电平</p><h2 id="3-下拉输入">3、下拉输入</h2><p><img src="https://img-blog.csdnimg.cn/20210122104235652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Njk5MTk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>IO内部接下拉电阻，此时如果IO口外部没有信号输入或者引脚悬空，IO口默认为低电平 如果I/O口输入高电平，那么引脚就为高电平，MCU读取到的就是高电平</p><h2 id="4-模拟输入">4、模拟输入</h2><p><img src="https://img-blog.csdnimg.cn/20210122104502194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Njk5MTk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p>将引脚设置为stm32内部的adc的模拟信号的输入，需要带adc的io口才能设置。</p><h2 id="5-开漏输出">5、开漏输出</h2><p><img src="https://img-blog.csdnimg.cn/20210122110839250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Njk5MTk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>输出端相当于三极管的集电极，要得到高电平状态需要上拉电阻才行，适合于做电流型的驱动，其吸收电流的能力相对强（一般20mA以内）</p><p>IO输出0接GND，IO输出1，悬空，需要外接上拉电阻，才能实现输出高电平。当输出为1时，IO口的状态由上拉电阻拉高电平</p><h2 id="6-推挽输出">6、推挽输出</h2><p><img src="https://img-blog.csdnimg.cn/20210122112911788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Njk5MTk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>在推挽输出模式时，N-MOS管和P-MOS管都工作，如果我们控制输出为0，低电平，则P-MOS管关闭，N-MOS管导通，使输出低电平，I/O端口的电平就是低电平，若控制输出为1 高电平，则P-MOS管导通N-MOS管关闭，使输出高电平，I/O端口的电平就是高电平， 外部上拉和下拉的作用是控制在没有输出时IO口电平</p><p>此时施密特触发器是打开的，即输入可用，通过输入数据寄存器GPIOx_IDR可读取I/O的实际状态。I/O口的电平一定是输出的电平<br>推</p><p>挽输出输出0-接GND， IO输出1 -接VCC，读输入是未知的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">                  推挽输出和开漏输出的区别</span><br><span class="line">1</span><br></pre></td></tr></table></figure><table><thead><tr><th>推挽输出</th><th>开漏输出</th></tr></thead><tbody><tr><td>可以输出强高低电平，连接数字器件</td><td>可以输出强低电平，高电平得靠外部电阻拉高。输出端相当于三极管的集电极. 需要外接上拉电阻，才能实现输出高电平 合于做电流型的驱动，其吸收电流的能力相对强(一般20ma以内)；在使用任何一种开漏模式时，都需要接上拉电阻，否则只能输出低电平</td></tr><tr><td>推挽输出电路： 其中IN端输出高电平时下面的PNP三极管截止，而上面NPN三极管导通，输出电平VS+；当IN端输出低电平时则恰恰相反，PNP三极管导通，输出和地相连，为低电平</td><td>开漏输出电路：IN端输出低电平时，三极管导通，使输出接地，IN端输出高电平时，三极管截止，所以引脚既不输出高电平，也不输出低电平，为高阻态。为正常使用时必须接上拉电阻</td></tr></tbody></table><p>在STM32的应用中，除了必须用开漏模式的场合，我们都习惯使用推挽输出模式。</p><h2 id="7-开漏复用输出">7、开漏复用输出</h2><p><img src="https://img-blog.csdnimg.cn/20210122115229776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Njk5MTk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>输出的高低电平的来源于其它外设，施密特触发器打开，输入可用，通过输入数据寄存器可获取I/O实际状态 除了输出信号的来源改变 其他与开漏输出功能相同<br>可以理解为GPIO口被用作第二功能时的配置情况（即并非作为通用IO口使用）</p><h2 id="8-推挽复用输出">8、推挽复用输出</h2><p><img src="https://img-blog.csdnimg.cn/20210122115612445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Njk5MTk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>可以理解为GPIO口被用作第二功能时的配置情况（即并非作为通用IO口使用）</p><h2 id="f4系列与f1系列区别">F4系列与F1系列区别:</h2><p>本质上的区别是F4系列采用了Cortex-M4内核 ，而F1系列采用Cortex-M3内核<br>F1系列(M3)IO口基本结构：<br><img src="https://img-blog.csdnimg.cn/20210122120344564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Njk5MTk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>F4系列(M4)IO口基本结构：<br><img src="https://img-blog.csdnimg.cn/20210122120412955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Njk5MTk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>F4系列设计的更加高级与人性化，他将外部上下拉电阻转移到了输出/输入驱动器外部，使得输出模式下也可以实现内部上拉与下拉，方便了用户的使用，增加了灵活性。</p><h2 id="引脚模式的配置方式如下：">引脚模式的配置方式如下：</h2><p>1、作为普通GPIO输入：根据需要配置该引脚为浮空输入、带弱上拉输入或带弱下拉输入，同时不要使能该引脚对应的所有复用功能模块。<br>2、作为普通GPIO输出：根据需要配置该引脚为推挽输出或开漏输出，同时不要使能该引脚对应的所有复用功能模块。<br>3、作为普通模拟输入：配置该引脚为模拟输入模式，同时不要使能该引脚对应的所有复用功能模块。<br>4、作为内置外设的输入：根据需要配置该引脚为浮空输入、带弱上拉输入或带弱下拉输入，同时使能该引脚对应的某个复用功能模块。<br>5、作为内置外设的输出：根据需要配置该引脚为复用推挽输出或复用开漏输出，同时使能该引脚对应的所有复用功能模块。</p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;center&gt;   &lt;/center&gt;</summary>
    
    
    
    
    <category term="stm32" scheme="https://www.darkfox.top/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>platformIO入门</title>
    <link href="https://www.darkfox.top/posts/85cfa8dc/"/>
    <id>https://www.darkfox.top/posts/85cfa8dc/</id>
    <published>2022-02-13T02:42:18.000Z</published>
    <updated>2022-06-23T03:30:47.584Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://fastly.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202202131045406.png" alt="" loading="lazy"></p><center> platformio ide 可以更快速的新建一个项目和配置环境，这次就来学习一下如何使用.  </center><span id="more"></span><h1>简介</h1><h2 id="platform">platform</h2><p>直译的话就是 <strong>平台</strong>，具体就是指的芯片平台，再详细一点那就是各个公司具体的系列芯片的开发平台了。目前为止 PIO针对支持的平台都有以下功能支撑：</p><ul><li>支持指定框架的基于脚本的编译构建系统</li><li>针对各公司常规开发板的预配置</li><li>提供多架构的构建工具及相关工具链的支持</li></ul><p>PIO 目前支持的平台分为嵌入式和桌面两大类。</p><h2 id="嵌入式平台">嵌入式平台</h2><ul><li><a href="https://docs.platformio.org/en/latest/platforms/aceinna_imu.html">Aceinna IMU</a></li><li><a href="https://docs.platformio.org/en/latest/platforms/atmelavr.html">Atmel AVR</a></li><li><a href="https://docs.platformio.org/en/latest/platforms/atmelsam.html">Atmel SAM</a></li><li><a href="https://docs.platformio.org/en/latest/platforms/espressif32.html">Espressif 32</a></li><li><a href="https://docs.platformio.org/en/latest/platforms/espressif8266.html">Espressif 8266</a></li><li><a href="https://docs.platformio.org/en/latest/platforms/freescalekinetis.html">Freescale Kinetis</a></li><li><a href="https://docs.platformio.org/en/latest/platforms/infineonxmc.html">Infineon XMC</a></li><li><a href="https://docs.platformio.org/en/latest/platforms/intel_arc32.html">Intel ARC32</a></li><li><a href="https://docs.platformio.org/en/latest/platforms/intel_mcs51.html">Intel MCS-51 (8051)</a></li><li><a href="https://docs.platformio.org/en/latest/platforms/kendryte210.html">Kendryte K210</a></li><li><a href="https://docs.platformio.org/en/latest/platforms/lattice_ice40.html">Lattice iCE40</a></li><li><a href="https://docs.platformio.org/en/latest/platforms/maxim32.html">Maxim 32</a></li><li><a href="https://docs.platformio.org/en/latest/platforms/microchippic32.html">Microchip PIC32</a></li><li><a href="https://docs.platformio.org/en/latest/platforms/nordicnrf51.html">Nordic nRF51</a></li><li><a href="https://docs.platformio.org/en/latest/platforms/nordicnrf52.html">Nordic nRF52</a></li><li><a href="https://docs.platformio.org/en/latest/platforms/nxplpc.html">NXP LPC</a></li><li><a href="https://docs.platformio.org/en/latest/platforms/riscv_gap.html">RISC-V GAP</a></li><li><a href="https://docs.platformio.org/en/latest/platforms/samsung_artik.html">Samsung ARTIK</a></li><li><a href="https://docs.platformio.org/en/latest/platforms/sifive.html">SiFive</a></li><li><a href="https://docs.platformio.org/en/latest/platforms/siliconlabsefm32.html">Silicon Labs EFM32</a></li><li><a href="https://docs.platformio.org/en/latest/platforms/ststm32.html">ST STM32</a></li><li><a href="https://docs.platformio.org/en/latest/platforms/ststm8.html">ST STM8</a></li><li><a href="https://docs.platformio.org/en/latest/platforms/teensy.html">Teensy</a></li><li><a href="https://docs.platformio.org/en/latest/platforms/timsp430.html">TI MSP430</a></li><li><a href="https://docs.platformio.org/en/latest/platforms/titiva.html">TI TIVA</a></li><li><a href="https://docs.platformio.org/en/latest/platforms/wiznet7500.html">WIZNet W7500</a></li></ul><h2 id="桌面平台">桌面平台</h2><ul><li><a href="https://docs.platformio.org/en/latest/platforms/native.html">Native</a></li><li><a href="https://docs.platformio.org/en/latest/platforms/linux_arm.html">Linux ARM</a></li><li><a href="https://docs.platformio.org/en/latest/platforms/linux_i686.html">Linux i686</a></li><li><a href="https://docs.platformio.org/en/latest/platforms/linux_x86_64.html">Linux x86_64</a></li><li><a href="https://docs.platformio.org/en/latest/platforms/windows_x86.html">Windows x86</a></li></ul><h1>Home 标签页</h1><p>进入Platformio 的主页显示的就是 Home 标签页，标签页内从上到下可以依次看到以下内容：</p><ul><li>Show at startup 的复选框，勾上后，每次启动 vs code 就会启动这个主页；</li><li>Quick Access 下有四个操作按钮，分别是：<ul><li>New Project：用于新建工程；</li><li>Import Arduino Project：用于导入电脑中已经存在的 Arduino 工程；</li><li>Open Project：用于打开已经存在的 Platformio 工程；</li><li>Project Examples：用于打开本机已经安装的单片机平台的例程工程；</li></ul></li><li>Recent News：显示最新 Platformio 信息；</li></ul><h3 id="project-标签页">project 标签页</h3><p>显示最近打开的工程</p><h3 id="inspect-标签页">Inspect 标签页</h3><p>用于检测项目，可以看到代码占用了多少RAM和Flash等信息，具体看<a href="https://docs.platformio.org/en/latest/home/index.html">文档介绍</a>.<br><img src="https://img-blog.csdnimg.cn/0d99caa854e249ebb6e0ade65758cdd8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCY57yY6YeM55qE6K6w5b-G,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy"></p><h3 id="libraries-标签页">Libraries 标签页</h3><p><img src="https://img-blog.csdnimg.cn/cbd61bfecc8f49a38113e3798b55379b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCY57yY6YeM55qE6K6w5b-G,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy">ibraries 标签页是管理库的接口，这里只简单说明一下，主要包含四个标签页：</p><ul><li><p>Registry 标签页 ：这个页面是有一个搜索框，搜索框内没有内容的时候，会在搜索框下面显示所有可用的库，搜索框中输入关键词就会过滤显示相关的库。<br>点击想要安装的库，就会进入这个库的详细页面，这个页面里有安装按钮、例程、使用方法等操作接口。</p></li><li><p>Installed 标签页：这里主要展示本机已经安装的第三方库。</p></li><li><p>Built-in 标签页：这里显示已安装平台内置的库。</p></li><li><p>Updates 标签页：展示需要更新的库。</p><p>新建项目的过程一搜一堆，就不描述了。</p><p><strong>当你新建项目工程以后将会自动产生以下文件夹：</strong></p></li><li><p><strong>.pio</strong>，存放工程编译产生的文件</p></li><li><p><strong>.vscode</strong>, 存放针对工程定制化的 vscode 配置文件</p></li><li><p><strong>include</strong>，存放统一管理的 h 头文件</p></li><li><p><strong>lib</strong>，存放自己编写的库文件</p></li><li><p><strong>src</strong>，存放工程项目的 C/C++ 源文件</p></li><li><p><strong>test</strong>，存放工程项目的测试文件，一般用不到</p></li><li><p><strong>.gitignore</strong>，git 仓库的忽略文件，方便 git 进行工程项目的版本控制</p></li><li><p><strong>travis.yml</strong>，持续集成的配置文件，一般用不到</p></li><li><p><strong>platformio.ini</strong>，项目的核心配置文件，这个会经常用到，所以得了解其中可用的配置项[<a href="https://zhuanlan.zhihu.com/p/78722930#ref_4">4]</a></p></li></ul><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202202131045406.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;center&gt; platformio ide 可以更快速的新建一个项目和配置环境，这次就来学习一下如何使用.  &lt;/center&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>SORT</title>
    <link href="https://www.darkfox.top/posts/67b11f96/"/>
    <id>https://www.darkfox.top/posts/67b11f96/</id>
    <published>2022-01-26T13:51:53.000Z</published>
    <updated>2022-03-20T06:13:06.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://fastly.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center>   </center><span id="more"></span><iframe   height=900 width=600 src="https://caspervonb.xyz/toneofsorting/" "   frameborder=0   allowfullscreen> </iframe><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">排序算法可视化</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>2021年终总结</title>
    <link href="https://www.darkfox.top/posts/a23e5172/"/>
    <id>https://www.darkfox.top/posts/a23e5172/</id>
    <published>2022-01-01T12:31:36.000Z</published>
    <updated>2022-06-23T03:29:27.343Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://fastly.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center>首先祝大家虎年快乐！</center><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/~T1Q%5B1G6CW%7BO%7B%7BS%5D4%24RIL~M.jpg" alt="虎年快乐" loading="lazy"></p><span id="more"></span><center>建议配合BGM食用</center><div align=life> <iframe frameborder="0" marginwidth="0" marginheight="0" width=300 height=86 src="https://music.163.com/outchain/player?type=2&id=506139194&auto=1&height=66"></iframe></div><p><s>真是愉快的一年呢！</s><br><strong>真是多灾多难的一年</strong>！</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201021334281.png" alt="2022" loading="lazy"></p><h3 id="2021是精神和身体的双重折磨">2021是精神和身体的双重折磨</h3><p>首先，在2021年初，得知了UP主<strong>墨茶</strong>的悲痛经历和逝世的不幸消息，值此之际，缅怀我们的这位朋友。希望他在那有数不清的草莓可以吃，希望听闻他的事迹的朋友可以更加的珍惜你的生活，珍惜你身边的朋友！</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201021335392.png" alt="" loading="lazy"></p><p>2021最为突出的特色是什么呢？没错，是™的<strong>疫情</strong>。这杀千刀的疫情摧毁了我们的日常生活，也使我的精气神变得很脆弱。每天都是某某因为疫情不得不关门失业，某某某地方爆发了巴拉巴拉，家里又没有吃的了巴拉巴拉……希望这该死的疫情在2022也不要再出现了。现在一想到在家里上网课的那段操蛋经历我就浑身难受。</p><p>至于身体上的折磨，说来话长。我还记得即将开学，即将分别的前夕，我和家里的同学朋友吃了一顿美滋滋的火锅。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201021349615.png" alt="" loading="lazy"></p><p>很诱人是吧，但是最后的离别时刻，为了检验友情，和朋友一人喝了一杯火锅汤，以表示哥们的友情<s>坚</s>（keng）<s>固</s>（die）无比。<br>像我这种关心室友的热心人士，肯定也会带点小特产回去。于是乎，我就买了一百多块钱的武汉九九辣鸭，足足三斤多。但是到了学校才发现我的室友呀，要过两天才报道……于是乎，本着节约粮食的原则，防止我的鸭子在这潮湿、温热的南方发酵，我做出了一个违背<s>原则</s>的决定——我给他吃了。<br>然后报道后，副作用就开始慢慢发酵了。</p><hr><ul><li><p>第一天，些许不适感，尚可上课</p></li><li><p>第二天，些许不适感，上课坐着很难受，肚子有灼烧感</p></li><li><p>第三天，上你🐎的课，去医院！</p></li></ul><hr><p>然后就是钱包流血暴击三连击，挂号-检查-付医药费</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201021401265.png" alt="" loading="lazy"></p><p>再接着就是血肉暴击三连击，挂号-住院-做手术。人生的第一次的手术竟然是因为尼玛的辣鸭……<br>然后就是长达两个月的恢复期……终于半血复活后返校。结果有几门课已经结课了（QWQ），只能拖着半血的身体开始冲刺（真的是半血，有时候一觉睡醒床上有一滩血）。好在那几门结课的课程补上了。从此以后，身上多了一个消除不了的伤疤，以及伴随终身的伤痛（再也不作死了）。</p><p>后来在吃鱼的时候还卡了一根刺，又做了一次小手术，就不提了（为何我这么倒霉）。其实吧，经历过这一次挫折我也学习到了很多。比如更加的珍惜足下的生活，也更能理解那些行动不方便的人士，这些也许不亲身经历一下很难理解。然后我发现了一个很操蛋的精神治疗方法，当你遇到不幸或者生活里有过不去的坎时，就去肛肠科或者儿科去坐一天。然后你会发现生活里也没有过不去的坎，大不了从头再来。</p><p>还有就是，多给这个世界一份温暖，这个世界也会多留给你一份温暖。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201021454584.png" alt="" loading="lazy"></p><h3 id="安全">安全</h3><p>2021，强调最多的事情就是<strong>安全</strong>，<strong>安全</strong>，还是<strong>安全</strong>！不管是疫情还是其他的，各位做实验的时候一定要<strong>注意安全</strong>。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201051558265.png" alt="" loading="lazy"></p><p>今年材料大楼就有几位同学不幸出了事故，诸君，一定要<strong>注意安全</strong>!</p><h3 id="2021电子设计大赛">2021电子设计大赛</h3><p>今年最有纪念意义的估计也就这个比赛了。现在看到当初为了比赛画的板子还是想笑，没想到到了大学,中二病还是存在于心中。被<s>附魔</s>的PCB板子。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201021507568.png" alt="" loading="lazy"></p><p>以及准备比赛花很多money搞来的器件。</p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201021509150.png" style="zoom:67%;" / loading="lazy"><p>好在虽然有很多的挫折和困难，但是我们都克服了，最后也取得了一个满意的结果，我们队伍拿了个国家一等奖。细节就不谈了，三天三夜也谈不完，还是回去留在酒桌上吹牛用吧。但是有个小插曲挺有意思的还是和你们分享一下，在集训调车的时候，为了让车走直线，方便调整PID参数。我们想了很多办法，最后是这么解决这个鬼问题的（笑）</p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201021514407.png" style="zoom:67%;" / loading="lazy"><p>最后圆满结束，和队友吃了最后一顿赛饭。非常感谢我这两位沙雕队友的技术支持和<s>无限的拌嘴</s>（bushi）</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201021523892.png" alt="" loading="lazy"></p><h3 id="小玩具">小玩具</h3><p>在这一年里也捣鼓了很多小玩具，不说了，上图</p><h4 id="激光雕刻机">激光雕刻机</h4><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201021517650.png" alt="" loading="lazy"></p><center>激光雕刻机</center><p>这个小东西是我的激光雕刻机2代，一代原型机很寒掺，并且被实验室弄丢了。好在当DIY原型机时在b站留存了视频。</p><iframe id="b" class="b video_pc" src="//player.bilibili.com/player.html?aid=98402834&bvid=BV1DE411F78X&cid=167982886&page=1" frameborder="0"framespacing="0"allowfullscreen="true"style="position: middle;width="100%" height="600" controls="controls" autoplay="autoplay"quality="high"></video>></iframe><iframe id="b" class="b video_pc" src="//player.bilibili.com/player.html?aid=370054886&bvid=BV1bZ4y1j76W&cid=170040000&page=1" frameborder="0"framespacing="0"allowfullscreen="true"style="position: middle;width="100%" height="600" controls="controls" autoplay="autoplay"quality="high"></video>></iframe>另外中间闲的我聊我还造了一个小沙雕，不过这都是2020年的事情了,时间过得真快，转眼两年了。<iframe src="//player.bilibili.com/player.html?aid=99366316&bvid=BV1j7411C7s6&cid=169615775&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="600" > </iframe><h4 id="雕刻机">雕刻机</h4><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201021518592.png" alt="" loading="lazy"></p><center>步进电机控制器</center><p>这个东西就没啥稀奇的了，市面上有很多，也没啥技术含量。就是一个简单的把引脚引出来然后连接a4988驱动（其他的也可），带动42步进电机用的一个小的转换的板子。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201021519216.png" alt="" loading="lazy"></p><center>三轴雕刻机框架</center><p>年初的时候因为没有设计过机械装置，所以买了个这个小垃圾。这个小垃圾结构也蛮好的，只是用料不太讲究。首先铝板要换成其他的钣金件，因为硬度（我也不知道专业说法叫啥）不够，容易变形，致使精度变低。其次同步轴和限位要更换成更新的，原来这个已经不能用了。然后最主要的部分，步进电机要更换，这三个步进电机扭矩太小，没什么用，带不了太大的负载。最后，要加个主轴才能变成雕刻机，现在的状态只是个激光雕刻机（笑）。奈何没钱继续了，2022希望能够搞定他。</p><h4 id="3d打印机">3D打印机</h4><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201021520315.png" alt="" loading="lazy"></p><center>3D打印机</center><center>这一年，我有了自己的3D打印机</center><p>这一年，确实有了自己的3D打印机，虽然进程只有10、10、10。但是也确确实实有了自己的一个3D打印机。一个好的极客怎么能没有自己的3D打印机呢。这个打印机参照的小树官方的资料，使用了单臂的结构，佩带有热床和pei板（照片忘拍了）。控制板使用了开源的MKS（虽然感觉是抄的别人的方案），固件刷的小树的汉化好的固件，一切都算是顺利。这个鬼东西主要是调平的时候很麻烦，只能一点一点手动调（因为没加钱）。最后做出来感觉精度还可以，打印个小东西还是蛮好的，也挺方便的。</p><h4 id="身份卡">身份卡</h4><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201021521923.png" alt="" loading="lazy"></p><center>特质身份卡</center><p>做这个鬼东西的时候，鬼知道我想的是啥。首先呢，这确确实实是一张cpu卡，只是把外圈的线圈剪去了。然后泡在有机溶剂里面方便取出来里面的芯片。但是奈何后来没有芯片的资料，最后也就不了了之了。2022年我打算重新再搞一次，争取这次一次成功！</p><h4 id="暗影之眼">暗影之眼</h4><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201021522894.png" alt="" loading="lazy"></p><center>BlackEyes</center><p>这个黑科技最初是在彩虹六号上看到的，之后在b站发现了竟然有人做这个鬼东西。我试着做了一个，但是没买到合适的塑料罩，最后不了了之了。现在放在哪了也忘了QWQ，2022年再复刻一个更好的！</p><h4 id="牛顿环">牛顿环</h4><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201021526652.png" style="zoom:67%;" / loading="lazy"><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201021526717.png" style="zoom:67%;" / loading="lazy"><center>没错，就是牛顿环，使用光学仪器观察到了（笑）</center><h4 id="捡垃圾">捡垃圾</h4><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201021527590.png" style="zoom:67%;" / loading="lazy"><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201021527265.png" alt="" loading="lazy"></p><p>今年确确实实捡了不少垃圾，但是奈何翻车次数太多了。所以好多垃圾最后真的成了垃圾。像这个年代久远缺少资料的小垃圾cd机，实在是修不好了（没有资料，很难修好）。不得不成了垃圾，哎。</p><h3 id="日常">日常</h3><center>我的日常，大多数时候是这个状态</center><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201051540921.png" alt="" loading="lazy"></p><p>没错，坐在椅子上，打开手机、电脑，然后愣住。。。。。。</p><p>还是聊一下日常生活的小插曲吧，还是这些有意思。</p><h4 id="校宠">校宠</h4><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201051549529.png" alt="" loading="lazy"></p><center>大橘和大黄的小窝</center><p>每天从图书馆路过看到这两个小可爱真的可以消散一天的负面debuff。关键是，<strong>他们让我撸</strong>！！！！</p><h4 id="美食">美食</h4><center>俗话说，唯有生活与美食不可辜负！</center><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201051553038.png" alt="" loading="lazy"></p><center>猪又炖粉条，yyds</center><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201051558245.png" alt="" loading="lazy"></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201051557434.png" alt="" loading="lazy"></p><center>火锅，永远的经典，不知道吃啥，来顿火锅吧</center><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201051602642.png" alt="" loading="lazy"></p><center>又成长了一岁</center><h4 id="美景">美景</h4><center>首先是无意中抓拍到的一幕（😀）</center><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201051605151.png" style="zoom:67%;" / loading="lazy"><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201051605782.png" style="zoom:67%;" / loading="lazy"><center>5.1期间拍到的花</center><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201051606670.png" alt="" loading="lazy"></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201051607744.png" alt="" loading="lazy"></p><center>返校后拍的老城区</center><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/pic/1641100995579.jpg.jpg" alt="" loading="lazy"></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/pic/1641101020261.jpg.jpg" alt="" loading="lazy"></p><h4 id="防诈骗">防诈骗</h4><p>说到这个就有意思了，起因是一哥们给我发了个二维码链接。点进去明显是个钓鱼的鬼佬网站，并且查询了几轮后发现是个空壳。里面真的是p都没有。。。。</p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201051611740.png" style="zoom:67%;" / loading="lazy"><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201051612136.png" style="zoom:50%;" / loading="lazy"><p>再点进去的话，就是传统的套路了，并且是全自动的话术套路，全都是机器人哦。</p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201051613898.png" style="zoom:67%;" / loading="lazy"><p>到最后也没啥，提醒了一下那个哥们后，顺手举报一波后就结束了。</p><p>先写到这，有时间再续。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202201051616819.png" alt="" loading="lazy"></p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">又到了一年一度的总结时间了！</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>来做一道钓鱼题目吧</title>
    <link href="https://www.darkfox.top/posts/6fce119e/"/>
    <id>https://www.darkfox.top/posts/6fce119e/</id>
    <published>2021-12-08T04:50:05.000Z</published>
    <updated>2022-03-20T06:04:18.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://fastly.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202112081252886.png" alt="" loading="lazy"></p><span id="more"></span><p>这个题目有一个限制，就是只能用初等几何来做，那些想用三角函数什么的来硬算出来的，请收起你的想法！</p><p>一开始我还以为加个辅助线什么的就可以做了，如下图所示，但是我算了一下发现不是这么回事。</p><p>按照这个思路来算的话总是会回归到一个等式a+b=b+a</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202112081255018.png" alt="" loading="lazy"></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202112081256398.png" alt="" loading="lazy"></p><p>不相信的话，你大可一试，至此，思路中断，然后我开始去各大平台寻找一些答案的解析和步骤思路什么的。还真找到了题解</p><p><a href="https://zhuanlan.zhihu.com/p/375054931">知乎的题解</a> <a href="https://www.youtube.com/watch?v=HQc-54hQ8kw">油管的题解</a></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202112081301795.png" alt="" loading="lazy"></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202112081302693.png" alt="" loading="lazy"></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202112081302794.png" alt="" loading="lazy"></p><p>现在回头看这道鬼题真是坑。。。。。。。</p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">他真的是个小学题！！！</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>2021全国电赛（F题）图像识别__数字识别</title>
    <link href="https://www.darkfox.top/posts/694f8495/"/>
    <id>https://www.darkfox.top/posts/694f8495/</id>
    <published>2021-11-08T03:30:55.000Z</published>
    <updated>2022-03-20T06:04:50.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://fastly.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><span id="more"></span><h3 id="基于openmv的图像识别"><strong>基于openmv的图像识别</strong></h3><h4 id="openmv简介"><strong>openmv简介</strong></h4><p>OpenMV是一个开源，低成本，功能强大的机器视觉模块，以STM32F427CPU为核心，集成了OV7725摄像头芯片，在小巧的硬件模块上，用C语言高效地实现了核心机器视觉算法，提供Python编程接口 。同时 OpenMV也是一个可编程的摄像头，通过Python语言可实现你想要的逻辑。而且摄像头本身也内置了一些图像处理的算法，使用起来也更加的方便，仅需要写一些简单的Python代码，即可轻松的完成各种机器视觉相关的任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在本次赛事中我们听到的最多的怨言就是（openmv4运行内存只有1MB，而openmv4plus运行内存有32MB！）</span><br><span class="line">，因为很多神经网络模型需要更大的内存才能运行。但是这个其实是可以实现的，后面我会简单说明一下。</span><br></pre></td></tr></table></figure><h5 id="一-打开openmv-ide软件"><strong>一、打开OpenMV IDE软件</strong></h5><p><img src="https://img-blog.csdnimg.cn/c84f2fc2a13b4c408867322efa96691a.png" alt="img" loading="lazy"></p><p>选择Cancel（不升级即可）！</p><h5 id="二-openmv4的数字模板匹配识别"><strong>二、openmv4的数字模板匹配识别</strong></h5><p>openmv4的数字识别的基础是需要配置使用NCC模板匹配。通过NCC模板的匹配可把</p><p>需要识别的数字模板图片保存到SD卡中，然后可进行下一步的识别。</p><p><strong>1、我们通过打开模板匹配的历程来直接打开代码使用</strong></p><p>点击文件——示例——openmv——feature detection——template_matching.py</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/test/202111121343657.png" alt="" loading="lazy"></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/test/202111121335156.png" alt="" loading="lazy"></p><p><strong>2、如果运行出现这个窗口那就说明你没有保存模板图片。</strong></p><p><img src="https://img-blog.csdnimg.cn/4043f3c29e4847d59d86ae582e3874d0.png" alt="img" loading="lazy"></p><p><strong>这时我们就需要创建一个模板图片。</strong></p><p><strong>3、首先要打开一个helloworld历程文件</strong></p><p>点击file——examples——01-basics——<a href="http://helloworld.py">helloworld.py</a></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/test/202111121344295.png" alt="" loading="lazy"></p><p><strong>4、在helloworld历程文件中进行匹配0~9这样的数字</strong></p><p>对这些数字进行一一截取（打开摄像头，图像中出现数字之和关闭摄像头，在图像中截取数字，右键选择将图像选择保存到PC），用它们来作为我们的模板图片（此时图片格式后缀为bmp格式）。</p><p>在右边的Frame Buffer框中进行截取</p><p><strong>注意</strong>：不要点Zoom，因为Zoom展示的是放大后的效果，在识别时可能会导致失帧。</p><p><strong>例如：本人截取的一张图片（目前后缀还是bmp）</strong></p><p><img src="https://img-blog.csdnimg.cn/c29ea05f024d4e5c9f01b8d110eb3bb7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA546L5ZOl5p2l5LqG5b-r6LeR,size_8,color_FFFFFF,t_70,g_se,x_16" alt="img" loading="lazy"></p><p><img src="https://img-blog.csdnimg.cn/2e6e9ea350664008a0908f27e633e6ca.bmp" alt="img" loading="lazy"></p><p><strong>注意：模板图片的格式一定要是pgm的格式</strong></p><p>星瞳科技给了一个网址：<strong><a href="https://convertio.co/zh/bmp-pgm/">https://convertio.co/zh/bmp-pgm/</a></strong>，其他的网站也是大同小异</p><p>这个网站用不了的话可以去百度啥的地方随便搜一个</p><p>点击选择文件（刚刚截图的模板图片）</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/test/202111121346073.png" alt="" loading="lazy"></p><p>打开所选的图片，点击转换（注意是不是转换到PGM格式，如果不是请换到PGm格式）</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/test/202111121337807.png" alt="" loading="lazy"></p><p>转换完成之后点击下载即可，此时图片后缀为PGM格式。</p><p><strong>5、将转换的数字图片（PGM）进行保存，一定要保存到OpenMV4的SD卡中，名称自定义</strong></p><p><strong>6、把template.pgm改为你命名的模板图片（PGM）的名称</strong></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/test/202111121338466.png" alt="" loading="lazy"></p><p>例如：我命名的为11</p><p><img src="https://img-blog.csdnimg.cn/ef46e5ea5b614c3ab6b4b2b6de485f03.png" alt="img" loading="lazy"></p><p><strong>7、改完即可运行</strong></p><p><a href="https://book.openmv.cc/image/template-match.html">官方数字识别源代码</a>，此代码为源代码，可在此基础上进行改动。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Template Matching Example - Normalized Cross Correlation (NCC)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This example shows off how to use the NCC feature of your OpenMV Cam to match</span></span><br><span class="line"><span class="comment"># image patches to parts of an image... expect for extremely controlled enviorments</span></span><br><span class="line"><span class="comment"># NCC is not all to useful.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># WARNING: NCC supports needs to be reworked! As of right now this feature needs</span></span><br><span class="line"><span class="comment"># a lot of work to be made into somethin useful. This script will reamin to show</span></span><br><span class="line"><span class="comment"># that the functionality exists, but, in its current state is inadequate.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time, sensor, image</span><br><span class="line"><span class="keyword">from</span> image <span class="keyword">import</span> SEARCH_EX, SEARCH_DS</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reset sensor</span></span><br><span class="line">sensor.reset()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set sensor settings</span></span><br><span class="line">sensor.set_contrast(<span class="number">1</span>)</span><br><span class="line">sensor.set_gainceiling(<span class="number">16</span>)</span><br><span class="line"><span class="comment"># Max resolution for template matching with SEARCH_EX is QQVGA</span></span><br><span class="line">sensor.set_framesize(sensor.QQVGA)</span><br><span class="line"><span class="comment"># You can set windowing to reduce the search image.</span></span><br><span class="line"><span class="comment">#sensor.set_windowing(((640-80)//2, (480-60)//2, 80, 60))</span></span><br><span class="line">sensor.set_pixformat(sensor.GRAYSCALE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load template.</span></span><br><span class="line"><span class="comment"># Template should be a small (eg. 32x32 pixels) grayscale image.</span></span><br><span class="line">template = image.Image(<span class="string">&quot;/template.pgm&quot;</span>)</span><br><span class="line"></span><br><span class="line">clock = time.clock()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run template matching</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">True</span>):</span><br><span class="line">    clock.tick()</span><br><span class="line">    img = sensor.snapshot()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># find_template(template, threshold, [roi, step, search])</span></span><br><span class="line">    <span class="comment"># ROI: The region of interest tuple (x, y, w, h).</span></span><br><span class="line">    <span class="comment"># Step: The loop step used (y+=step, x+=step) use a bigger step to make it faster.</span></span><br><span class="line">    <span class="comment"># Search is either image.SEARCH_EX for exhaustive search or image.SEARCH_DS for diamond search</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># Note1: ROI has to be smaller than the image and bigger than the template.</span></span><br><span class="line">    <span class="comment"># Note2: In diamond search, step and ROI are both ignored.</span></span><br><span class="line">    r = img.find_template(template, <span class="number">0.70</span>, step=<span class="number">4</span>, search=SEARCH_EX) <span class="comment">#, roi=(10, 0, 60, 60))</span></span><br><span class="line">    <span class="keyword">if</span> r:</span><br><span class="line">        img.draw_rectangle(r)</span><br><span class="line"></span><br><span class="line">    print(clock.fps())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="openmv的lenet数字识别">openmv的Lenet数字识别</h3><h4 id="1-简单的de个bug">1、简单的de个bug</h4><p>我估计很多人看到了这个nn识别的方案，但是我估计很多人倒在的这个地方</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202111121438620.png" alt="" loading="lazy"></p><p>因为官方把这个model给删除了（笑），另外还要注意一点，这个nn模型只支持3.6.5及以前的固件版本，如果你的固件是最新的版本的话，请刷回来老的固件版本才能使用。固件的话，自己去github找去。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202111121439528.png" alt="" loading="lazy"></p><p>这个模型，我队友通过万能的淘宝给找回来了（笑）。点击下载<a href="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/test/lenet.network">模型文件</a>，注意：该文件分享有效期为该文章发表日期起十日</p><h4 id="2-简单的跑个例程">2、简单的跑个例程</h4><p>刷好固件，存进去模型之后就可以运行了,例程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># LetNet数字识别例程</span></span><br><span class="line"><span class="keyword">import</span> sensor, image, time, os, nn</span><br><span class="line"></span><br><span class="line">sensor.reset()                         <span class="comment"># 复位并初始化传感器。</span></span><br><span class="line"></span><br><span class="line">sensor.set_contrast(<span class="number">3</span>)</span><br><span class="line">sensor.set_pixformat(sensor.GRAYSCALE) <span class="comment"># Set pixel format to RGB565 (or GRAYSCALE)</span></span><br><span class="line"><span class="comment">#设置图像色彩格式，有RGB565色彩图和GRAYSCALE灰度图两种</span></span><br><span class="line"></span><br><span class="line">sensor.set_framesize(sensor.QVGA)      <span class="comment"># 将图像大小设置为QVGA (320x240)</span></span><br><span class="line"></span><br><span class="line">sensor.set_windowing((<span class="number">128</span>, <span class="number">128</span>))       <span class="comment"># 设置128 x128窗口。</span></span><br><span class="line">sensor.skip_frames(time=<span class="number">100</span>)</span><br><span class="line">sensor.set_auto_gain(<span class="literal">False</span>)</span><br><span class="line">sensor.set_auto_exposure(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载lenet神经网络模型</span></span><br><span class="line">net = nn.load(<span class="string">&#x27;/lenet.network&#x27;</span>)</span><br><span class="line">labels = [<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>]</span><br><span class="line"></span><br><span class="line">clock = time.clock()                <span class="comment"># 创建一个时钟对象来跟踪FPS帧率。</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    clock.tick()                    <span class="comment"># 更新FPS帧率时钟。</span></span><br><span class="line">    img = sensor.snapshot()         <span class="comment"># 拍一张照片并返回图像。</span></span><br><span class="line">    out = net.forward(img.copy().binary([(<span class="number">150</span>, <span class="number">255</span>)], invert=<span class="literal">True</span>))</span><br><span class="line">    max_idx = out.index(<span class="built_in">max</span>(out))</span><br><span class="line">    score = <span class="built_in">int</span>(out[max_idx]*<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">if</span> (score &lt; <span class="number">70</span>):</span><br><span class="line">        score_str = <span class="string">&quot;??:??%&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        score_str = <span class="string">&quot;%s:%d%% &quot;</span>%(labels[max_idx], score)</span><br><span class="line">    img.draw_string(<span class="number">0</span>, <span class="number">0</span>, score_str)</span><br><span class="line"></span><br><span class="line">    print(clock.fps())             </span><br><span class="line">    <span class="comment"># 注意: 当连接电脑后，OpenMV会变成一半的速度。当不连接电脑，帧率会增加。</span></span><br><span class="line">    <span class="comment">#打印当前的帧率。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体的效果图我忘记存了，改天重现一下，但是这个方案的结果是：<strong>识别效果很垃圾！<strong>3，6，9不分1，7不分，2，4不分，再加上帧率只有tm的</strong>5帧</strong>，不适合放在车上边移动边识别（哪怕你停下来识别效果也很拉）</p><h4 id="3-简单的训个模型">3、简单的训个模型</h4><p>这个是使用的官方的nnlenet模型，其实我们蛮可以自己训练一个，官方也在下面说过，可以自己训练模型。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/202111121449178.png" alt="" loading="lazy"></p><p>所以我自己训练了一个简单的模型，<a href="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/test/train.png">点击打开模型示意图</a>,因为博主也不是相关技术人员，怕带偏你们，所以就不介绍怎么炼丹了。</p><p>因为没学过相关内容，就简单找了找教程，自己搞个足够大的数据集，然后丢进炼丹炉，然后练好后取出。<a href="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/test/train.tflite">模型文件</a>(注意：该文件十日后失效)</p><p>官方例程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># OpenMV Image Classification Example</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sensor, image, time, os, tf</span><br><span class="line"></span><br><span class="line">sensor.reset()                         <span class="comment"># Reset and initialize the sensor.</span></span><br><span class="line">sensor.set_pixformat(sensor.GRAYSCALE)    <span class="comment"># Set pixel format to RGB565 (or GRAYSCALE)</span></span><br><span class="line">sensor.set_framesize(sensor.QVGA)      <span class="comment"># Set frame size to QVGA (320x240)</span></span><br><span class="line">sensor.set_windowing((<span class="number">240</span>, <span class="number">240</span>))       <span class="comment"># Set 240x240 window.</span></span><br><span class="line">sensor.skip_frames(time=<span class="number">2000</span>)          <span class="comment"># Let the camera adjust.</span></span><br><span class="line"></span><br><span class="line">net = <span class="string">&quot;trained.tflite&quot;</span><span class="comment">#模型名称</span></span><br><span class="line">labels = [line.rstrip(<span class="string">&#x27;\n&#x27;</span>) <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&quot;labels.txt&quot;</span>)]<span class="comment">#标签，训练集自带的那个就行</span></span><br><span class="line"></span><br><span class="line">clock = time.clock()</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    clock.tick()</span><br><span class="line"></span><br><span class="line">    img = sensor.snapshot()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># default settings just do one detection... change them to search the image...</span></span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> tf.classify(net, img, min_scale=<span class="number">1.0</span>, scale_mul=<span class="number">0.8</span>, x_overlap=<span class="number">0.5</span>, y_overlap=<span class="number">0.5</span>):</span><br><span class="line">        print(<span class="string">&quot;**********\nPredictions at [x=%d,y=%d,w=%d,h=%d]&quot;</span> % obj.rect())<span class="comment">#打印坐标</span></span><br><span class="line">        img.draw_rectangle(obj.rect())</span><br><span class="line">        <span class="comment"># This combines the labels and confidence values into a list of tuples</span></span><br><span class="line">        predictions_list = <span class="built_in">list</span>(<span class="built_in">zip</span>(labels, obj.output()))<span class="comment">#定义数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(predictions_list)):</span><br><span class="line">            print(<span class="string">&quot;%s = %f&quot;</span> % (predictions_list[i][<span class="number">0</span>], predictions_list[i][<span class="number">1</span>]))<span class="comment">#对应的数字和概率</span></span><br><span class="line"></span><br><span class="line">    print(clock.fps(), <span class="string">&quot;fps&quot;</span>)<span class="comment">#打印个帧率不过分吧</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>好巧不巧，这个效果图我也忘记保存了，改天补上。这个模型的识别效果就比nn好多了，但是仍然有一些不足，3，6，9仍然会有混滫错误。没办法，内存就那一丁点，跑不了太大的model。</p><h3 id="基于k210的数字识别">基于k210的数字识别</h3><p>因为电赛还没评定完成，暂时空着</p><h4 id="后记">后记</h4><p>真是意想不到竟然拿了个国一，但是老师出于要宣传还是什么的原因，还是不让碰作品，我手头也没有K210所以呢，芬分享啥的再咕几天吧。</p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">之前打电赛需要用到嵌入式视觉识别几个数字，在此记录一下我的思路和方案。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>int8_t等数据类型的区别</title>
    <link href="https://www.darkfox.top/posts/52c127a1/"/>
    <id>https://www.darkfox.top/posts/52c127a1/</id>
    <published>2021-11-02T13:08:59.000Z</published>
    <updated>2022-03-20T06:03:12.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://fastly.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center>   </center><span id="more"></span><p>工作中经常碰到int8_t、int16_t、int32_t、int64_t、uint8_t、size_t、ssize_t等数据类型，所以有必要对此进行梳理。</p><p><strong>int_t同类</strong></p><p>int_t 为一个结构的标注，可以理解为type/typedef的缩写，表示它是通过typedef定义的，而不是一种新的数据类型。因为跨平台，不同的平台会有不同的字长，所以利用预编译和typedef可以最有效的维护代码。</p><ul><li>int8_t   : typedef signed char;</li><li>uint8_t  : typedef unsigned char;</li><li>int16_t  : typedef signed short ;</li><li>uint16_t : typedef unsigned short ;</li><li>int32_t  : typedef signed int;</li><li>uint32_t : typedef unsigned int;</li><li>int64_t  : typedef signed long long;</li><li>uint64_t : typedef unsigned long long;</li></ul><table><thead><tr><th style="text-align:left">Specifier</th><th style="text-align:left">Common Equivalent</th><th style="text-align:left">Signing</th><th style="text-align:left">Bits</th><th style="text-align:left">Bytes</th><th style="text-align:left">Minimum Value</th><th style="text-align:left">Maximum Value</th></tr></thead><tbody><tr><td style="text-align:left"><code>int8_t</code></td><td style="text-align:left"><code>signed char</code></td><td style="text-align:left">Signed</td><td style="text-align:left">8</td><td style="text-align:left">1</td><td style="text-align:left">-128</td><td style="text-align:left">127</td></tr><tr><td style="text-align:left"><code>uint8_t</code></td><td style="text-align:left"><code>unsigned char</code></td><td style="text-align:left">Unsigned</td><td style="text-align:left">8</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">255</td></tr><tr><td style="text-align:left"><code>int16_t</code></td><td style="text-align:left"><code>short</code></td><td style="text-align:left">Signed</td><td style="text-align:left">16</td><td style="text-align:left">2</td><td style="text-align:left">-32,768</td><td style="text-align:left">32,767</td></tr><tr><td style="text-align:left"><code>uint16_t</code></td><td style="text-align:left"><code>unsigned short</code></td><td style="text-align:left">Unsigned</td><td style="text-align:left">16</td><td style="text-align:left">2</td><td style="text-align:left">0</td><td style="text-align:left">65,535</td></tr><tr><td style="text-align:left"><code>int32_t</code></td><td style="text-align:left"><code>int</code></td><td style="text-align:left">Signed</td><td style="text-align:left">32</td><td style="text-align:left">4</td><td style="text-align:left">-2,147,483,648</td><td style="text-align:left">2,147,483,647</td></tr><tr><td style="text-align:left"><code>uint32_t</code></td><td style="text-align:left"><code>unsigned int</code></td><td style="text-align:left">Unsigned</td><td style="text-align:left">32</td><td style="text-align:left">4</td><td style="text-align:left">0</td><td style="text-align:left">4,294,967,295</td></tr><tr><td style="text-align:left"><code>int64_t</code></td><td style="text-align:left"><code>long long</code></td><td style="text-align:left">Signed</td><td style="text-align:left">64</td><td style="text-align:left">8</td><td style="text-align:left">-9,223,372,036,854,775,808</td><td style="text-align:left">9,223,372,036,854,775,807</td></tr><tr><td style="text-align:left"><code>uint64_t</code></td><td style="text-align:left"><code>unsigned long long</code></td><td style="text-align:left">Unsigned</td><td style="text-align:left">64</td><td style="text-align:left">8</td><td style="text-align:left">0</td><td style="text-align:left">18,446,744,073,709,551,615</td></tr></tbody></table><p><strong>size_t与ssize_t</strong></p><p>size_t主要用于计数，如sizeof函数返回值类型即为size_t。在不同位的机器中所占的位数也不同，size_t是无符号数，ssize_t是有符号数。</p><ul><li>在32位机器中定义为：typedef  unsigned int size_t; （4个字节）</li><li>在64位机器中定义为：typedef  unsigned long size_t;（8个字节）</li></ul><p>由于size_t是无符号数，因此，<strong>当变量有可能为负数时，必须使用ssize_t</strong>。因为当有符号整型和无符号整型进行运算时，有符号整型会先自动转化成无符号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> a;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> b = <span class="number">-1</span>;</span><br><span class="line">    a = b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b=&quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//b=-1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//a=65535</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，int 无论在32位还是64位机器中，都是4个字节, 且带符号，可见size_t与int 的区别之处。</p><p>下面是stdint.h中的详细定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 7.18.1.1  Exact-width integer types */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">char</span> <span class="keyword">int8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>   <span class="keyword">uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">short</span>  <span class="keyword">int16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span>  <span class="keyword">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>  <span class="keyword">int32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span>   <span class="keyword">uint32_t</span>;</span><br><span class="line">__MINGW_EXTENSION <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span>  <span class="keyword">int64_t</span>;</span><br><span class="line">__MINGW_EXTENSION <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>   <span class="keyword">uint64_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 7.18.1.2  Minimum-width integer types */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">char</span> <span class="keyword">int_least8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>   <span class="keyword">uint_least8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">short</span>  <span class="keyword">int_least16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span>  <span class="keyword">uint_least16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>  <span class="keyword">int_least32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span>   <span class="keyword">uint_least32_t</span>;</span><br><span class="line">__MINGW_EXTENSION <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span>  <span class="keyword">int_least64_t</span>;</span><br><span class="line">__MINGW_EXTENSION <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>   <span class="keyword">uint_least64_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  7.18.1.3  Fastest minimum-width integer types</span></span><br><span class="line"><span class="comment"> *  Not actually guaranteed to be fastest for all purposes</span></span><br><span class="line"><span class="comment"> *  Here we use the exact-width types for 8 and 16-bit ints.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">char</span> <span class="keyword">int_fast8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="keyword">uint_fast8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">short</span>  <span class="keyword">int_fast16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span>  <span class="keyword">uint_fast16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>  <span class="keyword">int_fast32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span>  <span class="keyword">int</span>  <span class="keyword">uint_fast32_t</span>;</span><br><span class="line">__MINGW_EXTENSION <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span>  <span class="keyword">int_fast64_t</span>;</span><br><span class="line">__MINGW_EXTENSION <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>   <span class="keyword">uint_fast64_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 7.18.1.5  Greatest-width integer types */</span></span><br><span class="line">__MINGW_EXTENSION <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span>  <span class="keyword">intmax_t</span>;</span><br><span class="line">__MINGW_EXTENSION <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>   <span class="keyword">uintmax_t</span>;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;center&gt;   &lt;/center&gt;</summary>
    
    
    
    <category term="C语言" scheme="https://www.darkfox.top/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言数据类型" scheme="https://www.darkfox.top/tags/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>c/c++ long int与long long的区别</title>
    <link href="https://www.darkfox.top/posts/66a918cc/"/>
    <id>https://www.darkfox.top/posts/66a918cc/</id>
    <published>2021-11-02T11:49:28.000Z</published>
    <updated>2022-03-20T06:04:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://fastly.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center>   </center><h1>long int</h1><p>long int即long，给人的感觉好像是长整型，但实际上，它和int一样，只有32位。cppreference给出的定义是——</p><blockquote><p><strong>int</strong> - basic integer type. The keyword int may be omitted if any of the modifiers listed below are used. If no length modifiers are present, it’s guaranteed to have a width of at least 16 bits. However, on 32/64 bit systems it is almost exclusively guaranteed to have width of at least 32 bits.<br><strong>long</strong> - target type will have width of at least 32 bits.</p></blockquote><p>在实际的使用中，long与int几乎没有区别，比如——</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> l = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10000000</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;size of long:%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;size of int:%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;l = %d\n&quot;</span>,l);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>,i);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2018122510141490.png" alt="在这里插入图片描述" loading="lazy"><br>　　既然long int与int相同，那么为什么还有long int这种尴尬的类型呢？<br>　　原因是早期的C编译器定义了long int占用4个字节，int占用2个字节，long int是名副其实的<strong>长整型</strong>。在ANSI C的标准中，对长整型的定义也是<strong>long int应该至少和int一样长</strong>，而不是long int 一定要比int占用存储字节长。新版的C/C++标准兼容了早期的这一设定。</p><span id="more"></span><h1>long long</h1><p>long long则不同，long long是C++的64位整型的基本类型，“现任”长整型，从C99开始引入这个概念，在后续的标准中完善概念和定义，C++11官方正式标准如下——</p><blockquote><p><strong>long long</strong> - target type will have width of at least 64 bits.(since C++11)</p></blockquote><p>long long占用8个字节，数据表示范围也从int的[ − 2 31 , 2 31 − 1 ] [-2^{31},2^{31}-1][−231,231−1]，升级到[ − 2 63 , 2 63 − 1 ] [-2^{63},2^{63}-1][−263,263−1]。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> l = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ll = <span class="number">100000000000000</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;size of long:%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;size of int:%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;size of long long:%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>));</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;l = %d\n&quot;</span>,l);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>,i);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;ll = %lld\n&quot;</span>,ll);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20181225103911667.png" alt="在这里插入图片描述" loading="lazy"><br>　　long long是C++的正式标准，这也就意味着，该类型不会因为编译器或者开发平台的不同而有所差异，放之四海而皆准，而且与一些系统函数、类库都有很好的交互（如常见的printf、scanf、cin和cout等）。与之相反，出身MS的__int64就有点不受待见了，在不同的编译器上可能水土不服。</p><h1>__int64</h1><p>在早期的代码中，可能会遇到<code>__int64</code>这种类型，这应该算是“历史遗留”问题。早期的C/C++标准中并没有规定64位长整型的规范，因此不同的编译器对这一模糊概念有不同的定义，我们熟知的VC6.0采用了<code>__int64</code>这种类型来表示64位长整型——</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">__int64 i64 = -<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">63</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;__int64:&quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(__int64)&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;i64 = &quot;</span>&lt;&lt;i64&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20181225104812530.png" alt="在这里插入图片描述" loading="lazy"><br>　　与long long具有相同的效果，但是，__int64并不是正式规范，比如，如果你使用的是MinGW的编译器的话，打开__int64的定义会发现——<br><img src="https://img-blog.csdnimg.cn/20181225105553149.png" alt="img" loading="lazy"><br>　　VS 2017虽然把__int64作为了一种内置类型，但是也做了类似的处理，使得__int64与long long没有肉眼可见的差别。但如果你使用的开发环境比较早期，那么可能就要专门研究一下__int64了。比如说，古老的VC6.0并没有long long这种类型，而__int64的输入输出，又需要printf和%I64d的配合，而不是%lld或者直接用cout。</p><h1>总结</h1><p>C/C++与Java等语言不同，具有较高的自由度，由于某些历史原因，某些概念在不同的平台上有不同的解释，虽然现在新版本的C++标准和编译器都在做兼容性工作，你可以在__int64与long long之间无缝切换，但至少，我们要清楚两者的不同。</p><table><thead><tr><th>类型</th><th>存储字节</th><th>表示范围</th></tr></thead><tbody><tr><td>int</td><td>4</td><td>-2147483648~2147483647</td></tr><tr><td>short int</td><td>2</td><td>-32768～+32767</td></tr><tr><td>long</td><td>4</td><td>-2147483648~2147483647（二十亿，约1 0 10 10^{10}1010）</td></tr><tr><td>long long</td><td>8</td><td>9223372036854775808～+9223372036854775807(九百亿亿，约1 0 19 10^{19}1019)</td></tr><tr><td>__int64</td><td>8</td><td>9223372036854775808～+9223372036854775807</td></tr></tbody></table><h1>参考链接</h1><p>1.<a href="https://blog.csdn.net/qq_31736627/article/details/52912691">https://blog.csdn.net/qq_31736627/article/details/52912691</a><br>2.<a href="https://en.cppreference.com/w/cpp/language/types">https://en.cppreference.com/w/cpp/language/types</a><br>3.<a href="https://www.cnblogs.com/ChenDinghao/p/6480937.html">https://www.cnblogs.com/ChenDinghao/p/6480937.html</a><br>4.<a href="https://blog.csdn.net/sk18192449347/article/details/55000087">https://blog.csdn.net/sk18192449347/article/details/55000087</a></p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;center&gt;   &lt;/center&gt;
&lt;h1&gt;long int&lt;/h1&gt;
&lt;p&gt;long int即long，给人的感觉好像是长整型，但实际上，它和int一样，只有32位。cppreference给出的定义是——&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;int&lt;/strong&gt; - basic integer type. The keyword int may be omitted if any of the modifiers listed below are used. If no length modifiers are present, it’s guaranteed to have a width of at least 16 bits. However, on 32/64 bit systems it is almost exclusively guaranteed to have width of at least 32 bits.&lt;br&gt;
&lt;strong&gt;long&lt;/strong&gt; - target type will have width of at least 32 bits.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在实际的使用中，long与int几乎没有区别，比如——&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; l = &lt;span class=&quot;number&quot;&gt;10000000&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;10000000&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;size of long:%d\n&amp;quot;&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;size of int:%d\n&amp;quot;&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;l = %d\n&amp;quot;&lt;/span&gt;,l);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;i = %d\n&amp;quot;&lt;/span&gt;,i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1234567891011&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2018122510141490.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;
　　既然long int与int相同，那么为什么还有long int这种尴尬的类型呢？&lt;br&gt;
　　原因是早期的C编译器定义了long int占用4个字节，int占用2个字节，long int是名副其实的&lt;strong&gt;长整型&lt;/strong&gt;。在ANSI C的标准中，对长整型的定义也是&lt;strong&gt;long int应该至少和int一样长&lt;/strong&gt;，而不是long int 一定要比int占用存储字节长。新版的C/C++标准兼容了早期的这一设定。&lt;/p&gt;</summary>
    
    
    
    <category term="C语言" scheme="https://www.darkfox.top/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言数据类型" scheme="https://www.darkfox.top/tags/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Bug</title>
    <link href="https://www.darkfox.top/posts/dc1f9f4/"/>
    <id>https://www.darkfox.top/posts/dc1f9f4/</id>
    <published>2021-09-28T11:45:55.000Z</published>
    <updated>2022-03-20T06:12:44.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://fastly.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center>   </center><span id="more"></span><h1>0x01</h1><p><img src="https://i.loli.net/2021/04/16/iD3tlZvuJBwzaex.png" alt="Snipaste_2021-04-16_09-29-21" loading="lazy"></p><p>Debug :</p><p>排除了bootload的问题</p><p>排除了芯片型号的问题</p><p>排除了驱动的问题</p><p>排除了接线的问题</p><p>排除了软件（上位机）问题</p><p>未排除下位机是否存在问题</p><p>未排除开发板是否短路</p><p>未排除开发板是否有故障</p><p>没有找到解决方案，打算换个控制系统试一下。</p><h1>0x02</h1><p>bug的来源十分简单，github上的那个grbl例程包里面有个小问题。那个grbl的包只要刷进去开发板，你的开发板就不能再写入其他程序了。是不是很诡异</p><p><img src="https://i.loli.net/2021/04/18/3mMUzEtJoV6pyR4.png" alt="" loading="lazy"></p><p><img src="https://i.loli.net/2021/04/18/cot1SMRln6zvNBE.png" alt="" loading="lazy"></p><p>包括arduino ide本身也不能再次刷进去程序了，很是诡异。一些老哥说是bootloader给刷掉了，改天刷一个看看是否能还原。</p><p>就目前的项目来看，只能再买一个开发板了。</p><p><img src="https://i.loli.net/2021/04/18/YC1wpWbiaUEeGRq.png" alt="" loading="lazy"></p><p>再也不刷这个包了。。。。。。</p><hr><p>后记：其实是这个板子的芯片有问题，我买的arduino uno的开发板只有16块钱，当时没注意，这个垃圾芯片是二手拆机下来的。熔断丝已经寄了，所以出现错误后不可恢复。</p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">用来记录那些奇奇怪怪的BUG，解决的bug将放入debug文件里面</summary>
    
    
    
    <category term="bug" scheme="https://www.darkfox.top/categories/bug/"/>
    
    
    <category term="bug" scheme="https://www.darkfox.top/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>Debug</title>
    <link href="https://www.darkfox.top/posts/ad6468a3/"/>
    <id>https://www.darkfox.top/posts/ad6468a3/</id>
    <published>2021-09-28T11:25:27.000Z</published>
    <updated>2022-03-20T06:12:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://fastly.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center>   </center> <span id="more"></span><h5 id="00x01-命名">00x01 命名</h5><p>这是有个远古之前犯的bug，今天来复现一下。</p><p>如图所示，一个极其简单的入门级别的操作代码，没有啥问题吧？</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/pic/20210928193215.png" alt="" loading="lazy"></p><p>但是吼，报错了嘿</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/pic/20210928194231.png" alt="" loading="lazy"></p><p>仔细一看，发现了么，是因为命名出现了问题。<img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/pic/20210928194412.png" alt="" loading="lazy"></p><p>改一下名字就好了，(<em>^_^</em>)</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/pic/20210928194508.png" alt="" loading="lazy"></p><p>00x03</p><p>00x04</p><p>00x05</p><p>00x06</p><p>00x07</p><p>00x08</p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">今天突然发现犯了以前的错误，但是忘记了debug方式，所以在此记录下，以备后患</summary>
    
    
    
    <category term="bug" scheme="https://www.darkfox.top/categories/bug/"/>
    
    
    <category term="bug" scheme="https://www.darkfox.top/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>写这句话的人建议拉去并网发电</title>
    <link href="https://www.darkfox.top/posts/3391b988/"/>
    <id>https://www.darkfox.top/posts/3391b988/</id>
    <published>2021-09-27T13:06:42.000Z</published>
    <updated>2022-06-23T03:03:28.143Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://fastly.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/pic/202109272108878.jpg" alt="1" loading="lazy"></p><span id="more"></span><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://pic-1304932877.cos.ap-shanghai.myqcloud.com/pic/202109272108878.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>宽禁带半导体材料的电力电子器件概述</title>
    <link href="https://www.darkfox.top/posts/946a5cb7/"/>
    <id>https://www.darkfox.top/posts/946a5cb7/</id>
    <published>2021-09-27T09:53:38.000Z</published>
    <updated>2022-03-20T06:08:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://fastly.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h4 id="百字总结">百字总结</h4><p>宽禁带半导体材料被誉为第三代半导体材料，典型的材料代表有碳化硅、氮化镓、金刚石。在电力电子元件以及材料的研制中，碳化硅的研究时间最为长久，紧接其后的便是氮化镓。第三代半导体材料相比较传统工艺材料有明显的三大特性。比硅高得多的临界雪崩击穿电场强度和载流子饱和漂移速度、较高的热导率和相差不大的载流子迁移率，因此，基于宽禁带半导体材料(如碳化硅)的电力电子器件将具有比硅器件高得多的耐受高电压的能力、低得多的通态电阻、更好的导热性能和热稳定性以及更强的耐受高温和射线辐射的能力，许多方面的性能都是成数量级地提高。<br>之所以最近该材料广受关注，是因为人们普遍认为硅基材料已经接近材料特性的理论极限。为了人类的进步，以及国家的战略发展，众多攻城狮和科学家将精力放在了此处。目前该新型材料（其实不新了，最早可以追溯到上个世纪）的发展一直受制于材料的提炼、制造以及随后半导体制造工艺的困难。目前金刚石在这些宽禁带半导体材料中性能是最好的，很多人称之为最理想的或最具前景的电力半导体材料。但是金刚石材料提炼和制造以及随后的半导体制造工艺也是最困难的（所以才有人去研究石墨烯）。目前，碳化硅的工艺较为成熟。其优异的特性使其在研制高温、高频、大功率、抗辐射器件以及紫外探测器、短波发光二极管等方面具有广阔的应用前景。</p><span id="more"></span><h3 id="何为宽禁带半导体材料">何为宽禁带半导体材料</h3><p>固体中电子的能量具有不连续的量值，电子都分布在一些相互之间不连续的能带上。价电子所在能带与自由电子所在能带之间的间隙称为禁带或带隙。所以禁带的宽度实际上反映了被束缚的价电子要成为自由电子所必须额外获得的能量。硅的禁带宽度为1.12电子伏特(eV)，而宽禁带半导体材料是指禁带宽度在2.3eV及以上的<a href="https://baike.baidu.com/item/%E5%8D%8A%E5%AF%BC%E4%BD%93%E6%9D%90%E6%96%99/5078">半导体材料</a>，典型的是<a href="https://baike.baidu.com/item/%E7%A2%B3%E5%8C%96%E7%A1%85/245856">碳化硅</a>(SiC)、氮化镓(GaN)、金刚石等材料。宽禁带半导体材料是被称为第三代半导体材料。</p><h3 id="sic器件概要">SIC器件概要</h3><p>以碳化硅(SiC)和氮化镓(GaN)为代表的第三代半导体材料具有非常显著的性能优势和巨大的产业带动作用，欧美日等发达国家和地区都将发展碳化硅半导体技术列入国家战略，积极投入巨资支持发展。随着SiC衬底、外延材料、工艺制造技术的改进，器件性能和生产成本不断降低。SiC电力电子器件打破了传统Si器件由于材料特性极限所造成的性能瓶颈，推动着电力电子技术领域的革新与发展。当前，传统电网正向以电力电子技术广泛应用为代表的智能电网方向发展。以未来电力电子变压器的核心应用为代表，对超高压大功率器件提出了更高的性能要求。碳化硅(SiC)器件具有高耐压、大电流、高频率、低损耗等优势，大大推动了设备小型化、轻量化、高效化、低能耗的发展，因此，高压大功率SiC材料及器件的实用化将决定电力电子设备的发展未来。</p><p>对于 10 kV 超高压 SiC 电力电子器件，一些工艺难度较低的器件，如 PiN 二极管、肖特基势垒二极管(SBD)等，发展较早，正趋向成熟；对于栅控器件，如 MOSFET、 IGBT，由 SiC 材料所带来的一些问题，如栅氧界面态密度高、沟道迁移率低、器件可靠性差等，随着近年来材料及工艺技术的提高，逐渐获得解决和完善，尽管起步较晚，但是发展迅速。 本文将重点针对近年来国内外智能电网用 10 kV以上 SiC 二极管(PiN、 SBD、 JBS 与 MPS)和晶体管(SiC MOSFET 与 IGBT)的器件结构、技术手段、发展现状来阐述超高压 SiC 电力电子器件的设计思路及其性能特点。</p><h4 id="超高压-sicpin-二极管">超高压 SiCPiN 二极管</h4><p>国外对于 SiCPiN 二极管的研究始于 20 世纪 90年代，凭借其简单且成熟的工艺优势， SiCPiN 二极管成为 SiC 电力电子器件的主力之一，尤其在超高压领域的研究已较为成熟。通过不断优化与改进结终端技术， SiCPiN 二极管成为目前超高压领域发展最完善的电力电子器件  。</p><p>2001 年日本关西电力研究中心和 CREE 共同报道了耐压达到 12~19 kV 的 MESA-JTE 结构的SiCPiN 二极管， 成为世界上首个超过 10 kV 的 SiC功率整流器。 器件通过结合 MESA 与单区 JTE 两种结终端技术，从而降低边缘电场集中效应，提高了器件击穿电压。</p><p>对于不同外延层浓度与厚度的SiCPiN二极管(A：N-漂移区掺杂浓度2×1014cm–3，厚度120μm；B：N-漂移区掺杂浓度8×1013cm–3，厚度200μm)，击穿电压分别达到了14.9 kV与19 kV，100 A/cm2时导通压降UF分别为4.4 V与6.5 V，关断延迟仅为商业化400 V耐压的Si基PiN二极管的1/4，动态损耗大大降低，如图1所示。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/pic/202109271830648.png" alt="image-20210927183034494" loading="lazy"></p><p>做为首个超过10 kV的SiC功率整流器，该研究对未来超高压SiC功率器件的发展具有重要的意义及借鉴作用。但是，MESA结构的缺点在于斜面角度与掺杂浓度需要进行优化，而且实际工艺中往往受到氧化层间电荷的影响。另一方面，器件击穿电压对于单区JTE区的掺杂浓度范围很敏感，因此在实际工艺中，要获得最大击穿电压对应的最优JTE掺杂浓度非常困难。因此，近年来国内外学者不断优化改进JTE终端结构，进一步提高了SiCPiN二极管性能。</p><p>2015年，Naoki Kaji等人通过结合间距调变JTE(space-modulated JTE，SM-JTE)与双区JTE(double zone JTE)结构，研制出了一种击穿电压超过26.9 kV的SiCPiN二极管，是目前报道的击穿电压最高的SiC电力电子器件，如图2所示。新结构通过优化SM-JTE的宽度与间距，降低了单区JTE边缘处的电场集中现象，从而克服了传统单区JTE存在的优化掺杂浓度范围窄的缺点。同时，与传统双区JTE结构相比，JTE区同样只需要2次离子注入，没有增加工艺步骤与难度。该结构器件特性如图3所示。一方面，相比传统单区JTE与双区JTE结构，新结构JTE优化掺杂浓度范围显著扩宽；另一方面，当N-区厚度分别为98μm和268μm时二极管的击穿电压超过13 kV和26.9 kV，达到了理论平行平面结击穿电压的70%，同时差分导通电阻分别为1.87 mΩ·cm2及9.7 mΩ·cm2，正向压降分别为3.1 V和4.72 V，在保证优良正向导通特性的条件下，大大提高了器件的击穿电压。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/pic/202109271831805.png" alt="image-20210927183155665" loading="lazy"></p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/pic/202109271832155.png" alt="image-20210927183209986" loading="lazy"></p><h4 id="超高压sic-sbd二极管">超高压SiC SBD二极管</h4><p>肖特基势垒二极管(schottky barrier diode，SBD)是一种金半接触的整流器件，SiC SBD相较于SiCPiN二极管，其主要优势在于导通压降只有1 V左右，仅为PiN二极管的1/3，大大降低了器件的导通损耗。但是，金半接触也导致其反向耐压较低，泄漏电流较大，如今商业化的SiC SBD大多在千伏量级，对于10 kV以上的超高压领域，目前国内外的研究均较少。2003年，赵建华等人报道了首个10 kV SiC SBD二极管。该器件的终端利用刻蚀与外延生长形成多级JTE结构，如图4所示。二极管击穿电压为10.8 kV，电流密度48 A/cm2时正向导通压降为6 V，比导通电阻187 mΩ·cm2。器件的缺点显而易见，反向泄漏电流较大。</p><h4 id="超高压sic-jbs与mps二极管">超高压SiC JBS与MPS二极管</h4><p>JBS与MPS二极管结构上类似，均是结合PiN高耐压大电流与SBD低导通压降、高开关速度的优点，其区别在于：JBS二极管选用肖特基势垒较低的金属接触，漂移区较薄，导通时仅SBD部分参与导电，关断时PN结反偏形成耗尽层承受耐压，多用于低压领域；而MPS选用肖特基势垒相对较高的金属接触，漂移区较厚，导通时SBD与PiN均参与导电，多用于高压领域。JBS与MPS的综合性能均高于单一PiN和SBD器件，且工艺难度不大，因此，在超高压应用领域，SiC JBS与MPS二极管扮演着重要角色。</p><h4 id="超高压sic-mosfet与igbt晶体管">超高压SiC MOSFET与IGBT晶体管</h4><p>金属氧化物场效应半导体(MOSFET)与绝缘栅双极型晶体管(IGBT)均是栅控型电力电子器件，其输入阻抗高、温度稳定性好、安全工作区大，是目前中高压领域发展的主流器件，尤其IGBT更是结合了MOSFET与BJT的优点，在高压大电流应用领域远超其他器件，是目前发展最为迅速的功率器件。同样，在10 kV领域，SiC MOSFET与SiC IGBT相比传统器件具有巨大优势。一方面，SiC MOSFET与SiC IGBT大大降低了功率损耗，减少了系统元器件数目，简化了电路拓扑结构，提高了效率。另一方面，超高压SiC MOSFET与SiC IGBT为一些<br>受到Si材料极限限制的应用领域，如固态电力电子变压器，提供了扩展发展空间的途径。由CREE公司设计研制的10~15 kV SiCMOSFET和15 kV SiC IGBT代表了目前超高压功率器件发展的最高技术水平，并引起了国际上对于超高压SiC MOSFET和SiC IGBT晶体管的广泛研究。2015年Jeffrey B等人报道了新一代的10 kVSiC MOSFET，如图8所示，对于8.1 mm×8.1 mm的器件，通过优化改进，其室温下导通电阻从第一代的160 mΩ降低至100 mΩ。</p><h4 id="sic器件在电力电子变压器中的应用">SiC器件在电力电子变压器中的应用</h4><p>电力电子变压器与传统变压器相比具有重量轻、体积小、单位功率因数高等优点。随着分布式发电系统、智能电网技术以及可再生能源的发展，面向智能电网的电力电子变压器逐渐发展为具有电气隔离、可再生能源并网接入等多种功能的智能化电力电子设备。然而，早期电力电子变压器的理论和实验研究受到当时大功率器件和高压大功率变换技术发展水平以及Si基器件材料性能极限带来的开关频率的限制，未能实用化。随着10 kV以上SiC电力电子器件的出现，电力电子变压器的研究取得了新的突破。</p><p>2009年W Sung等人报道了15 kV SiCIGBT，打破了传统Si基功率开关器件的频率限制，使固态变压器取代传统配电变压成为可能。如图14所示的FREEDM系统中，15 kV SiC IGBT将被用于固态变压器技术中，取代系统中变压器和配电控制，实现可再生能源的发展，提高电能质量。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/pic/202109271859338.png" alt="image-20210927185929187" loading="lazy"></p><p>2014年J. W. Palmour等人报道了15 kVSiC MOSFET，与商业化6.5 kV的Si IGBT比较，如表2所示，击穿电压高2倍多，且开关损耗仅为其1/30。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/pic/202109271901898.png" alt="image-20210927190134793" loading="lazy"></p><p>15 kV的SiC MOSFET和JBS被应用在第二代电力电子变压器中，与第一代采用6.5 kV的硅基IGBT电力电子变压器(如图15所示)相比较，不再使用复杂的器件或拓扑串联结构，开关频率由原来的1 kHz提升至20 kHz，开关损耗大大降低，并且可靠性大大提高。</p><h4 id="超高压sic器件在直流及交流断路器中的应用">超高压SiC器件在直流及交流断路器中的应用</h4><p>直流断路器凭借其高速的开关特性和方便的控制能力，以及瞬时、高频、低损耗和高安全性的特性得到了广泛的关注。15 kV SiC ETO器件被应用于直流断路器，如图所示，实现了9 kV/50 A下的可靠性工作。在大容量柔性直流输电技术发展的推动下，超高压大容SiC器件在未来直流断路器的应用中必定具有光明的应用前景。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/pic/202109271908466.png" alt="image-20210927190806346" loading="lazy"></p><p>交流固态断路器的主要特点就是快速性和可靠性，对电网故障的快速检测系统起着十分重要的作用。目前已有研究者提出基于15 kV SiC ETO及15 kV PiN二极管的混合交流断路器，如图所示，实现了中压领域超过100 A的故障电流条件下，4 ms内快速断路。相比传统机械断路器40~100 ms，速度提升了一个数量级，大大提高了交流固态断路器的快速性和可靠性。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/pic/202109271910964.png" alt="image-20210927191023879" loading="lazy"></p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;百字总结&quot;&gt;百字总结&lt;/h4&gt;
&lt;p&gt;宽禁带半导体材料被誉为第三代半导体材料，典型的材料代表有碳化硅、氮化镓、金刚石。在电力电子元件以及材料的研制中，碳化硅的研究时间最为长久，紧接其后的便是氮化镓。第三代半导体材料相比较传统工艺材料有明显的三大特性。比硅高得多的临界雪崩击穿电场强度和载流子饱和漂移速度、较高的热导率和相差不大的载流子迁移率，因此，基于宽禁带半导体材料(如碳化硅)的电力电子器件将具有比硅器件高得多的耐受高电压的能力、低得多的通态电阻、更好的导热性能和热稳定性以及更强的耐受高温和射线辐射的能力，许多方面的性能都是成数量级地提高。&lt;br&gt;
之所以最近该材料广受关注，是因为人们普遍认为硅基材料已经接近材料特性的理论极限。为了人类的进步，以及国家的战略发展，众多攻城狮和科学家将精力放在了此处。目前该新型材料（其实不新了，最早可以追溯到上个世纪）的发展一直受制于材料的提炼、制造以及随后半导体制造工艺的困难。目前金刚石在这些宽禁带半导体材料中性能是最好的，很多人称之为最理想的或最具前景的电力半导体材料。但是金刚石材料提炼和制造以及随后的半导体制造工艺也是最困难的（所以才有人去研究石墨烯）。目前，碳化硅的工艺较为成熟。其优异的特性使其在研制高温、高频、大功率、抗辐射器件以及紫外探测器、短波发光二极管等方面具有广阔的应用前景。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>MATLAB的常用函数</title>
    <link href="https://www.darkfox.top/posts/6b735cd/"/>
    <id>https://www.darkfox.top/posts/6b735cd/</id>
    <published>2021-09-26T01:42:13.000Z</published>
    <updated>2022-03-20T06:04:44.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://fastly.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center>   </center><span id="more"></span><h3 id="第一篇：matlab软件函数">第一篇：Matlab软件函数</h3><h4 id="一-软件操作函数">一、软件操作函数</h4><h5 id="1-命令窗口函数：">1）命令窗口函数：</h5><p>clc：清空命令窗口，使用向上箭头翻看命令。</p><p>open:打开文件，文本文件（<em>.doc），可执行文件（</em>.exe），图形文件（<em>.fig），超文本文件（</em>.html，<em>.htm），MATLAB数据库文件（</em>.mat），simulink模型文件*.mdl），MATLAB p文件（<em>.p），PDF文件（</em>,pdf），PPT文件（<em>.ppt），工程文件（</em>.prj），网址(*.url)和变量等。</p><p>format：设置数据输出格式。format（‘command’）</p><p>disp:在commandwindow中显示字符和矩阵。</p><p>​    disp(x)—x为矩阵</p><p>​    disp(‘x’)—x为字符</p><p>​    disp([‘x’ a ‘y’])—打印字符合集</p><p>clear：从工作空间中清空变量。clear, clear name,clear global name, clear –regexpexpr1 expr2</p><p>​    clear:清空工作空间的所有变量</p><p>​    clear name—clear(‘name’):清空以name命名的m文件，mex文件或变量名</p><p>​    clear globe name:完全清空以name命名的全局变量，清空后该全局变量不能被函数调用。</p><h5 id="2-帮助函数">2)帮助函数</h5><p>demo：通过help浏览器访问工具箱的演示文件。—demo’MATLAB’</p><p>doc:在help浏览器中打开相应帮助页面。</p><p>help：在MATLAB命令窗口中显示MATLAB的m函数，mdl文件，工具箱等的帮助信息。</p><h4 id="二-文件编程函数">二、文件编程函数</h4><h5 id="1-文件目录操作函数">1)文件目录操作函数</h5><p>dir:显示当前工作空间目录文件  dir; dirname;</p><p>files=dir(‘directory’):返回指定目录中的文件信息到结构体file中，结构体file中包含的信息为：name,data,bytes,isdir,datenum</p><h5 id="2-文件编辑调试函数">2)文件编辑调试函数</h5><p>dbstep:从当前断点中执行一行或多行代码 dbstep; dbstep nlines;dbstep in</p><p>dbstop:设置断点  dbstop inmfile ; dbstop in mfile at lineno</p><p>debug:列举出m文件的调试函数</p><p>mlint:检查m文件可能出现的问题，并报告结果—mlint(‘m-filename’)</p><p>profile:调试优化m文件代码—界面Desktop–Profiler</p><h5 id="3-文件脚本函数">3)文件脚本函数</h5><p>function:声明函数  function [out1, out2, …]=funname(in1,in2,…)：定义一个名为funname的函数，该函数输入参数为in1、in2、……输出参数为out1、out2、……</p><p>input:请求用户输入  user_entry=input(‘prompt’) ：在屏幕上显示prompt作为提示，等待键盘输入，并返回用户输入的值。user_entry=input(‘prompt’,‘s’)：将键入的字符返回为文本变量而非变量名或数值。</p><h5 id="4-语句控制函数">4）语句控制函数</h5><p>break:终止执行for循环或者while循环, break语句结束循环，把语句控制返回给循环结束后的语句。</p><p>continue:传递控制给下一个for或while循环</p><p>case:条件为真时执行代码,case是switch语法中的允许有条件执行语句的一部分。case语句块由case函数，case表达式和其后的一条或多条语句构成。</p><p>switch:有条件执行的代码，在基本语法中，当switch_expr ==case_expr时执行相关语句，如果没有实例表达式与switch表达式相匹配，则语句控制传递给otherwise语句块。</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">`method=&#x27;bigger&#x27;;`</span><br><span class="line">`switch method`</span><br><span class="line">`case&#x27;bigger&#x27;`</span><br><span class="line">`a=3;`</span><br><span class="line">`case&#x27;middle&#x27;`</span><br><span class="line">`a=2;`</span><br><span class="line">`case&#x27;small&#x27;`</span><br><span class="line">`a=1;`</span><br><span class="line">`otherwise`</span><br><span class="line">`a=0;`</span><br><span class="line">`end`</span><br></pre></td></tr></table></figure><p>If:如果条件为真，则执行相关语句  if expression, statements, end</p><p>elseif:—if expression1,statement1,elseifexpresstion,statement2,end</p><p>else:如果条件为假时执行语句</p><p>end:终止代码块，或为数组的最后一位数字索引, end用来终止for、while、switch、try和if语句—end函数也作为数组的最后一个索引，如X(3:end)和X(1,1:2:end-1)。可以用end增加数组，如X存在的情况下使用X(end+1)=5。</p><p>error:显示信息并终止函数—error(‘说明信息’)</p><p>for：反复运算指定代码块 forvariable=initval:endval, statements, end</p><p>while:当条件为真时重复执行语句—whileexpression,statement,end</p><p>return:从调用函数中返回</p><h5 id="5-内存控制函数">5)内存控制函数</h5><p>global:声明全局变量  初始化为一个空矩阵</p><p>isglobal:判断一个变量是否是全局变量</p><p>persistent:定义静态全局常量</p><h3 id="第二篇：数据类型函数">第二篇：数据类型函数</h3><h4 id="三-基本数据类型函数">三、基本数据类型函数</h4><h5 id="1-数值函数">1）数值函数</h5><p>double：转换为双精度浮点数</p><p>single:转换为单精度浮点数</p><p>typecast：在不改变数据大小情况下转换数据类型 Y=typecast(X,type)</p><p>​    type可选范围:‘uint8’、‘int8’、‘uint16’、‘int16’、‘uint32’、‘int32’、‘uint64’、‘int64’、‘single’、‘double’</p><p>arrayfun:把函数应用到数组中的每个元素 A=arrayfun(fun, S)应用fun函数到数组S中的每个元素，将结果返回给数组A。</p><p>​    A=arrayfun(fun, S, T, …)</p><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x(1).f1&#x3D;2;x(2).f1&#x3D;3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x(1).f2&#x3D;3;x(2).f2&#x3D;3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result&#x3D;arrayfun(@(x)isequal(x.f1,x.f2),x)</span><br></pre></td></tr></table></figure><p>cast:转变数值数据类型 B=cast(A,newclass)</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`a=int16(2);`</span><br><span class="line">`b=cast(a,&#x27;char&#x27;);`</span><br><span class="line">`cate=class(b)`</span><br></pre></td></tr></table></figure><p>cat:连接数组  C=cat(dim, A,B)–cat(2,A,B)与[A,B]相同，cat(1,A,B)与[A;B]相同</p><p>class:创建对象或者返回对象类型  obj=class(s,‘class_name’)</p><p>find：寻找非零元素的索引和值</p><p>​    ind=find(X)；X可以是逻辑式，返回非零元素的索引</p><p>​    ind=find(X, k, ‘first’) 返回数组X中所有非零元素的前k个元素。</p><p>​    ind=find(X, k, ‘last’) 返回数组X中所有非零元素的后k个元素。</p><p>​    [row,col,v]=find(X,…)返回列向量，行向量，v表示非零值</p><p>isequal ：判断两个对象是否相等 比较结构体是否相等时，结构体中子域的顺序不重要 NaNs在此函数中认识不相等—isequal(A,B,…)相同返回1，不同返回0</p><p>isequalwithequalnans:把NaN视为相等的情况下判断两个数组是否相等</p><h5 id="2-字符串转化数值函数">2）字符串转化数值函数</h5><p>base2dec :把指定进制的数字字符串转换为十进制数 d=base2dec(‘strn’, base)</p><p>bin2dec :把二进制数字字符串转换为十进制数 bin2dec(binarystr)</p><p>hex2dec :把十六进制数字字符串转换为十进制数 d=hex2dec(‘hex_value’)</p><p>hex2num :把十六进制数字字符串转换为双精度浮点数 n=hex2num(S)</p><p>str2double :把字符串转换为双精度浮点数</p><p>str2num :把字符串转换为数字</p><h5 id="3-数值转化为字符串函数">3）数值转化为字符串函数</h5><p>dec2base:把十进制数转换为指定基下的数值字符串 str=dec2base(d, base)</p><p>dec2bin :把十进制数转换为二进制数值字符串</p><p>dec2hex :把十进制数转换为十六进制的数值字符串</p><p>int2str :把整数转换为字符串</p><p>mat2str :把矩阵转换为字符串</p><p>num2str :把数字转换为字符串</p><h4 id="四-高级数据类型函数">四、高级数据类型函数</h4><h5 id="1-结构体函数">1）结构体函数</h5><p>cell2struct :把元胞数组转换成结构体数组 s=cell2struct(c, fields,dim) fields指结构体数组的域名，fields可以说字符数组或者字符串元胞数组。</p><p>size(c,dim)==length(fields)%如果fields是元胞数组 size</p><p>(c,dim)==size(fields,1)%如果fields是字符数组</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`c=&#123;&#x27;Tom&#x27;,&#x27;math&#x27;,80;&#x27;Jane&#x27;,&#x27;math&#x27;,70&#125;`</span><br><span class="line">`feilds=&#123;&#x27;name&#x27;,&#x27;subject&#x27;,&#x27;grade&#x27;&#125;;`</span><br><span class="line">`s=cell2struct(c,fields,2)`</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>struct:创建结构体数组 s=struct(‘field1’, values1, ‘field2’,values2, …)</p><p>struct2cell :把结构体数组转换为元胞数组</p><p>structfun :把函数应用于结构体中的每一个子域 A=structfun(fun, s)</p><h5 id="2-元胞数组函数">2)元胞数组函数</h5><p>cell ：创建元胞数组  c=cell(n)c=cell(m,n)</p><p>celldisp ：显示元胞数组的内容</p><p>cellfun ：把函数应用于元胞数组中的每个元素 A=cellfun(fun, C, D,…)</p><p>cellplot ：以图形形式显示元胞数组的结构</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`c&#123;1,1&#125;=&#x27;2-by-2&#x27;;c&#123;1,2&#125;=&#x27;eigenvalues ofeye(2)&#x27;;`</span><br><span class="line">`c&#123;2,1&#125;=eye(2);c&#123;2,2&#125;=eig(eye(2));`</span><br><span class="line">`cellplot(c)`</span><br></pre></td></tr></table></figure><p>cellstr ：根据字符串数组创建字符串元胞数组</p><p>mat2cell ：把矩阵分割为元胞数组 c=mat2cell(x,m, n)</p><p>num2cell ：把数值数组转变为元胞数组  C=num2cell(A)</p><h5 id="3-字符串函数">3)字符串函数</h5><p>func2str ：根据函数句柄构建函数名称字符串 s=func2str(fhandle)</p><p>char ：把整数数组转化为字符串 S=char(X)</p><p>eval ：执行包含MATLAB表达式的字符串 eval(expression)</p><p>findstr ：在长字符串中寻找匹配的短字符串,返回字符串索引</p><p>sprintf ：把一定格式把数据写入字符串  [s, errmsg]=sprintf(format,A, …)</p><p>strcat ：水平连接字符串  t=strcat(s1,s2, s3, …)</p><p>strcmp,strcmpi ：比较字符串—strcmp(‘str1’,‘str2’)相同返回1，不同返回0</p><p>strings函数：连接字符串name=[‘abc’ ‘def’ ‘ghj’]</p><p>strread ：从字符串中读取指定格式数据</p><p>strrep :发现和替换子字符串  str=strrep(str1, str2, str3) —将str1内的所有子字符串str2替换为str3</p><p>strtrim :删除字符串开头和结尾的空字符</p><p>blanks :创建空格字符串数组</p><p>isletter :判断字符串中字符是否为英文字母</p><p>isspace :判断字符串中字符是否为空格</p><p>isstrprop :判断字符串中是否含有指定类别的字符tf=isspace(‘str’)</p><p>dblank :删除字符串末尾空格</p><h3 id="第三篇：矩阵函数">第三篇：矩阵函数</h3><h4 id="五-数组和矩阵函数">五、数组和矩阵函数</h4><h5 id="1-数组基本函数">1）数组基本函数</h5><p>display：显示字符或者数组</p><p>isempty :判断数组是否为空，空返回1，不空返回0</p><p>isequal :判断数组是否相同 （认为NaN不同）</p><p>isequalwithequalnans:判断数组是否相同，把NaN看成相同的数</p><p>isfinite :判断数组元素是否为有限数</p><p>isfloat :判断数组元素是否为浮点数</p><p>isinf :判断数组元素是否为无限数</p><p>isinteger :判断元素是否为整数</p><p>islogical ：判断元素是否为逻辑变量</p><p>isnan ：判断元素是否为NaN</p><p>isnumeric ：判断数组元素是否为数值</p><p>isscalar ：判断输入是不是离散量</p><p>issparse ：判断矩阵是否为稀疏矩阵</p><p>isvector ：判断输入是否为向量</p><p>length ：计算向量的长度</p><p>max ：找出向量中的最大元素</p><p>C=max(A) A为一个向量，返回向量最大值，矩阵A，返回每列向量最大值</p><p>C=max(A,B) A、B维数一样，返回对应位置最大元素</p><p>max(A,[],dim)</p><p>[C,I]=max(A)找出最大值和索引</p><p>min ：找出向量中的最小元素</p><p>ndims ：计算矩阵的维数  ndims同length(size(x)) 一致</p><p>numel：计算数组中元素的个数或者下标数组表达式的个数</p><p>size ：计算数组维数大小 d=size(X) [m,n]=size(X)m行n列 m=size(X,dim)</p><h5 id="2-数组操作函数">2）数组操作函数</h5><p>bsxfun：两个数组间元素逐个计算 C=bsxfun(fun,A,B)</p><p>@plus(加)@minus（减）@times(数组乘)@rdivide（左除）@ldivide（右除）@power（幂）@max@min@rem（整除）@mod（模除）</p><p>dot :向量点乘 C=dot(A,B)</p><h5 id="3-基础矩阵函数">3）基础矩阵函数</h5><p>create :生成随机数流  [s1,s2,…]=RandStream.create(‘gentype’,‘NumStreams’,n)</p><p>eye :生成单位矩阵 Y=eye([m,n])对角线1，其他0</p><p>ones :生成元素为1的数组 Y=ones(n) Y=ones(m,n)</p><p>rand :生成均匀分布的伪随机数矩阵 r=rand(n) rand(m,n,p,…)</p><p>randi :生成均匀分布的伪随机整数矩阵 randi(imax) r=randi(imax,n)</p><p>r=randi(imax,m,n,p,…) r=randi([imin,imax],…) 例：r=randi([5,10],[2,3])</p><p>randn :生成[-1,1]之间随机分布数矩阵 r=randn(n) randn(m,n)randn(m,n,p,…)</p><p>randstream :生成随机数据流</p><p>set (RandStream) :设置随机数据流属性set(S,‘PropertyName’,Value)</p><p>set(S,‘Property’)</p><h5 id="4-矩阵处理函数">4)矩阵处理函数</h5><p>reshape ：改变矩阵维数  B=reshape(A,m,n)</p><p>sort :把数组元素按升序或降序排列</p><p>B=sort(A,dim) B=sort(…,mode) [B,IX]=sort(A,2)返回B元素在A中的位置的索引</p><p>sortrows :矩阵行按照升序排列</p><h5 id="5-矩阵分析函数">5）矩阵分析函数</h5><p>det :求方阵行列式值</p><p>norm :计算向量或者矩阵范数  n=norm(A) n=norm(A,p)</p><p>normest :返回矩阵2-范数估计值</p><p>null :计算矩阵零空间</p><p>rank :返回矩阵的秩</p><p>subspace :返回两个子空间夹角</p><p>trace :返回矩阵的迹对角元素之和</p><h5 id="6-矩阵特征值函数">6）矩阵特征值函数</h5><p>eig :计算矩阵特征值和特征向量</p><p>condeig :计算特征值对应的条件数</p><p>eigs :计算矩阵的最大特征值和特征向量</p><p>gsvd :矩阵广义奇异值分解</p><p>svd :矩阵奇异值分解</p><h3 id="第四篇-数学函数">第四篇 数学函数</h3><h4 id="六-基本数学函数">六、基本数学函数</h4><h5 id="1-基本运算符">1）基本运算符</h5><p>+：加法运算符</p><p>-：减法运算符</p><p>*：矩阵乘法</p><p>.*：数组乘法</p><p>/：斜杠或者矩阵右除  B/A等于公式B*inv(A)</p><p>./：数组右除  A./B等于A(i,j)/B(i,j)</p><p>\：反斜杠或者矩阵左除  A\B等于inv(A)*B</p><p>.\：数组左除   A.\B等于B(i,j)/A(i,j)</p><p>^：矩阵幂计算</p><p>.^：数组幂计算  A.^B等于A(i,j)的B(i,j)次幂</p><p>’：矩阵转置</p><p>[]：表示空矩阵，A(m,:)删除A中的一行，A(:,n)删除A中的一列</p><p>{}：元胞组赋值</p><p>关系操作符：&lt; &lt;= &gt; &gt;= == ~ =</p><p>逻辑操作符 : 逻辑：&amp;&amp; || 数组：&amp; | ~</p><h5 id="2-数据操作函数">2）数据操作函数</h5><p>sort ：数组元素按升序或降序排列 B=sort(A) B=sort(A,dim) B=sort(…,mode)[B,IX]=sort(A,…)</p><p>sortrows ：把矩阵中每行按照升序排列  B=sortrows(A) B=sortrows(A,column)</p><p>sum ：求数列元素的和  B=sum(A) A是向量，向量求和，A是矩阵就没列求和 B=sum(A,dim)</p><h5 id="3-统计分析函数">3）统计分析函数</h5><p>brush:交互式标记、删除、修改以及保存图片中的观测量位  data brush</p><p>corrcoef ：计算相关性系数 R=corrcoef(X)</p><p>cov ：返回协方差矩阵 cov(x)</p><p>max ：求数组中的最大元素   C=max(A) C=max(A,B) C=max(A,[],dim)</p><p>mean ：求数组的平均数或者均值 M=mean(A) M=mean(A,dim)</p><p>median ：返回数组的中间值 M=median(A) M=median(A,dim)</p><p>mode ：求数组中出现频率最多的值  M=mode(X) M=mode(X, dim)</p><p>[M,F]=mode(X, …)</p><p>std ：计算标准差 s=std(X)</p><p>var ：计算方差 V=var(X)</p><h5 id="4-三角函数">4）三角函数</h5><p>acos ：以弧度的形式返回反余弦值</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`x=-1:.05:1;`</span><br><span class="line">`plot(x,acos(x));grid on`</span><br></pre></td></tr></table></figure><p>acosd ：以角度的形式返回反余弦值</p><p>acosh ：以弧度形式返回反双曲余弦值</p><p>acot ：以弧度的形式返回反余切值</p><p>acotd ：以角度的形式返回反余切值</p><p>acoth ：以弧度的形式返回反双曲余切值</p><p>acsc :以弧度的形式返回反余割值</p><p>acscd :以角度的形式返回反正割值</p><p>acsch :以弧度的形式反双曲余割值</p><p>asec :以弧度的形式返回反正割值</p><p>asecd :以角度的形式返回反正割值</p><p>asech :以弧度的形式返回反双曲正割值</p><p>asin :以弧度的形式返回反正弦值</p><p>asind :以角度形式返回反正弦值</p><p>asinh :以弧度的形式返回反双曲正弦值</p><p>atan :以弧度的形式返回反正切值</p><p>atand :以角度的形式返回反正切值</p><p>atanh :以弧度的形式返回反双曲正切值</p><p>cos :以弧度的形式返回输入的余弦值</p><p>cosd :以角度的形式返回输入的余弦值</p><p>cosh :以弧度的形式返回输入的双曲余弦值</p><p>cot :以弧度的形式返回输入的余切</p><p>cotd :以角度的形式返回输入的余切值</p><p>coth :以弧度的形式返回输入的双曲余切值</p><p>csc :以弧度的形式返回输入的余割值</p><p>cscd :以角度形式返回输入的余割值</p><p>csch :以弧度的形式返回双曲余割值</p><p>sec :以弧度的形式返回输入的正割值</p><p>secd :以角度的形式返回输入的正割值</p><p>sech :以弧度的形式返回双曲正割值</p><p>sin :以弧度的形式返回输入的正弦</p><p>sind :以角度的形式返回输入的正弦值</p><p>sinh :以弧度的形式返回输入的双曲正弦值</p><p>tan :以弧度的形式返回输入的正切值</p><p>tand :以角度的形式返回输入的正切值</p><p>tanh :以弧度的形式返回双曲正切</p><h5 id="5-指数函数">5）指数函数</h5><p>exp ：计算指数</p><p>log ：计算自然对数</p><p>log10 ：计算平凡对数（以10为底）</p><p>log2 ：计算以2为底数的对</p><p>pow2 ：计算以2为底的幂</p><p>nthroot：计算实数值的实n阶方根。y=nthroot(X,n)</p><p>sqrt ：计算平方根</p><p>abs ：计算绝对值和复数模值</p><h5 id="6-除法函数">6）除法函数</h5><p>ceil ：向正无穷方向舍入</p><p>fix ：向零方向舍入</p><p>floor ：向负无穷方向舍入</p><p>idivide ：舍入操作  C=idivide(A,B, opt)</p><p>mod ：计算相除后的模值</p><h5 id="7-排列函数">7）排列函数</h5><p>factorial：阶乘—factorial（N），N！</p><p>perms：元素所有可能的全排列</p><h4 id="七-高级数学函数">七、高级数学函数</h4><h5 id="1-微分方程解函数">1）微分方程解函数</h5><p>decic ：计算和ode15i（ode常微分方程）相容的初始条件</p><p>[y0mod,yp0mod]=decic(odefun,t0,y0,fixed_y0,yp0,fixed_yp0)</p><p>deval ：计算微分方程的解   sxint=deval(sol,xint)  sol是求解器返回的结构体，（ode45, ode23, dde23 xint是点或向量，函数求解的是该点上的值。</p><p>deval :计算微分方程的解   sxint=deval(sol,xint)</p><h5 id="2-极值函数">2）极值函数</h5><p>fminbnd ：在指定区间上求解单变量函数的最小值x=fminbnd(fun,x1,x2)x=fminbnd(fun,x1,x2,options)  结构体options用于指定优化参数</p><p>[x,fval]=fminbnd(…)   [x,fval,exitflag]=fminbnd(…)</p><p>[x,fval,exitflag,output]=fminbnd(…)</p><p>fminsearch ：利用derivative-free算法求无约束多变量函数的最小值</p><p>x=fminsearch(fun,x0)x=fminsearch(fun,x0,options)</p><p>[x,fval,exitflag]=fminsearch(…)</p><p>fzero：求单变量连续函数的零值点 x=fzero(fun,x0) x=fzero(fun,x0,options)</p><p>isqnonneg :求解非负最小二乘法约束问题</p><p>x=lsqnonneg(C,d)返回一个向量x，满足x &gt;= 0时(C*x-d)的范数最小。</p><p>x=lsqnonneg(C,d,x0) x=lsqnonneg(C,d,x0,options)</p><h5 id="3-数值积分函数">3）数值积分函数</h5><p>dblquad ：计算矩形区域的二重定积分</p><p>q=dblquad(fun,xmin,xmax,ymin,ymax)</p><p>q=dblquad(fun,xmin,xmax,ymin,ymax,tol)q=dblquad(fun,xmin,xmax,ymin,ymax,tol,method)</p><p>quad ：求基于变步长Simpson法的函数定积分数值解 q=quad(fun,a,b)</p><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">F&#x3D;@(x)1.&#x2F;(x.^3-2*x-5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Q&#x3D;quad(F,0,2)</span><br></pre></td></tr></table></figure><p>quad2d ：在平面区域求二重积分的数值解  q=quad2d(fun,a,b,c,d)</p><p>实例：Q=quad2d(@(x,y)y.*sin(x)+x.<em>cos(y),pi,2</em>pi,0,pi)</p><h5 id="4-微分积分函数">4）微分积分函数</h5><p>dblquad ：计算矩形区域的二重定积分 q=dblquad(fun,xmin,xmax,ymin,ymax)</p><p>cumtrapz ：累积梯形数值积分 Z=cumtrapz(Y)Z=cumtrapz(X,Y) 对于多维数组从第一维开始计算 Z=cumtrapz(X,Y,dim)</p><p>diff :差分与微分近似 Y=diff(X) Y=diff(X,n) Y=diff(X,n,dim)</p><p>gradient :计算函数数值梯度  FX=gradient(F) [FX,FY]=gradient(F)</p><p>实例：绘制函数z=exp(-x.^2-y.^2)的梯度图形。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">`v=-2:0.2:2;`</span><br><span class="line">`[x,y]=meshgrid(v);`</span><br><span class="line">`z=exp(-x.^2-y.^2);`</span><br><span class="line">`[px,py]=gradient(z,0.2,0.2);`</span><br><span class="line">`contour(v,v,z)`</span><br><span class="line">`hold on`</span><br><span class="line">`quiver(v,v,px,py)`</span><br></pre></td></tr></table></figure><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210926095356.png" alt="image-20210926095340360" loading="lazy"></p><p>trapz :梯形数值积分 Z=trapz(Y) Z=trapz(X,Y) Z=trapz(…,dim)</p><h5 id="5-赋值函数">5)赋值函数</h5><p>biltin:重载方法中执行MATLAB内部自带的函数  builtin(…) 函数和 feval(…)函数相同</p><p>evalc :计算表达式值  T=evalc(S)：同函数eval(S)用法相同</p><p>feval :计算函数值  [y1, y2, …]=feval(fhandle, x1, …, xn)</p><h3 id="第五篇：方程函数">第五篇：方程函数</h3><h4 id="八-插值函数-线性方程解函数和多项式函数">八、插值函数、线性方程解函数和多项式函数</h4><h5 id="1-插值函数">1）插值函数</h5><p>interp1q ：1维快速线性插值法 yi=interp1q(x,Y,xi)</p><p>​    interp1q正常执行条件：</p><p>（1）x单调递增列向量</p><p>（2）Y为列向量or行数为length(x)(3)xi为列向量，如果xi值在x的坐标范围外，返回NaN</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`x=(-5:0.5:5)&#x27;;`</span><br><span class="line">`y=sin(x);`</span><br><span class="line">`xi=(-5:0.5:5)&#x27;;`</span><br><span class="line">`yi=interp1q(x,y,xi);`</span><br><span class="line">`plot(x,y,&#x27;o&#x27;,xi,yi)`</span><br></pre></td></tr></table></figure><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210926095806.png" alt="image-20210926095802196" loading="lazy"></p><p>interp2 ：2维数据插值法</p><p>​    ZI=interp2(X,Y,Z,XI,YI)</p><p>​    ZI=interp2(Z,XI,YI)</p><p>​    ZI=interp2(X,Y,Z,XI,YI,method)</p><p>​    （1）‘nearest’：最邻近插值法；</p><p><img src="C:/Users/49475/AppData/Roaming/Typora/typora-user-images/image-20210926095826309.png" alt="image-20210926095826309" loading="lazy"></p><p>​    （2）‘linear’：线性插值法（默认插值方法）；</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210926100005.png" alt="image-20210926095912064" loading="lazy"></p><p>​    （3）‘spline’：三次样条插值法；</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210926100043.png" alt="image-20210926100040286" loading="lazy"></p><p>​    （4）’cubic’：三次插值法</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210926100104.png" alt="image-20210926100100798" loading="lazy"></p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">`[X,Y]=meshgrid(-2:0.5:2);`</span><br><span class="line">`Z=peaks(X,Y);`</span><br><span class="line">`[XI,YI]=meshgrid(-2:0.125:2);`</span><br><span class="line">`ZI=interp2(X,Y,Z,XI,YI);`</span><br><span class="line">`mesh(X,Y,Z)`</span><br><span class="line">`hold on`</span><br><span class="line">`mesh(XI,YI,ZI+10)</span><br></pre></td></tr></table></figure><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210926100153.png" alt="image-20210926100150073" loading="lazy"></p><p>interp3 ：3维数据插值法</p><p>​    VI=interp3(X,Y,Z,V,XI,YI,ZI)</p><p>​    VI=interp2(X,Y,Z,V,XI,YI,ZI,method)</p><p>​    （1）‘nearest’：最邻近插值法；</p><p>​    （2）‘linear’：线性插值法（默认插值方法）；</p><p>​    （3）‘spline’：三次样条插值法；</p><p>​    （4）’cubic’：三次插值法</p><p>​</p><p>interpft ：基于FFT方法的1维插值法 y=interpft(x,n) y=interpft(x,n,dim)</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">`y=[1 2 3 2 1 23];`</span><br><span class="line">`N=length(y);`</span><br><span class="line">`L=5;`</span><br><span class="line">`M=N*L;`</span><br><span class="line">`x=0:L:L*N-1`</span><br><span class="line">`xi=0:M-1`</span><br><span class="line">`yi=interpft(y,M)`</span><br><span class="line">`plot(x,y,&#x27;o&#x27;,xi,yi,&#x27;*&#x27;)`</span><br></pre></td></tr></table></figure><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210926100231.png" alt="image-20210926100216325" loading="lazy"></p><p>interpn ：n维数据插值（表格查询）VI=interpn(X1,X2,X3,…,V,Y1,Y2,Y3,…)</p><p>meshgrid ：为3维绘图生成X和Y矩阵</p><p>[X,Y]=meshgrid(x,y) [X,Y,Z]=meshgrid(x,y,z)</p><p>ndgrid ：生成可为函数和插值算法使用的n维矩阵</p><p>[X1,X2,X3,…]=ndgrid(x1,x2,x3,…)</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`[X1,X2]=ndgrid(-1:0.1:1,-1:0.1:1);`</span><br><span class="line">`Z=exp(-X1.^2-X2.^2);`</span><br><span class="line">`mesh(Z)`</span><br></pre></td></tr></table></figure><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210926100349.png" alt="image-20210926100345433" loading="lazy"></p><p>pchip ：分段三次厄密插值多项式（PCHIP） yi=pchip(x,y,xi)pp=pchip(x,y)</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">`x=-4:4`</span><br><span class="line">`y=[-3 -2 -2 0 0 0 2 2 3];`</span><br><span class="line">`t=-4:0.01:4;`</span><br><span class="line">`p=pchip(x,y,t);`</span><br><span class="line">`s=spline(x,y,t);`</span><br><span class="line">`plot(x,y,&#x27;o&#x27;,t,p,&#x27;-&#x27;,t,s,&#x27;-.&#x27;)`</span><br><span class="line">`legend(&#x27;data&#x27;,&#x27;pchip&#x27;,&#x27;spline&#x27;,4)`</span><br></pre></td></tr></table></figure><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210926100422.png" alt="image-20210926100418901" loading="lazy"></p><p>spline ：曲线三次样条插值  yy=spline(x,Y,xx)  pp=spline(x,Y)</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`x=0:10;`</span><br><span class="line">`y=cos(x);`</span><br><span class="line">`xx=0:0.1:10;`</span><br><span class="line">`yy=spline(x,y,xx);`</span><br><span class="line">`plot(x,y,&#x27;o&#x27;,xx,yy)`</span><br></pre></td></tr></table></figure><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210926100518.png" alt="image-20210926100515126" loading="lazy"></p><h5 id="2-线性方程解函数">2)线性方程解函数</h5><p>linsolve ：使用部分主元LU因子分解法求解线性方程组  X = linsolve(A,B) [X, R] = linsolve(A,B)  X = linsolve(A,B,opts)</p><p>lscov ：已知协方差时求解方程的最小二乘解</p><p>x = lscov(A,b)  线性方程组A*x = b的一般最小二乘解</p><p>x = lscov(A,b,w)  线性方程组A*x = b的加权最小二乘解</p><p>x = lscov(A,b,V)  线性方程组A*x = b 的广义最小二乘解</p><p>x =lscov(A,b,V,alg)</p><p>bicg ：求解线性方程的双共轭梯度法</p><p>x=bicg(A,b) bicg(A,b,tol)bicg(A,b,tol,maxit)</p><p>bicg(A,b,tol,maxit,M1,M2)bicg(A,b,tol,maxit,M1,M2,x0)[x,flag]=bicg(A,b,…)</p><p>[x,flag,relres]=bicg(A,b,…)[x,flag,relres,iter]=bicg(A,b,…)</p><p>[x,flag,relres,iter,resvec]=bicg(A,b,…)</p><p>bicgstab ：求解线性方程的稳定的双共轭梯度法</p><p>bicgstabl ：求解线性方程的双共轭梯度l稳定法</p><p>bicgstab ：求解线性方程的稳定的双共轭梯度法</p><p>bicgstabl ：求解线性方程的双共轭梯度l稳定法</p><p>cgs ：求解线性方程的共轭梯度平方法</p><p>gmres ：求线性方程的广义最小残差法</p><p>lsqr ：求解线性方程的LSQR 方法</p><p>minres :求解线性方程的最小残差法</p><p>pcg :求解线性方程的预处理共轭梯度法</p><p>qmr :求解线性方程的准最小残差法</p><p>symmlq :求解线性方程的对称 LQ 法</p><p>tfqmr :求解线性方程的自由转置准最小残差法</p><h5 id="3-多项式函数">3)多项式函数</h5><p>polyfit ：多项式拟合</p><p>​    p=polyfit(x,y,n) 根据拟合数据x,y求n阶多项式p(x)的系数，p是系数</p><p>​    [p,S]=polyfit(x,y,n) p是系数，使用S和多项式的值能得到误差估计值或预测</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`x=(-3:0.2:3)&#x27;;`</span><br><span class="line">`y=erf(x);`</span><br><span class="line">`p=polyfit(x,y,3)`</span><br><span class="line">`f=polyval(p,x);`</span><br><span class="line">`plot(x,y,&#x27;*&#x27;,x,f,&#x27;-&#x27;)`</span><br></pre></td></tr></table></figure><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210926101210.png" alt="image-20210926101206088" loading="lazy"></p><p>polyval ：多项式求值   y=polyval(p,x)</p><p>poly ：根据根求解多项式</p><p>polyder ：解析求解多项式微分表达式k=polyder§ k=polyder(a,b)</p><p>polyint ：解析求解多项式积分表达式系数  polyint(p,k)</p><p>mkpp ：构建分段多项式  pp=mkpp(breaks,coefs)</p><p>breaks是一个长度为L+1的向量，该向量元素严格递增。coefs为L*k的矩阵，每行元素代表</p><p>[breaks(i),breaks(i+1)]的k阶多项式的系数。</p><h4 id="十一-基本文件操作函数">十一、基本文件操作函数</h4><h5 id="1-文件创建函数">1）文件创建函数</h5><p>filemaker ：把文件名与文件中函数名分开 。</p><p>filesep ：文件目录分隔。</p><p>fileparts ：把目标文件名拆分成字符串形式输出 。</p><p>tempdir ：返回系统暂存地址名 。</p><p>tempname ：返回系统暂存文件名 。</p><p>fullfile :创建文件名</p><h5 id="2-文件打开-读取-存储函数">2）文件打开、读取、存储函数</h5><p>open:打开文件 —用法：open(‘name’)</p><p>load :将文件导入到MATLABworkspace中。loadfilename load filename X Y Z,</p><p>load-asciifilename ,load-mat filename,load(‘arg1’, ‘arg2’, ‘arg3’, …)</p><p>save:存储文件.save filename, save filename content, savefilename options</p><p>save(‘filename’, ‘var1’, ‘var2’, …)</p><p>daqread ：读数据采集工具箱(.daq)中的文件 。</p><p>​     [data, time, abstime, events, daqinfo]= daqread(‘filename’)</p><p>uiimport :调用文件导入助手</p><h5 id="3-简单文件输入输出函数">3)简单文件输入输出函数</h5><p>fopen ：打开文件。</p><p>​    fid = fopen(filename)</p><p>​    fid = fopen(filename,permission)</p><table><thead><tr><th>Permission值</th><th>打开模式</th></tr></thead><tbody><tr><td>‘r’</td><td>只读模式</td></tr><tr><td>‘w’</td><td>可写入模式，覆盖已有内容</td></tr><tr><td>‘a’</td><td>可写入模式，写入数据到文件末尾</td></tr><tr><td>‘r+’</td><td>可读写模式，</td></tr><tr><td>‘w+’</td><td>可写入模式，覆盖已有内容</td></tr><tr><td>‘a+’</td><td>可写入模式，写入数据到文件末尾</td></tr><tr><td>‘A’</td><td>无自动删除添加</td></tr><tr><td>‘W’</td><td>无自动删除写入</td></tr></tbody></table><p>fclose 关闭文件。status=fclose(fid) ,status=fclose(‘all’)</p><p>fprintf:以指定格式将数据写入文件 。count = fprintf(fid, format, A, …)</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> `x=1:0.1:2;`</span><br><span class="line">. `y=[x,sin(x)];`</span><br><span class="line">3. `fid=fopen(&#x27;sin.txt&#x27;,&#x27;wt&#x27;);`</span><br><span class="line">4. `fprintf(fid,&#x27;%5.2f %5.6f\n&#x27;,y);`</span><br><span class="line">5. `fclose(fid)`</span><br></pre></td></tr></table></figure><p>fscanf ：以指定格式读取文件中的内容 。A =fscanf(fid, format) , [A,count] = fscanf(fid, format, size)</p><p>fread ：读取文件中的二进制数据 。A =fread(fid, count ,precision, skip, machineformat)</p><p>fwrite ：将二进制数据写入到文件中 。</p><p>fseek ：设置文件位置指针 。status = fseek(fid,offset, origin)</p><p>ftell ：获取文件位置指针 。position = ftell(fid)</p><p>fwind ：把文件位置指针移动到文件起始位置 。fwind(fid)</p><p>fgetl ：按行读取文件内容，并删去换行符 。tline = fgetl(fid)</p><p>fgets ：按行读取文件内容，并保留换行符 。tline = fgets(fid, nchar)</p><p>frewind ：将文件指针移到文件的起始位置。 frewind(fid)</p><p>feof ：测试是否为文件的末尾 。message = ferror(fid)</p><p>ferro ：测试文件输入输出是否有错误 。message = ferror(fid,‘clear’) , [message,errnum] = ferror(…)</p><p>disp ：将目标文件所包含的信息以不同形式显示，如文本、数组等形式。</p><p>disp(obj)</p><h5 id="4-电子表格操作函数">4)电子表格操作函数</h5><p>xlsfinfo ：检测文件中是否包含Microsoft Excel电子表格文件 。</p><p>typ = xlsfinfo(filename) [typ,desc, fmt] = xlsfinfo(filename)</p><p>xlsread ：读Microsoft Excel电子表格文件中的内容 。</p><p>num = xlsread(filename)，num = xlsread(filename,sheet)，num =xlsread(filename, range)，num = xlsread(filename, sheet, range, ‘basic’)</p><p>[num,txt,raw,X]=xlsread(filename,sheet, range, ‘basic’)</p><p>xlswrite :将数据写入Microsoft Excel电子表格文件中 。</p><p>xlswrite(filename, M)，xlswrite(filename, M, sheet, range)，</p><p>[status, message] = xlswrite(filename, …)</p><p>wk1finfo ：检测文件中是否包含Lotus 1-2-3 WK1电子表格。</p><p>[extens, typ] = wk1finfo(filename)</p><p>wk1read ：读取Lotus 1-2-3 WK1电子表格文件 。</p><p>M = wk1read(filename) ，M = wk1read(filename,r,c,range)</p><p>wk1write ：将数据写入Lotus1-2-3 WK1电子表格文件中 。</p><p>wk1write(filename,M,r,c)</p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;center&gt;   &lt;/center&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>MATLAB基础__软件初展望</title>
    <link href="https://www.darkfox.top/posts/305021c5/"/>
    <id>https://www.darkfox.top/posts/305021c5/</id>
    <published>2021-09-25T07:44:25.000Z</published>
    <updated>2021-09-25T08:11:16.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://fastly.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center>   </center><span id="more"></span><h3 id="matlab最基础教程-零-：基本数学概念"><strong>MATLAB最基础教程（零）：基本数学概念</strong></h3><p>前言：matlab只是个软件，用来完成相关数学的计算，而如何安排这些计算，需要用户掌握最基本的数学概念。如果不理解相关的数学概念，则自然不会使用这个软件。</p><h4 id="1-数值与符号"><strong>1.数值与符号</strong></h4><p>如果给工程数学问题分类，最大的两类肯定是数值问题和符号问题，对应matlab的数值运算和符号运算。简而言之，数值运算就是所有的变量的值已知，求解的也是一些具体的值；符号运算则刚好相反，不要求所有的变量都已知，求解的结果也不是变量具体的值，而是变量之间的关系。一个简单的例子是<br>①数值问题：求解一元二次方程，<strong>ax2+bx+c=0</strong>，其中<strong>a=b=c=1</strong>，所求得的结果一定是<strong>x=几点几+几点几i</strong>，是个复数，是个具体的数值。<br>②符号问题：求解一元二次方程，<strong>ax2+bx+c=0</strong>，所求的的结果一定是<strong>x=求根公式</strong>，是abc的函数，是个关系<br>可见，一个问题是数值问题还是符号问题，很大程度上决定于结果需要求解的是数值还是关系。当然两个问题也可以相互转化，比如数值问题的一元二次方程，我们一般会先转化成符号问题，把abc代入求根公式，求出来变量x的具体数值。但实际中，一般我们并不推荐这样做，原因是matlab的数值和符号是完全不同的两套系统，相互转化不仅需要多余的数值符号转换语言，更可能带来查错的不便。</p><h4 id="2-典型数值问题"><strong>2.典型数值问题</strong></h4><p>以下是常见的数值问题，文中提到的解法均可在数值计算、科学计算、数值算法这类书中找到。</p><h4 id="2-1代数方程"><strong>2.1代数方程</strong></h4><p>代数方程又分为线性方程和非线性方程，线性方程一般可以转化为矩阵形式<strong>AX=b</strong>，对A求逆即可。求逆的数值解法一般有高斯赛德尔迭代，超松弛迭代等。非线性方程一般转化为<strong>f(x)=zeros</strong>其中x是个向量，右侧的<strong>zeros</strong>表示<strong>f</strong>是个多输出函数，数值解法一般是迭代，常见的有牛顿迭代，最速梯度，点斜式等。</p><h4 id="2-2常微分方程"><strong>2.2常微分方程</strong></h4><p>常微分方程一般转化为<strong>Dy=f(y,t)，且y(0)=y0</strong>是初始条件，其中<strong>y和Dy都是向量</strong>，f也是个多输出函数，数值解法有<strong>欧拉法，龙格库塔法</strong>。</p><h4 id="2-3偏微分方程"><strong>2.3偏微分方程</strong></h4><p>偏微分方程比较复杂，matlab处理偏微分方程也不专业，我也几乎不用matlab处理这类问题。但工程数学上，偏微分方程的解法有两类，差分法和有限元法。差分法需要采用中心差分，迎风差分等。有限元需要计算刚度矩阵等。</p><h4 id="2-4插值和拟合"><strong>2.4插值和拟合</strong></h4><p>插值和拟合是完全不同的两个数学概念，虽然很多时候很多人都混淆了。两者的描述都可以归结为：已知函数上的点**(x1,y1),(x2,y2)…(xn,yn)<strong>，求一个已知的</strong>x**，对应的<strong>y</strong>的数值。插值常用的<strong>多项式插值，三次样条插值</strong>。拟合的本质是一个<strong>最优化</strong>问题，其中最常用的一种拟合是线性拟合，求解方法是最小二乘法。</p><h4 id="2-5离散周期傅里叶变换"><strong>2.5离散周期傅里叶变换</strong></h4><p>严格说来，这并不能算一个数学问题，只是一种运算方式，就好像加减乘除一样。特殊性在于这种变换是对于一个向量进行，且运算后的结果依然是个向量。这里提出来是为了强调这种傅里叶变换的限定，要求是离散周期，这也是数值方法能处理的唯一一种傅里叶变换。</p><h4 id="2-6最优化问题"><strong>2.6最优化问题</strong></h4><p>最优化问题比较宽泛，一般可以归结为求目标函数f(x)的最大或者最小值，其中f是一个单输出的函数，x是一个向量。其中x需要满足线性约束条件、非线性约束条件、上下界。具体的解法有<strong>最速梯度，遗传，蚁群，退火等算法</strong>。</p><h4 id="2-7数值积分"><strong>2.7数值积分</strong></h4><p>已知函数上的点(x1,y1),(x2,y2),…(xn,yn)，求函数在x1到xn的定积分。常见算法有矩形公式，梯形公式，辛普森公式。类似的问题还有数值求导。</p><h4 id="3-典型符号问题"><strong>3.典型符号问题</strong></h4><p>以下是常见的符号问题，需要特别指出的是，无解问题。数值问题中也有一部分无解问题，但大多数工程中是碰不到的。而符号问题恰好相反，绝大部分我们遇到的符号问题都是没有解的，或者准确的说，没有解析解。比如求一元五次方程，我们知道x和这些系数存在关系，但无法写出显式的表达式，也就是说没有解析解。</p><h4 id="3-1递推转通项"><strong>3.1递推转通项</strong></h4><p>这个问题可以归结为：已知<strong>xn+1=f(xn)，求xn</strong>，常见于数列的推导。</p><h4 id="3-2代数方程"><strong>3.2代数方程</strong></h4><p>区别于数值问题中的代数方程， 这里的代数方程问题可以描述为：<strong>f(x,c)=0，求x=x©</strong>，这里需要求解的其实是x和c的关系。</p><h4 id="3-3常微分方程"><strong>3.3常微分方程</strong></h4><p>区别于数值问题中的常微分数方程， 这里的代数方程问题可以描述为：<strong>Dy=f(y,t,c)，求y=x(t,c)</strong>，一般无需初值条件。</p><h4 id="3-4符号积分"><strong>3.4符号积分</strong></h4><p>区别于数值问题中的数值积分，这里的符号积分可以描述为：已知函数关系<strong>y=f(x)</strong>，求<strong>y</strong>的不定积分。同样的问题还有符号求导。</p><h3 id="matlab最基础教程-一-：软件基本概念">matlab最基础教程（一）：软件基本概念</h3><h4 id="1-matlab的界面-汉化的可略过"><strong>1.matlab的界面</strong>（汉化的可略过）</h4><p>左上角，home标签下，找到layout进行设置/复位，可以设置各板块的显示与隐藏。其中有几个部分，请务必要显示<br>①<strong>Current Folder</strong>：中文一般翻译成工作路径，一般设置成一个自己建立的、有读写权限的文件夹，例如我的文档下建立一个matlab文件夹<br>②<strong>Command Window</strong>：字面意思是命令窗口，用来运行代码，所有的代码都是在这里输入<br>③<strong>Workspace</strong>：字面意思是工作空间，其实就是暂存所有运行结果的地方，“暂”的具体含义是：关闭matlab后丢失</p><h4 id="2-软件中的基本概念"><strong>2.软件中的基本概念</strong></h4><h5 id="2-1-函数"><strong>2.1 函数</strong></h5><p>matlab之所以强大，就是因为提供大量的函数，你也可以建立自定义函数，方法是：Home-&gt;New-&gt;function。自定义函数一般保存在工作路径下。函数文件的特征是：扩展名m，内容的第一行以function开头，后续内容是“输出变量=函数名(输入变量)”。且函数名和文件名相同。<br>每个函数在Command Window中运行，用来完成特定的计算任务，运行方式是输入“输出变量=函数名(输入变量)”，然后按回车。例如有个系统自带的函数是用来求绝对值的，函数名abs，所以在Command Window里输入“a=abs(-1)”，就会显示运算结果为“a=1”。且运算结果会在Workspace里出现一个变量a，双击后可看到a的值是1。</p><h5 id="2-2-脚本"><strong>2.2 脚本</strong></h5><p>可以理解为特殊的函数，这种函数内容的开头没有function那行，因此没有输入、输出变量，也没有函数名。文件扩展名和函数一样是m，也需要在Command Window里运行。脚本都是用户建立的，方法是：Home-&gt;New Script。一般保存在工作路径下。脚本的功能就是完成用户需要的、复杂的计算任务，通常脚本里会调用很多函数。</p><h5 id="2-3-gui"><strong>2.3 GUI</strong></h5><p>一般翻译为界面，就是人机交互界面的意思。写脚本处理问题的方法有点麻烦，让人看起来更像是码农，所以现在很多问题可以通过界面点点鼠标解决。这时候就需要打开界面，打开方法是：在APPS标签里可以找到所有已安装的GUI工具，单击即可。注意右边有个小三角可以点开。和函数一样，用户也可以自己建立自定义GUI，这部分较为复杂，对新手而言有点遥远。</p><h5 id="2-4-toolbox"><strong>2.4 toolbox</strong></h5><p>一般翻译成工具箱，matlab将功能相近或者应用上自成体系的一组函数和GUI打包成一个toolbox。正版的matlab在购买时，几乎每一个toolbox都是要单独收费的，所以toolbox也可以理解为matlab产品的模块，一个工具箱就是一个产品/商品。</p><h5 id="2-5-simulink-仿真"><strong>2.5 simulink</strong>（仿真）</h5><p>一般用matlab解决问题的过程是：用户自定义脚本，在Command Window里运行脚本。而脚本的运行逻辑是顺序执行，和一般的编程一样。simulink则提供另一种思路，图形化编程，有点像labview，这种方法很适合于物理模型的仿真，因此有时用“matlab编程”和“simulink仿真”强调。使用方法是在home标签下点击simulink。</p><h4 id="3-获得帮助"><strong>3.获得帮助</strong></h4><p>常用的获得帮助有四种方法<br>①home标签里，有个Help标志，点开后可以获得各工具箱/产品的完整帮助文档。新版本中默认使用在线，改用本地帮助的办法是在home标签里，Preferences下的matlab/Help里选择installed locally<br>②cn.mathworks.com官网上找到支持，然后可以获得教程。这种方法获得的帮助文档和第一种方法一样。<br>③在Command Window里输入 doc+函数名 来获得帮助。比如输入&quot;doc fft&quot;可以获得离散傅里叶变换函数fft的帮助和范例。这种方法获得的文档是前两种方法文档中的部分。当然，前提是你要知道函数名，才能找到帮助。这种方法适合于获得系统自带函数的使用说明。<br>④使用GUI时，通常界面的角落里有Help，点开可以获得帮助。这种方法获得的文档是第一和第二种方法文档中的部分。这种方法适合于获得系统自带GUI的使用说明。<br>这几种方法中，最常用的是第三种，只要知道自己需要的函数名，就可以用这种方式获得说明和范例。而实际使用中，一般常用的系统自带函数，也并不是非常多，大概几十个？真正需要牢记使用方法的可能就几个，通常都是知道函数名，要用的时候doc一下。</p><h3 id="matlab最基础教程-二-：变量类型与赋值"><strong>matlab最基础教程（二）：变量类型与赋值</strong></h3><p>前言：matlab解决问题的最基本思路是建立脚本文件，那么脚本文件的第一段就是定义一些变量，这和C语言等编程思想是一样的。matlab提供的变量类型很多，最基础的是三种：数值变量、符号变量、字符串，其他的类型还有cell、table等。这里仅说明最基础的变量类型。</p><h4 id="1-数值变量"><strong>1.数值变量</strong></h4><p>matlab中所有的数值变量都是矩阵，赋值时，以方括号作为开头和结尾，以英文逗号或空格分割同行元素，以英文分号分割各列。例如在Command Window里输入<br><strong>a=[1 2;3 4]</strong>* *可以看到运算结果，a是一个数值变量。同时workspace里出现一个田字形的变量a，说明变量a的类型是数值型。</p><p>向量和数字可以视为特殊的矩阵，例如</p><ol><li><strong>a=[1 2]</strong></li><li><strong>a=[1;2]</strong></li></ol><p>分别是行向量和列向量，<strong>a=[1]<strong>可以简写为<br><strong>a=1</strong> 是数字。<br>数值变量的命名要求是英文字母开头，不能包含特殊符号，大小写敏感。这里推荐采用下划线来进行分割，例如</strong>value_of_A</strong>，这和其他编程语言的命名规则大体相当。<br>赋值中，有时需要用到等差数列，例如定义一个向量<strong>a=[1 2 3]</strong>，如果比较长，赋值很麻烦，所以matlab提供了一个简单的方法<br>**a=[1:1:3]**这里两个冒号的意思是起始值:步长:终值。采用这种赋值方式时可以获得一个等差数列行向量，并可以省略两侧的方括号。当步长为1时，可以省略步长和一个冒号，于是可以简写为<br><strong>a=1:3</strong> 另一种灵活的赋值方法是分块矩阵，其方法是变量名后面加圆括号，圆括号中加序号。例如</p><ol><li><strong>a=[1 2;3 4]</strong></li></ol><p>定义变量a之后，<br><strong>b=a(1,2)</strong> 就可以把a的第一行第二列元素赋值给b，当然也可以用<br><strong>a(1,2)=1</strong> 来修改矩阵中部分元素的值。这里需要注意，序号必须是自然数，且不能是零。当矩阵中有多个元素需要赋值时，可以将序号部分改成向量，例如<br><strong>a([1 2],[1 2])=[1 2;3 4]</strong> 中把行数和列数都用向量表示，就是说对矩阵a的第1和2行，第1和2列，总共4个元素赋值。更进一步，也可以有**a([1 2],1)**表示a的第一列，也可以写成<br>**a(1:end,1)**这里的end表示终点，即a的行数2，也可以更进一步简写成<br>**a(:,1)**这里的冒号表示从头至尾。这类赋值方法最为常用，但基本的语法非常简单，方括号表示矩阵开头和结尾，圆括号表示从矩阵中选取部分，把握这个原则，有利于读懂程序。<br>当然分块矩阵也可以<br>**b=[a a]**这样的赋值方法，但需要注意的是，方括号中的元素必须满足矩阵的行列数要求，例如</p><ol><li><strong>a=[1 1]</strong></li><li><strong>b=[1;1]</strong></li><li><strong>c=[a b]</strong></li></ol><p>就会引起错误，因为此时matlab无法确定c的行列数。</p><h4 id="2-符号变量"><strong>2.符号变量</strong></h4><p>总体而言，符号变量比数值变量简单得多，因为变化非常少，常用的赋值命令是<br>syms a b这里syms表示这里要定义一些符号变量，a和b是变量名，符号变量的命名规则和数值变量一样。有时候也采用<br>syms a real来强调a是实数变量，具体可以doc syms来获得帮助。<br>有些变量之间存在依赖关系，此时可以定义<br>syms x y(x) 这里声明x是一个符号变量，又声明y是一个符号变量，且y的值由x决定，这相当于数学中函数的概念。当然具体的函数关系并没有明确规定。也可以<br>syms x y z(x,y)来定义符号变量z，z依赖x和y。这相当于二元函数的概念。这里的圆括号显然和数值变量中的圆括号含义完全不同，这也是学习matlab最不习惯的地方，同一个符号，由于变量类型不同会有完全不同的含义。所以在学习matlab的过程中，一定要区分数值变量和符号变量。<br>上述方法定义的符号变量是一个数，或者1*1矩阵，matlab中也可以定义符号矩阵，例如</p><ol><li><strong>syms a11 a12 a21 a22</strong></li><li><strong>A=[a11 a12;a21 a22]</strong></li></ol><p>就可以获得一个矩阵符号变量A。<br>定义符号变量后，workspace中出现相应的变量名，图形不是数值变量的田字形，而是方框里有个立方体，双击后可以看到行列数。</p><h4 id="3-字符串"><strong>3.字符串</strong></h4><p>比数值、符号更为简单的就是字符串了，其定义方法是以单引号开头和结尾，例如<br><strong>a='hello world’<strong>就定义了一个字符串</strong>a</strong>，其值为<strong>hello world</strong>。matlab中较为特殊的是，字符串可视为行向量，例如</p><ol><li><strong>b='hello '</strong></li><li><strong>c='world’</strong></li><li><strong>a=[b c]</strong></li></ol><p>也可以获得字符串a，其值为你好世界。另外，有时也可以将字符串视为矩阵，例如<strong>a=[‘ab’;‘cd’]<strong>但这种用法很罕见，同时要求各行字符串长度一样，否则将违反矩阵行列数规定。当然字符串的值也可以是特殊符号，比如’,'就定义了逗号，而最特殊的就是定义单引号，因为单引号会和字符串定义中的单引号混淆，因此matlab中用两个单引号表示一个单引号，也就是</strong>a=’’’'<strong>表示a是一个字符变量，值是一个单引号。语句中第一和第四个单引号是字符串类型的开头和结尾，中间两个单引号用来表示一个单引号。定义字符串变量后，workspace中出现相应的变量名，图像是方框里写了</strong>ch</strong>，双击后可以看到行列数。</p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">本文转载自互联网，遵从转载条约</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>PWM与PFM</title>
    <link href="https://www.darkfox.top/posts/aeef000a/"/>
    <id>https://www.darkfox.top/posts/aeef000a/</id>
    <published>2021-09-24T01:50:48.000Z</published>
    <updated>2022-03-20T06:03:28.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://fastly.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center>   </center><span id="more"></span><h3 id="pwm-和-pfm">PWM 和 PFM</h3><p>PWM 不是用来调节开关式转换器输出电压的唯一技术。 这种技术不是通过改变固定频率方波的占空比来调节电源输出，而是采用恒定占空比，然后以调制方波频率方式来实现调节。 采用恒定导通和关断时间控制方式的 DC/DC 电压转换器是 PFM 架构的典型例子。</p><p>另外一个 PFM 例子就是所谓的滞后电压转换器。这种转换器采用一种简单调节方法，使 <a href="http://www.elecfans.com/tags/mosfet/">MOSFET</a> 能根据转换器检测到的输出电压变化导通和关断。 这种架构使输出电压在设定点左右往连续摆动，因此有时也称作“纹波稳压器”或“双滞环控制器”。 滞后作用用于保持预期运行，避免开关抖动。 因为滞后架构会根据<a href="http://www.hqpcb.com/">电路</a>的运行情况改变 MOSFET 的驱动信号，所以开关频率会改变。</p><p>PFM 架构在 DC/DC 转换方面确实拥有一定的优势，具体包括更优的低功耗转换效率、更低的总解决方案成本和简单的转换器拓扑结构，这种架构不需要控制环补偿网络，但由于一些明显的不足而不及 PWM 受欢迎。</p><p>首先是 EMI 控制。 相对于工作频率范围宽的器件，固定开关<a href="http://www.elecfans.com/tags/%E9%A2%91%E7%8E%87%E8%BD%AC%E6%8D%A2%E5%99%A8/">频率转换器</a>的滤波电路更易于设计。 第二，PFM 架构容易在输出端导致更大的电压纹波，进而给被供电的敏感性硅器件造成问题。 第三，低频（或甚至频率为零）的 PFM 会增加开关转换器的瞬态响应时间，导致一些便携式应用响应缓慢，引起客户不满。</p><p>然而，将 PWM 架构的优点与单晶片“双模式”开关转换器中的 PEM 器件的优点相结合，制造商能为我们提供在整个运行范围内具有高效率的解决方案。 与 PFM 有关的 EMI 问题已大大缓解，此类干扰的根本原因是高电流和高电压条件下的快速切换，反之，在双模式芯片中，仅在低电流和低电压运行时才会变频运行。</p><h4 id="开关稳压器中的能量损耗"><a href="http://www.elecfans.com/tags/%E5%BC%80%E5%85%B3%E7%A8%B3%E5%8E%8B%E5%99%A8/">开关稳压器</a>中的能量损耗</h4><p>最常见的开关设备调压技术是采用<a href="http://www.elecfans.com/tags/%E6%8C%AF%E8%8D%A1%E5%99%A8/">振荡器</a>和 PWM 控制器产生方形脉冲波， 这种方波会按照通常为数百兆赫兹范围内的一组频率，对装置的内部 MOSFET（或者同步设备中的 MOSFET）进行切换操作。 （如果不考虑更严重的电磁干扰 ［EMI］，就允许采用体积越小的<a href="http://www.hqchip.com/app/868">磁性元件</a>。） 稳压器的输出电压与 PWM 波形占空比成比例关系。</p><p>这种技术一般情况下运行良好，但低频时效率降低。 要了解其中原因，就需要考虑那里出现损耗，即稳压器输入端吸取的能量没有传输至输出端的负载。</p><p>开关稳压器有四大损耗源。 首先是对 MOSFET 栅极<a href="http://www.elecfans.com/tags/%E7%94%B5%E5%AE%B9/">电容</a>进行充放电所用的能量造成的动态损耗，这是<a href="http://www.elecfans.com/tags/%E6%99%B6%E4%BD%93%E7%AE%A1/">晶体管</a>高频运行时的最大损耗。 电流流经漏源通道且该通道上压差显著时发生开关损耗。 当功率开关元件的近零通道<a href="http://www.hqchip.com/app/dianzudianrongdiangan">电阻</a>流过高电流时，会出现其它 MOSFET 损耗。 （这就是功率元件制造商努力减小产品“导通电阻”的原因。）</p><p>除开关元件外，开关稳压器电路中的无源器件也容易出现低效率。 <a href="http://www.elecfans.com/tags/%E7%94%B5%E6%84%9F%E5%99%A8/">电感器</a>损耗包括导通（绕组中）损耗和<a href="http://www.hqchip.com/app/523">磁芯</a>损耗。 <a href="http://www.elecfans.com/tags/%E7%94%B5%E5%AE%B9%E5%99%A8/">电容器</a>损耗通常与元件的等效串联电阻 （ESR） 有关，并由器件的电容大小、运行频率和负载电流决定。</p><p>开关稳压器有两种实施方法。 工程师可以利用分立元件从零开始构建一个开关稳压器，或者在 <a href="http://www.elecfans.com/tags/te/">Te</a>xas Instruments、<a href="http://www.elecfans.com/tags/linear/">Linear</a> Technology 和 <a href="http://www.elecfans.com/tags/fairchild/">Fairchild</a> Semiconductor 等主要半导体供应商提供的许多种转换器 IC 中，为他们的电源选择一种，然后构建一个开关稳压器。 模块的优势在于其设计过程简化。 （请参见 TechZone 中的《DC/DC 稳压器：如何在分立式和<a href="http://www.hqchip.com/app/1022">模块化</a>设计之间选择》</p><p>然而，转换器 IC 本身会增加开关稳压器的总损耗。 例如， 一些能量需要为<a href="http://www.elecfans.com/tags/%E6%94%BE%E5%A4%A7%E5%99%A8/">放大器</a>、<a href="http://www.elecfans.com/tags/%E6%AF%94%E8%BE%83%E5%99%A8/">比较器</a>和基准提供内部偏置电流，但 IC 的主要损耗与 PWM 控制器的内部振荡器和驱动电路有关。 相对来讲，此类损耗在开关稳压器驱动高负载时不明显，但随着负载减小，与开关动作和外部无源器件有关的损耗会降低，而与转换器有关的损耗则保持不变。</p><p>这种情况有时会让便携式产品设计人员进退两难。 面临压力的工程师会想方设法控制<a href="http://www.elecfans.com/dianyuan/603907.html">电池</a>预算，因此选择一款高效率开关稳压器（如与<a href="http://www.elecfans.com/tags/%E7%BA%BF%E6%80%A7%E7%A8%B3%E5%8E%8B%E5%99%A8/">线性稳压器</a>比较）似乎是一种再明显不过的选择。 （参见 TechZone 中的《延长<a href="http://www.elecfans.com/d/725725.html">锂离子电池</a>续航时间的设计方法》） 然而，便携式产品在低功耗“待机”或“休眠”模式下时间相当长，其中，对开关转换器的要求则比较温和，且开关稳压器的运行效率相对较差。</p><p>典型的手持式设备在完全运行时的电流消耗约为 1 安培，但在待机或者休眠模式下则小于 1 毫安。 考虑到转换 IC 保持运行状态时就需消耗多达几个毫安的电流，低负载条件下的低转换效率会让人有些感到意外，因为稳压器总负载电流中相当大的一部分是静态电流。</p><h4 id="提升能效">提升能效</h4><p>为解决主要损耗问题（即与 PWM 控制器的内部振荡器和驱动电路有关的损耗），设计人员可在市面上的多种双模式开关转换器中选择一种。 这些器件融合了正常 PWM 运行功能 PFM 技术（在 PWM 模式下运行时，这种技术的可变频率通常远低于正常固定频率）</p><p>双模式开关转换器在中等到高电流之间运行时，进入连续导通模式（因此，<a href="http://m.elecfans.com/article/570177.html">电感</a>器中的电流永远不会降为零）。 负载电流减小时，转换器会切换至断续模式（当电感器中的电流由于轻负载确实降为零时）。 负载非常轻时，转换器进入 PFM（有时被制造商称作“省电模式 ［PSM］”）。 其他供应商会通过完全停止振荡器将变频运行的优势发挥到极致（通常指“脉冲跳跃”）。</p><p>应指出，低负载时使用 PFM 并不表示开关转换器使用了 PFM 架构，而是使用了能够在需要时利用 PFM 运行功能的 PWM 架构。</p><p>轻负载条件下，开关转换器的输出电容器能在开关脉冲的间隔时间内保持输出电压一段时间。 理想情况下，振荡器在空载时可完全关闭，且输出电压由于输出电容器的充满状态将保持恒定。 然而，寄生损耗会消耗电容器电能，且电路要求功率开关至少具有偶发脉冲，以保持调节过程中的稳压输出。</p><p>在 PFM 运行期间，输出功率与脉冲链的平均频率成比例，并且输出电压低于由反馈控制回路测得的设定输出电压时，转换器开始工作。 然后，转换器的开关频率持续升高，直到输出电压达到由设定输出电压和高于设定输出电压 0.8 - 1.5% 的电压值确定的范围内（如图 1 所示）。</p><p><a href="http://file.elecfans.com/web1/M00/82/EB/pIYBAFw-c7KAaus3AADJPAYucSU974.jpg"><img src="http://file.elecfans.com/web1/M00/82/EB/pIYBAFw-c7KAaus3AADJPAYucSU974.jpg" alt="PFM的工作原理、优势及集成功率芯片中实现PFM技术" loading="lazy"></a></p><p>图 1：PFM 改变稳压器的固定占空比脉冲链频率，以满足负载要求。</p><h4 id="pfm-操作的负面影响">PFM 操作的负面影响</h4><p>由于需要一个容差频带（非固定点）来检测功率开关何时再次导通，因此在开关转换器切换至 PFM 模式时能经常观察到输出电压纹波增加。 如采用较窄容差频带，转换器会提升开关频率，造成省电能力减弱。 工程师必须在提升低负载能效和提升输出电压纹波之间找到平衡点。 图 2a 和 2b 所示分别为 PWM 和 PFM 模式下的开关转换器运行时的电压纹波差异。</p><p><a href="http://file.elecfans.com/web1/M00/82/6C/o4YBAFw-c5GAc79YAAIuPMw78FE428.jpg"><img src="http://file.elecfans.com/web1/M00/82/6C/o4YBAFw-c5GAc79YAAIuPMw78FE428.jpg" alt="PFM的工作原理、优势及集成功率芯片中实现PFM技术" loading="lazy"></a></p><p>图 2：PWM 模式 （a） 和 PFM 运行 （b） 的电压纹波（感谢 Analog Devices 提供数据）。</p><p>在负载过渡期间，任何开关转换器都会在高负载向低负载过渡时出现某种程度的过冲，或者由低负载向高负载过渡时出现下冲。 转换器在 PSM 模式运行时，负载水平已很低，因此下一次负载过渡就是从低电流过渡到高电流（通常对应于由休眠向激活模式过渡）。 稳压器输出端的负载提升经常会造成持续“输出电压陷”，直至转换回路有时间对其做出响应。</p><p>一些开关转换器具有将这种电压陷降至最低的措施。 <a href="http://www.elecfans.com/tags/ti/">TI</a> 的 TPS62400 采用“动态电压定位”功能。 PSM 运行期间，输出电压设定点会稍有提升（如，提升 1%），以预计考虑负载突然升高时发生的即时电压瞬间下降。 这样会防止输出电压在初始负载过渡时跌落至所需的调节窗口以下。</p><p>一些器件还具有增强功能，可用于对良好瞬态响应（PWM 模式下最佳）和低功耗（PSM 模式下最佳）之间的所做的让步进行平衡。 这种增强功能是一种间歇模式，工程师可对瞬态响应比 PSM 具有更优、能效比 PWM 更高的转换器 IC 使用 I²C 指令来实现。 对于从高负载向如休眠模式之类轻负载转换的系统，这种中间模式是一种很好的选择。</p><h4 id="商业芯片中的-pfm">商业芯片中的 PFM</h4><p>低负载下的 PFM 运行能将 IC 静态电流从数个 mA 降至几个 μA。 图 3 所示为 TPS62400 开关转换器在 PWM 模式下运行时相比轻负载 PSM 的功率转换效率。</p><p><a href="http://file.elecfans.com/web1/M00/82/EB/pIYBAFw-c7SAfFq4AAIhNxQqQ3U328.jpg"><img src="http://file.elecfans.com/web1/M00/82/EB/pIYBAFw-c7SAfFq4AAIhNxQqQ3U328.jpg" alt="PFM的工作原理、优势及集成功率芯片中实现PFM技术" loading="lazy"></a></p><p>图 3：对 TI TPS62400 执行 PSM 时的能效提升。</p><p>由图 3 可知，尽管 PWM 模式能保持高于 100 mA 的良好能效，但采用 PSM 后能在负载电流低于 1 mA 的情况下将效率提升至 80 - 90% 之间。 如果转换器在如此轻的负载期间在 PWM 模式下运行，其运行电流将明显高于负载电流，从而造成非常差的转换效率（远低于 30%）。</p><p>Analog Devices 提供多种采用 PSM 的开关转换器。 进入这种模式时，PWM 稳压级导致的偏移使输出电压持续升高，直至达到比 PWM 稳压级高 1.5% 的值，在该点处，PWM 运行停止：两个功率开关均关断并进入空载模式。 在 VOUT 降至 PWM 稳压值前，允许电容器放电。 然后，转换器会驱动电感器，使 VOUT 再次上升至阈值上限。 只要负载电流低于 PSM 电流阈值，该过程就会重复。</p><p>公司的 TPS7A8300 稳压器采用 PSM，以便在 2.3 V 输入电压和 10 mA 输出电流条件下，将效率从 40% 提升至 75%。 该芯片是一款 3 MHz <a href="http://www.elecfans.com/tags/%E9%99%8D%E5%8E%8B%E8%BD%AC%E6%8D%A2%E5%99%A8/">降压转换器</a>，能在高达的 600 mA 的电流下利用 2.3 - 5.5 V 输入提供 3.3 V 输出。 图 4 所示为发生 PWM 和 PSM 转换的点。</p><p><a href="http://file.elecfans.com/web1/M00/82/6C/o4YBAFw-c5OAa0CsAAFY9jTo2Lk221.jpg"><img src="http://file.elecfans.com/web1/M00/82/6C/o4YBAFw-c5OAa0CsAAFY9jTo2Lk221.jpg" alt="PFM的工作原理、优势及集成功率芯片中实现PFM技术" loading="lazy"></a></p><p>图 4：Analog Devices <a href="https://dfm.elecfans.com/uploads/software/hqdfm.zip?neilian">AD</a>P2108 的 PWM 到 PSM 的阈值。</p><p>其他功率元件制造商也提供双模式开关转换器。 Linear Technology 提供 LTC3412A 器件，该器件具有能在低负载条件下提升效率的“猝发模式”和脉冲跳跃运行功能。 该芯片是一款降压转换器，能在高达 3 A 的电流下将 2.25 - 5.5 V 输入提升至 0.8 - 5 V 输出。</p><p>猝发模式是上文介绍的中间 PFM 技术的一个例子，它能在保持合理瞬态响应能力的同时提升效率。 例如：通过实施猝发模式，在 10 mA 输出电流（VIN 3.3 V、VOUT 2.5 V）下的效率将从 30% 提升至 90%。 LTC3412A 还包括一个传统的脉冲跳跃运行模式，能在轻负载时进一步减小开关损耗。</p><h4 id="延长电池寿命">延长电池寿命</h4><p>设计工程师需要延长便携设备中的电池寿命时，PWM 控制式开关转换器是一种大众化选择。 不过应当牢记，许多便携式产品在大部分时间内是处于低功耗的休眠模式的，只是在工作时点转换器才处于最小能效状态。 虽然对电池的要求较温和，但长时间电流累加在一起，电池寿命就会缩短。</p><p>通过采用具有 PWM 架构、但在低于某一负载阈值时仍可以实现 PFM 和 PSM 技术优势的转换器，设计人员可以在正常运行期间获得 PWM 优势，同时在在许多便携式设备处于空闲状态时，又能在很长时间内保持电池容量。</p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">简单的讲述区别</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>太阳能板向阳自校准</title>
    <link href="https://www.darkfox.top/posts/ca5803cc/"/>
    <id>https://www.darkfox.top/posts/ca5803cc/</id>
    <published>2021-08-23T03:01:43.000Z</published>
    <updated>2022-03-20T06:05:34.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://fastly.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center>   </center><span id="more"></span><h4 id="太阳能自动追踪器">太阳能自动追踪器</h4><p>这个也挺新颖，只是这个玩意有简单的现成的了；我在想可不可以用复杂点的低功耗单片机做出来，准确度更高，耗能更少（虽然没啥）</p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210820183455.png" / loading="lazy"><p>这个玩意的构造很简单，红色面是两个太阳能板；如图</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210820183619.png" alt="" loading="lazy"><br>然后底座和支撑是一个3d打印的小座子，中间打胶固定了一个电机。<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210820183756.png" alt="" loading="lazy"><br>这种电机也挺常见的倒也没啥；<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210820183811.png" alt="" loading="lazy"><em>电机</em><br>原理也挺简单，就是简单的太阳能板连接到了电机上面，有电就转；</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210820190732.png" alt="" loading="lazy"><br>然后这种电机叫做直流电机，只是带了个减速器，简单理解为用来加大扭力的装置。这种电机正接就正转，反接就反转；然后两个太阳能板反着接，就可以在两边电压相同时停下；<br><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210820190755.png" alt="image-20210820190747997" loading="lazy"></p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">&lt;center&gt;   &lt;/center&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>新玩具</title>
    <link href="https://www.darkfox.top/posts/ef933535/"/>
    <id>https://www.darkfox.top/posts/ef933535/</id>
    <published>2021-08-09T11:03:15.000Z</published>
    <updated>2022-03-20T06:05:30.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://fastly.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://fastly.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center>   </center><span id="more"></span><h3 id="前言">前言</h3><p>数位板就不介绍了，省的有人说我打广告，不过我买的这个数位板是真的大，和我笔记本屏幕差不多了（我笔记本13.3）</p><p>电脑上也没有什么可以用来测试这个板子的软件，所以我就用了下微软的那个白板。简单的试了下感觉还可以。</p><p>ps：最后那个图是我瞎画的</p><h3 id="试用">试用</h3><p>这个新玩具看着还可以，颜值也不低，就是不耐脏，可以明显的看出使用痕迹。</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210809191034.jpg" alt="" loading="lazy"></p><p>简单的试用了几下，手感还不错，就是bug略多。因为我有三块屏幕，来回切换时老是卡在一个地方，并且还有空气墙，数位板不能在整块屏幕上写字（(╯▔皿▔)╯）</p><h3 id="修正bug">修正bug</h3><p>但是问题不大，谁让咱是科技宅。经过简单的测试与判断，这个板子应该是在映射时发生了点小问题，导致了不能在比板子大的地方书写。在修正这个bug前，我找到了一个折中方案</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210809191433.jpg" alt="" loading="lazy"></p><p>我有一块这样的小屏幕 ，大概10寸（忽略那条黑线）。50块钱从学弟手里搞的，原来一直当作状态屏使用了（显示电脑的资源）。现在看来可以给它分配个新任务了；</p><p>可以用它来显示whiteboard；</p><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210809191906.jpg" alt="" loading="lazy"></p><p>然后它完美的完成了任务（内心ps：垃圾板子驱动，占我一块屏）；</p><p>试用了一下白板的一些功能，比如图形自动矫正之类的，画了一篇屑作。</p><h3 id="效果">效果</h3><p><img src="https://pic-1304932877.cos.ap-shanghai.myqcloud.com/img/20210809190330.png" alt="瞎几把画的" loading="lazy"></p><p>右下角是我的签名，我打赌你猜不出来写的啥(<em>^_^</em>)</p><h3 id="结尾">结尾</h3><p>我也是刚拿到这个板子一天不到，还有很多功能（bug）还没测试，例如上面的按键，对于手机的适配等。改天没事了测试一下再补上吧。</p><link rel="stylesheet" href="/css/markmap.css" type="text/css">]]></content>
    
    
    <summary type="html">最近觉得做电子笔记不太方便，但是没有太多的money买ipad，于是乎买了个数位板.</summary>
    
    
    
    
  </entry>
  
</feed>
